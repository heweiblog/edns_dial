// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Dial.h"
#include "thrift/protocol/TBinaryProtocol.h"
#include "thrift/protocol/TProtocol.h"
#include "thrift/server/TSimpleServer.h"
#include "thrift/transport/TServerSocket.h"
#include "thrift/transport/TBufferTransports.h"
#include "thrift/transport/TSocket.h"
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <sys/time.h>
#include <vector>
#include <map>
#include <arpa/nameser.h>
#include <resolv.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/resource.h>
#include <signal.h>


#include "Agent.h"
#include "Dial_list.h"
#include "Dial_server.h"
#include "Dial_hash.h"
#include "Dial_mode.h"
#include "Dial_thread_pool.h"
#include "Dial_queue.h"
#include "Dial_icmp.h"
#include "Dial_common.h"
#include "Dial_dns.h"
#include "Dial_ssl.h"
#include "version.h"
#include "Dial_snmp.h"
#include "Dial_ipsec.h"
#include <clib/daemon.h>


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

#define	HASH_POLICY_NUM	0x7F
#define	HASH_NGINX_NUM	0x7FF
#define	HASH_GROUP_NUM	0x7FFF
#define	THREAD_POOL_NUM	100
#define HTTPGET_PORT 	80
#define NETBIOS_PORT 	445
#define	CONFIG_FILE		"/etc/dial_config"

hash_info_t 		hs_health_policy;
hash_info_t 		hs_health_group;
hash_info_t 		hs_nginx_group;
DIAL_LIST_HEAD 		list_dial_srv;
DIAL_LIST_HEAD 		list_snmp;
queue_info_t		queue_info;
threadpool_t 		tp;
int 				primary_flag;	
pthread_mutex_t		client_lock;
bool				client_connecting_flag = false;
bool				registered_flag = false;
dial_cfg_t 			g_cfg;
bool 				s_debug_switch;
pthread_mutex_t 	g_log_lock;
bool 				thread_exit_flag;

map<string,snmp_node_t> snmp_map;
map<string,ipsec_node_t> ipsec_map;
pthread_rwlock_t 	ipsec_map_lock;
pthread_rwlock_t 	snmp_map_lock;

pthread_mutex_t 	health_results_lock;
pthread_mutex_t 	nginx_results_lock;
pthread_mutex_t 	server_results_lock;

vector<DialHealthResult> health_results;
vector<DialNginxResult> nginx_results;
vector<DialServerResult> server_results;

boost::shared_ptr<TTransport> transport_client;  
boost::shared_ptr<TProtocol> protocol_client; 


healthpolicy_info_t *find_healthpolicy_node_by_name(const char *policyname)
{
		DIAL_LIST_NODE *cur = NULL;
		healthpolicy_info_t *hp_node = NULL;

		cur = hs_health_policy.hash_search(&hs_health_policy,policyname);
		hp_node = (healthpolicy_info_t *)cur;

		return hp_node;
}


healthgroup_info_t *find_healthgroup_node(healthgroup_info_t *search_node,hash_info_t *hs)
{
		healthgroup_info_t *hg = NULL;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;	
		int key = 0;

		key = hs->hash_key(search_node->name,hs->num);

		head = &hs->tab[key].head;
		head_node = &hs->tab[key];

		pthread_mutex_lock(&head_node->lock);

		list_for_each(cur, head) 
		{
				hg = (healthgroup_info_t *)cur;
				if(!strcmp(hg->name,search_node->name)) 
				{
						break;
				}
		}

		pthread_mutex_unlock(&head_node->lock);

		if(cur != head)
		{
				return hg;
		}		
		else
		{
				return NULL;
		}		
}


nginxgroup_info_t *find_nginxgroup_node(nginxgroup_info_t *search_node,hash_info_t *hs)
{
		nginxgroup_info_t *ng = NULL;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;   
		int key = 0;

		key = hs->hash_key(search_node->name,hs->num);

		head = &hs->tab[key].head;
		head_node = &hs->tab[key];

		pthread_mutex_lock(&head_node->lock);

		list_for_each(cur, head) 
		{
				ng = (nginxgroup_info_t *)cur;
				if(!strcmp(ng->name,search_node->name)) 
				{
						break;
				}
		}

		pthread_mutex_unlock(&head_node->lock);

		if(cur != head)
		{
				return ng;
		}		
		else
		{
				return NULL;
		}		
}



RetCode::type DialHandler::systemCommand(const SysCommand::type cmdType) 
{
		return RetCode::OK; 
}


void DialHandler::heartBeat(HeartBeatState& _return) 
{
		static int index_sec = 0;

		if(registered_flag)
		{
				_return.__set_mState(ModuleState::REGISTERED);
		}	
		else
		{
				_return.__set_mState(ModuleState::STARTUP);
		}

		_return.__set_serverState(primary_flag);

		if(index_sec % 60 == 0)
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"heartBeat:receive heart beat register_flag=%d,ServerState=%d!!\n",registered_flag,primary_flag);
				index_sec = 0;
		}

		index_sec++;
}


RetCode::type DialHandler::setServerState(const bool enable) 
{
		primary_flag = enable;

		cfg_debug_printf(LOG_LEVEL_BASIC,"setServerState:set Server State = %d\n",primary_flag);

		return RetCode::OK;
}


RetCode::type DialHandler:: addHealthGroup(const std::string& groupName, const std::string& policyName) 
{

		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		healthgroup_info_t *hg = NULL;
		healthgroup_info_t *hg_node = NULL;
		healthgroup_info_t hg_tmp;
		pPolicy_node_t *pPolicy_node = NULL;
		healthpolicy_info_t *policy = NULL;
		int key = 0;

		policy = find_healthpolicy_node_by_name((const char *)policyName.c_str());
		if(NULL == policy) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:find_healthpolicy_node_by_name failed,no policy node<%s>!!!\n",policyName.c_str());
				return RetCode::FAIL;
		}

		pPolicy_node = (pPolicy_node_t *)calloc(1,sizeof(pPolicy_node_t));
		if(NULL == pPolicy_node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:malloc pPolicy_node failed!!!\n");
				return RetCode::FAIL;
		}

		pPolicy_node->pPolicy = policy;
		gettimeofday(&pPolicy_node->t_insert,NULL);
		pPolicy_node->t_insert.tv_sec += pPolicy_node->pPolicy->freq;

		memset(&hg_tmp,0,sizeof(healthgroup_info_t));
		strcpy(hg_tmp.name,groupName.c_str());

		key = hs_health_group.hash_key(hg_tmp.name,hs_health_group.num);
		head = &hs_health_group.tab[key].head;
		head_node = &hs_health_group.tab[key];

		list_for_each_safe(cur,tmp,head) 
		{
				hg = (healthgroup_info_t *)cur;

				if(!strcmp(hg->name,hg_tmp.name)) 
				{
						break;
				}
		}

		if(cur != head) 
		{
				list_add(&hg->pPolicy_head,&pPolicy_node->node);
				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:attach a policy=%s to group=%s!!!\n",policyName.c_str(),groupName.c_str());
		} 
		else 
		{
				hg_node = (healthgroup_info_t *)calloc(1,sizeof(healthgroup_info_t));
				if(NULL == hg_node) 
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:malloc hg_node failed!!!\n");
						free(pPolicy_node);
						return RetCode::FAIL;
				}

				strcpy(hg_node->name,groupName.c_str());
				list_head_init(&hg_node->record_head);
				list_head_init(&hg_node->pPolicy_head);

				list_add(&hg_node->pPolicy_head,&pPolicy_node->node);
				hs_health_group.hash_add(&hs_health_group,hg_node->name,&hg_node->node);

				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:add a new group=%s,policy=%s!!!\n",groupName.c_str(),policyName.c_str());
		}


		return RetCode::OK;
}


#if 0
RetCode::type DialHandler::addHealthGroup(const HealthGroupInfo& health,const std::string& policyName,const std::vector<DialRecord> & records) 
{
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		healthgroup_info_t *hg = NULL;
		healthgroup_info_t *hg_node = NULL;
		healthgroup_info_t hg_tmp;
		pPolicy_node_t *pPolicy_node = NULL;
		healthpolicy_info_t *policy = NULL;
		record_info_t* record = NULL;
		int key = 0,size = 0,i = 0;

		policy = find_healthpolicy_node_by_name((char *)policyName.c_str());
		if(NULL == policy) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:find_healthpolicy_node_by_name failed,no policy node<%s>!!!\n",policyName.c_str());
				return RetCode::FAIL;
		}

		pPolicy_node = (pPolicy_node_t *)calloc(1,sizeof(pPolicy_node_t));
		if(NULL == pPolicy_node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:malloc pPolicy_node failed!!!\n");
				return RetCode::FAIL;
		}

		pPolicy_node->pPolicy = policy;
		gettimeofday(&pPolicy_node->t_insert,NULL);
		pPolicy_node->t_insert.tv_sec += pPolicy_node->pPolicy->freq;

		memset(&hg_tmp,0,sizeof(healthgroup_info_t));
		strcpy(hg_tmp.viewname,health.viewName.c_str());
		strcpy(hg_tmp.zonename,health.zoneName.c_str());
		strcpy(hg_tmp.name,health.name.c_str());

		key = hs_health_group.hash_key((void *)&hg_tmp,hs_health_group.num);
		head = &hs_health_group.tab[key].head;
		head_node = &hs_health_group.tab[key];

		pthread_mutex_lock(&head_node->lock);

		list_for_each(cur, head) 
		{
				hg = (healthgroup_info_t *)cur;
				if(!strcmp(hg->viewname,hg_tmp.viewname) && !strcmp(hg->zonename,hg_tmp.zonename) && !strcmp(hg->name,hg_tmp.name)) 
				{
						break;
				}
		}

		pthread_mutex_unlock(&head_node->lock);

		if(cur != head) 
		{
				list_add(&hg->pPolicy_head,&pPolicy_node->node);

				head_node = &hg->record_head;
				head = &head_node->head;

				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:attach a policy=%s to group=%s!!!\n",policyName.c_str(),health.name.c_str());
		} 
		else 
		{
				hg_node = (healthgroup_info_t *)calloc(1,sizeof(healthgroup_info_t));
				if(NULL == hg_node) 
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:malloc hg_node failed!!!\n");
						free(pPolicy_node);
						return RetCode::FAIL;
				}

				strcpy(hg_node->viewname,health.viewName.c_str());
				strcpy(hg_node->zonename,health.zoneName.c_str());
				strcpy(hg_node->name,health.name.c_str());
				list_head_init(&hg_node->record_head);
				list_head_init(&hg_node->pPolicy_head);

				list_add(&hg_node->pPolicy_head,&pPolicy_node->node);
				hs_health_group.hash_add(&hs_health_group,hg_node,&hg_node->node);

				head_node = &hg_node->record_head;
				head = &head_node->head;

				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:add a new group=%s,policy=%s\n",health.name.c_str(),policyName.c_str());
		}

		size = records.size();

		//cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:record size=%d\n",size);

		for(i = 0 ; i < size ; i++)
		{
				list_for_each_safe(cur,tmp,head)
				{
						record = (record_info_t*)cur;			
						if(!strcmp(record->rid,records[i].rid.c_str()))
						{
								break;
						}
				}

				if(cur != head)
				{
						//cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord already exist!!!:healthgroup=%s,ip=%s\n",health.name.c_str(),records.ip.addr.c_str());
						continue;
				}
				else
				{
						record_info_t *r_node = (record_info_t *)calloc(1,sizeof(record_info_t));
						if(NULL == r_node) 
						{
								cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord:calloc record_info_t failed!!!\n");
								return RetCode::FAIL;
						}

						strcpy(r_node->rid,records[i].rid.c_str());
						r_node->ip.version = records[i].ip.version;
						strcpy(r_node->ip.addr,records[i].ip.addr.c_str());
						r_node->priority = records[i].priority;
						r_node->ttl= records[i].ttl;
						r_node->enabled = records[i].enabled;

						list_add(head_node,&r_node->node);

						cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord success!!!:healthgroup=%s,ip=%s\n",health.name.c_str(),records[i].ip.addr.c_str());
				}
		}


		return RetCode::OK;

}


RetCode::type DialHandler:: modHealthGroup(const HealthGroupInfo& health, const std::string& policyName) 
{
		cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthGroup:start!!!name = %s,policyName=%s\n",health.name.c_str(),policyName.c_str());

		healthgroup_info_t hg_node;
		int key;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		healthgroup_info_t *hg = NULL;
		RetCode::type ret = RetCode::OK;

		memset(&hg_node,0,sizeof(healthgroup_info_t));

		strcpy(hg_node.viewname,health.viewName.c_str());
		strcpy(hg_node.zonename,health.zoneName.c_str());
		strcpy(hg_node.name,health.name.c_str());

		hg_node.pPolicy = find_healthpolicy_node_by_name((char *)policyName.c_str());
		if(NULL == hg_node.pPolicy) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthGroup:find_healthpolicy_node_by_name failed,no policy node<%s>!!!\n",policyName.c_str());
				//free(hg_node);
				return RetCode::FAIL;
		}

		key = hs_health_group.hash_key((void *)&hg_node,hs_health_group.num);

		head = &hs_health_group.tab[key].head;
		head_node = &hs_health_group.tab[key];

		pthread_mutex_lock(&head_node->lock);

		list_for_each(cur, head) 
		{
				hg = (healthgroup_info_t *)cur;
				if(!strcmp(hg->viewname,hg_node.viewname) && !strcmp(hg->zonename,hg_node.zonename) && !strcmp(hg->name,hg_node.name)) 
				{
						break;
				}
		}

		if(cur != head) 
		{
				hg->pPolicy = hg_node.pPolicy;
				//debug_printf(LOG_LEVEL_BASIC,"modHealthGroup:success!!!\n");		
		}
		else 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthGroup:can not find the target node!!!viewname=%s,zonename=%s,name=%s\n",
								hg_node.viewname,hg_node.zonename,hg_node.name);
				ret = RetCode::FAIL;
		}

		pthread_mutex_unlock(&head_node->lock);

		return ret;
}
#endif



RetCode::type DialHandler:: delHealthGroup(const std::string& groupName, const std::string& policyName) 
{
		healthgroup_info_t hg_node;
		int key = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_NODE *node = NULL;
		DIAL_LIST_NODE *record_head_node = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		DIAL_LIST_HEAD *record_head = NULL;
		healthgroup_info_t *hg = NULL;
		record_info_t* record_node = NULL;
		pPolicy_node_t *pPolicy_node = NULL;
		RetCode::type ret = RetCode::OK;

		memset(&hg_node,0,sizeof(healthgroup_info_t));
		
		strcpy(hg_node.name,groupName.c_str());

		key = hs_health_group.hash_key(hg_node.name,hs_health_group.num);
		node = hs_health_group.hash_search(&hs_health_group,hg_node.name);
		if(NULL == node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:failed,can not find health group node group=%s!!!\n",groupName.c_str());
				return RetCode::FAIL;
		}

		head_node = &hs_health_group.tab[key];
		hg = (healthgroup_info_t *)node;
		head = &hg->pPolicy_head.head;


		list_for_each_safe(cur,tmp,head) 
		{
				pPolicy_node = (pPolicy_node_t *)cur;
				if(!strcmp(pPolicy_node->pPolicy->policyname,policyName.c_str()))
				{
						break;
				}	
		}


		if(cur != head) 
		{
				list_del(&hg->pPolicy_head,&pPolicy_node->node);
				free(pPolicy_node);
				cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:del policy=%s from healthgroup=%s\n",policyName.c_str(),groupName.c_str());
					
				if(hg->pPolicy_head.num < 1)
				{
						record_head = &hg->record_head;
						record_head_node = &(record_head->head);
							

						list_for_each_safe(cur,tmp,record_head_node)
						{
								list_del(record_head,cur);
								record_node = (record_info_t *)cur;
								cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:del record ip=%s from healthgroup=%s\n",(record_node->ip).addr,hg->name);
								free(record_node);
								record_node = NULL;
						}

						list_del(head_node,&hg->node);
						free(hg);
						hg = NULL;

						cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:del all policy and record success!!! healthgroup = %s\n",groupName.c_str());
				}
				

		}
		else
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:can not find target policynode=%s from group=%s!!!\n",policyName.c_str(),groupName.c_str());
				return RetCode::FAIL;
		}


		return RetCode::OK;
}



RetCode::type DialHandler:: addHealthRecord(const std::string& groupName, const std::vector<DialRecord> & records) 
{
		int size = 0,i = 0;
		healthgroup_info_t hg_node;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		healthgroup_info_t *hg = NULL;
		record_info_t* record = NULL;

		memset(&hg_node,0,sizeof(healthgroup_info_t));
		strcpy(hg_node.name,groupName.c_str());

		cur = hs_health_group.hash_search(&hs_health_group,hg_node.name);
		if(NULL == cur) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord:failed,can not find health group node!!!,group=%s\n",groupName.c_str());
				return RetCode::FAIL;
		}


		hg = (healthgroup_info_t *)cur;

		head_node = &hg->record_head;
		head = &head_node->head;
		
		size = records.size();

		for(i = 0 ; i < size ; i++)
		{
				list_for_each_safe(cur,tmp,head)
				{
						record = (record_info_t*)cur;			
						if(!strcmp(record->rid,records[i].rid.c_str()))
						{
								break;
						}
				}

				if(cur != head)
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord already exist!!!:healthgroup=%s,ip=%s\n",groupName.c_str(),records[i].ip.addr.c_str());
						continue;
				}
				else
				{
						record_info_t *r_node = (record_info_t *)calloc(1,sizeof(record_info_t));
						if(NULL == r_node) 
						{
								cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord:calloc record_info_t failed!!!\n");
								return RetCode::FAIL;
						}

						strcpy(r_node->rid,records[i].rid.c_str());
						r_node->ip.version = records[i].ip.version;
						strcpy(r_node->ip.addr,records[i].ip.addr.c_str());
						r_node->priority = records[i].priority;
						r_node->ttl= records[i].ttl;
						r_node->enabled = records[i].enabled;

						list_add(head_node,&r_node->node);

						cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord success!!!:healthgroup=%s,ip=%s\n",groupName.c_str(),records[i].ip.addr.c_str());
				}
		}


		return RetCode::OK;
}


#if 0
RetCode::type DialHandler:: modHealthRecord(const HealthGroupInfo& health, const DialRecord& rec) 
{
		healthgroup_info_t hg_node;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		healthgroup_info_t *hg = NULL;
		record_info_t *prec = NULL;
		RetCode::type ret = RetCode::OK;


		memset(&hg_node,0,sizeof(healthgroup_info_t));
		strcpy(hg_node.viewname,health.viewName.c_str());
		strcpy(hg_node.zonename,health.zoneName.c_str());
		strcpy(hg_node.name,health.name.c_str());


		cur = hs_health_group.hash_search(&hs_health_group,(char *)&hg_node);
		if(NULL == cur) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthRecord:failed,can not find health group node!!!\n");
				return RetCode::FAIL;
		}

		hg = (healthgroup_info_t *)cur;

		head_node = &hg->record_head;
		head = &head_node->head;

		pthread_mutex_lock(&head_node->lock);

		list_for_each(cur, head) 
		{
				prec = (record_info_t *)cur;
				if(!strcmp(prec->rid,rec.rid.c_str()))
				{
						break;
				}	
		}
		if(cur != head) 
		{
				strcpy(prec->rid,rec.rid.c_str());
				prec->ip.version = rec.ip.version;
				strcpy(prec->ip.addr,rec.ip.addr.c_str());
				prec->priority = rec.priority;
				prec->ttl= rec.ttl;
				prec->enabled = rec.enabled;
				cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthRecord:success!!!dn=%s,ip=%s,version=%d,priority=%d,ttl=%d,enabaled=%d\n",health.name.c_str(),rec.ip.addr.c_str(),rec.ip.version,rec.priority,rec.ttl,rec.enabled);

		} 
		else 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthRecord:failed,can not find target node.viewname=%s,zonename=%s,name=%s!!!\n",hg_node.viewname,hg_node.zonename,hg_node.name);

				ret = RetCode::FAIL;
		}

		pthread_mutex_unlock(&head_node->lock);


		return ret;
}
#endif


RetCode::type DialHandler:: delHealthRecord(const std::string& groupName, const std::vector<DialRecord> & records) 
{
		int size = 0,i = 0;
		healthgroup_info_t hg_node;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_NODE *node = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		healthgroup_info_t *hg = NULL;
		record_info_t* record = NULL;

		memset(&hg_node,0,sizeof(healthgroup_info_t));
		strcpy(hg_node.name,groupName.c_str());

		node = hs_health_group.hash_search(&hs_health_group,hg_node.name);
		if(NULL == node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthRecord:failed,can not find health group node!!!groupname=%s\n",groupName.c_str());
				return RetCode::FAIL;
		}

		hg = (healthgroup_info_t *)node;

		head_node = &hg->record_head;
		head = &head_node->head;

		size = records.size();


		for(i = 0 ; i < size ; i++)
		{
				list_for_each_safe(cur,tmp,head)
				{
						record = (record_info_t*)cur;			
						if(!strcmp(record->rid,records[i].rid.c_str()))
						{
								break;
						}
				}
				if(cur != head)
				{
						list_del(head_node,cur);
						cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthRecord:del record success,ip=%s,healthgroup=%s\n",(record->ip).addr,hg->name);
						free(record);
						record = NULL;
				}
				else
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthRecord:del record fialed,ip=%s,healthgroup=%s\n",records[i].ip.addr.c_str(),hg->name);
						pthread_mutex_unlock(&head_node->lock); 
						return RetCode::FAIL; 
				}
		}


		return RetCode::OK;

}


void init_dial_option(dial_option_t *dialoption,const DialOption &option)
{
		unsigned int i = 0;
		match_code_t *mcode = NULL;


		strcpy(dialoption->dest_url,option.destUrl.c_str());	
		strcpy(dialoption->test_method,option.testMethod.c_str());	
		strcpy(dialoption->expect_match,option.expectMatch.c_str());	

		list_head_init(&dialoption->code_head);

		for(i= 0;i < option.expectCode.size();i++) 
		{
				mcode = (match_code_t *)calloc(1,sizeof(match_code_t));
				mcode->code = option.expectCode[i];
				list_add(&dialoption->code_head,&mcode->node);	
				cfg_debug_printf(LOG_LEVEL_BASIC,"init_dial_option:match_code=%d\n",mcode->code);
		}
		
		if(strlen(dialoption->dest_url))
		{
			cfg_debug_printf(LOG_LEVEL_BASIC,"init_dial_option:dest_url=%s\n",dialoption->dest_url);
			cfg_debug_printf(LOG_LEVEL_BASIC,"init_dial_option:test_method=%s,expect_match=%s,matchcode_num=%d\n",dialoption->test_method,dialoption->expect_match,option.expectCode.size());
		}	
		else
		{
			cfg_debug_printf(LOG_LEVEL_BASIC,"init_dial_option:dest_url=%s,test_method=%s,expect_match=%s,matchcode_num=%d\n",dialoption->dest_url,dialoption->test_method,dialoption->expect_match,option.expectCode.size());
		}

}


void modify_dial_option(dial_option_t *dialoption, const DialOption &option)
{
		unsigned int i = 0;
		match_code_t *mcode = NULL;
		DIAL_LIST_NODE *cur,*tmp,*head;

		memset(dialoption->dest_url,0,sizeof(dialoption->dest_url));
		memset(dialoption->test_method,0,sizeof(dialoption->test_method));
		memset(dialoption->expect_match,0,sizeof(dialoption->expect_match));

		strcpy(dialoption->dest_url,option.destUrl.c_str());	
		strcpy(dialoption->test_method,option.testMethod.c_str());	
		strcpy(dialoption->expect_match,option.expectMatch.c_str());	

		head = &dialoption->code_head.head;

		list_for_each_safe(cur,tmp,head) 
		{
				list_del(&dialoption->code_head,cur);
				mcode = (match_code_t *)cur;
				free(mcode);
		}

		for(i= 0;i < option.expectCode.size();i++) 
		{
				mcode = (match_code_t *)calloc(1,sizeof(match_code_t));
				mcode->code = option.expectCode[i];
				list_add(&dialoption->code_head,&mcode->node);	
		}
}


void del_dial_option(dial_option_t *dialoption)
{
		int i = 0;
		match_code_t *mcode = NULL;
		DIAL_LIST_NODE *cur,*tmp,*head;


		head = &dialoption->code_head.head;

		list_for_each_safe(cur,tmp,head) 
		{
				list_del(&dialoption->code_head,cur);
				mcode = (match_code_t *)cur;
				free(mcode);
		}
}



RetCode::type DialHandler:: addHealthPolicy(const HealthPolicyInfo& policy) 
{

		healthpolicy_info_t *hp_node = (healthpolicy_info_t *)malloc(sizeof(healthpolicy_info_t));
		if(NULL == hp_node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthPolicy:malloc failed!!!\n");
				return RetCode::FAIL;
		}

		memset(hp_node,0,sizeof(healthpolicy_info_t));

		strcpy(hp_node->policyname,policy.name.c_str());
		hp_node->method = policy.method;
		hp_node->port = policy.port;
		hp_node->freq = policy.freq;
		hp_node->times = policy.times;
		hp_node->passed = policy.passed;

		init_dial_option(&hp_node->dial_option,policy.option);

		hs_health_policy.hash_add(&hs_health_policy,hp_node->policyname,&hp_node->node);

		cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthPolicy:success!!!,policyname=%s,frep=%d,times=%d,passed=%d\n",policy.name.c_str(),policy.freq,policy.times,policy.passed);

		return RetCode::OK;
}


RetCode::type DialHandler:: modHealthPolicy(const HealthPolicyInfo& policy) 
{
		int key = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		healthpolicy_info_t *hp_node = NULL;
		RetCode::type ret = RetCode::OK;

		key = hs_health_policy.hash_key((const char *)policy.name.c_str(),hs_health_policy.num);

		head = &hs_health_policy.tab[key].head;
		head_node = &hs_health_policy.tab[key];

		pthread_mutex_lock(&head_node->lock);

		list_for_each(cur, head) 
		{
				hp_node = (healthpolicy_info_t *)cur;
				if(!strcmp(policy.name.c_str(),hp_node->policyname)) 
				{
						break;
				}
		}

		if(NULL != head) 
		{
				hp_node->method = policy.method;
				hp_node->port = policy.port;
				hp_node->freq = policy.freq;
				hp_node->times = policy.times;
				hp_node->passed = policy.passed;
				modify_dial_option(&hp_node->dial_option,policy.option);
				cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthPolicy:success!!!,policyname=%s\n",policy.name.c_str());

		}
		else 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthPolicy:can not find the target node!!!name=%s\n",policy.name.c_str());
				ret = RetCode::FAIL;
		}
		pthread_mutex_unlock(&head_node->lock);


		return ret;
}


RetCode::type DialHandler:: delHealthPolicy(const HealthPolicyInfo& policy) 
{
		int key = 0;
		DIAL_LIST_NODE *cur = NULL;
		healthpolicy_info_t *hp_node = NULL;
		RetCode::type ret = RetCode::OK;

		cur = hs_health_policy.hash_search(&hs_health_policy,(const char *)policy.name.c_str());
		key = hs_health_policy.hash_key((const char*)policy.name.c_str(),hs_health_policy.num);

		if(NULL != cur) 
		{
				hp_node = (healthpolicy_info_t *)cur;
				list_del(&hs_health_policy.tab[key],cur);
				del_dial_option(&hp_node->dial_option);
				free(hp_node);
				cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthPolicy:success!!!,policyname=%s\n",policy.name.c_str());
		}
		else 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthPolicy:can not find the target node!!!name=%s\n",policy.name.c_str());
				ret = RetCode::FAIL;
		}


		return ret;

}


RetCode::type DialHandler::dialServerConfig(const DialServerType::type typ, const bool allowed) 
{

		g_cfg.srv_cfg.allowed[typ] = allowed;

		cfg_debug_printf(LOG_LEVEL_BASIC,"dialServerConfig:success!!!,server_type=%d,allowed=%d\n",typ,allowed);

		return RetCode::OK;
}



RetCode::type DialHandler::addDialServer(const ObjectId& rid, const IpAddr& ip, const DialServerType::type typ) 
{

		dial_srv_node_t *srv_node = (dial_srv_node_t *)calloc(1,sizeof(dial_srv_node_t));
		if(NULL == srv_node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addDialServer:malloc failed!!!\n");
				return RetCode::FAIL;
		}

		strcpy(srv_node->ip.addr,ip.addr.c_str());
		srv_node->ip.version = ip.version;
		srv_node->srv_tpye = typ;
		strcpy(srv_node->srv_id,rid.c_str());
		gettimeofday(&srv_node->t_insert,NULL);
		srv_node->t_insert.tv_sec += g_cfg.srv_cfg.interval;

		list_add(&list_dial_srv,&srv_node->node);

		cfg_debug_printf(LOG_LEVEL_BASIC,"addDialServer:success!!!,ip=%s,type=%d,srv_id=%s\n",ip.addr.c_str(),typ,rid.c_str());

		return RetCode::OK;
}


RetCode::type DialHandler::delDialServer(const ObjectId& rid) 
{

		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = &list_dial_srv.head;
		dial_srv_node_t *srv_node  = NULL;

		list_for_each_safe(cur, tmp, head) 
		{
				srv_node = (dial_srv_node_t *)cur;

				if(!strcmp(srv_node->srv_id,rid.c_str()))
				{
						break;
				}
		}
		if(cur == head) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delDialServer failed!!!:srv_id=%s\n",rid.c_str());
				return RetCode::FAIL;
		}
		else
		{
				list_del(&list_dial_srv,cur);
				free(srv_node);
				cfg_debug_printf(LOG_LEVEL_BASIC,"delDialServer:success!!!,srv_id=%s\n",rid.c_str());
				return RetCode::OK;
		}

}


RetCode::type DialHandler::addIpSec(const SysIpSec& ipsec,const int32_t interval)
{
		ipsec_node_t ipsec_node;
		ipsec_node.work_flag = false;
		ipsec_node.tid = 0;
		ipsec_node.ipsec = ipsec;
		ipsec_node.interval = interval;
		pthread_rwlock_wrlock(&ipsec_map_lock);
		ipsec_map[ipsec.recordId] = ipsec_node;
		pthread_rwlock_unlock(&ipsec_map_lock);
		cfg_debug_printf(LOG_LEVEL_BASIC,"addIpSec:success!!!,ipsec=%s,ipsecid=%s\n",ipsec.ipsec.ip.addr.c_str(),ipsec.recordId.c_str());
		return RetCode::OK;
}


RetCode::type DialHandler::delIpSec(const std::string& ipsecid)
{
		int size = 0,res = 0;
		map<string,ipsec_node_t>::iterator iter;

		iter = ipsec_map.find(ipsecid);

		if(iter == ipsec_map.end())
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delIpSec:failed!!!,can not find ipsec_id=%s\n",ipsecid.c_str());
				return RetCode::FAIL;
		}
		
		iter->second.work_flag = false;
		res = pthread_join(iter->second.tid,NULL);
		if(0 != res)
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delIpSec:pthread_join failed!!!,ipsec_id=%s\n",ipsecid.c_str());	
		}

		pthread_rwlock_wrlock(&ipsec_map_lock);
		size = ipsec_map.erase(ipsecid);
		pthread_rwlock_unlock(&ipsec_map_lock);

		if(size > 0)
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delIpSec:success!!!,ipsec_id=%s\n",ipsecid.c_str());
				return RetCode::OK;
		}		
		else
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delIpSec:failed!!!,ipsec_id=%s\n",ipsecid.c_str());
				return RetCode::FAIL;
		}
}


RetCode::type DialHandler::addSnmpGroupInfo(const SnmpGroupInfo& snmp)
{
		snmp_node_t snmp_node;
		snmp_node.tid = 0;
		snmp_node.work_flag = false;
		pthread_rwlock_init(&snmp_node.process_lock,NULL);
		snmp_node.snmp = snmp;
		pthread_rwlock_wrlock(&snmp_map_lock);
		snmp_map[snmp.name] = snmp_node;
		pthread_rwlock_unlock(&snmp_map_lock);
		cfg_debug_printf(LOG_LEVEL_BASIC,"addSnmp:success!!!,ip=%s,id=%s\n",snmp.ip.addr.c_str(),snmp.name.c_str());
		return RetCode::OK;
}


RetCode::type DialHandler::delSnmpGroupInfo(const std::string& snmp)
{
		int size = 0,res = 0;
		map<string,snmp_node_t>::iterator iter;
		
		iter = snmp_map.find(snmp);
		if(iter == snmp_map.end())
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delSnmp:failed!!!,can not fand snmp_node id=%s\n",snmp.c_str());
				return RetCode::FAIL;
		}

		iter->second.work_flag = false;
		res = pthread_join(iter->second.tid,NULL);
		if(0 != res)
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delSnmp:pthread_join failed!!!,snmp_node id=%s\n",snmp.c_str());	
		}
		
		pthread_rwlock_wrlock(&snmp_map_lock);
		iter->second.process.clear();
		pthread_rwlock_destroy(&iter->second.process_lock);
		size = snmp_map.erase(snmp);
		pthread_rwlock_unlock(&snmp_map_lock);

		if(size > 0)
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delSnmp:success!!!,id=%s\n",snmp.c_str());
				return RetCode::OK;
		}
		else
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delSnmp:failed!!!,id=%s\n",snmp.c_str());
				return RetCode::FAIL;
		}
}


RetCode::type DialHandler::addSnmpProcessInfo(const std::string& snmp, const std::string& processname)
{
		ProcessInfo process;	
		map<string,snmp_node_t>::iterator iter;
		
		iter = snmp_map.find(snmp);
		if(iter == snmp_map.end())
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addprocess:failed!!!,snmp node not exist snmp_id=%s,process=%s,id=%s\n",snmp.c_str(),processname.c_str(),snmp.c_str());
				return RetCode::FAIL;
		}

		process.name = processname;
		pthread_rwlock_wrlock(&iter->second.process_lock);
		snmp_map[snmp].process.push_back(process);
		pthread_rwlock_unlock(&iter->second.process_lock);
		cfg_debug_printf(LOG_LEVEL_BASIC,"addprocess:success!!!,snmp_id=%s,process=%s,id=%s\n",snmp.c_str(),processname.c_str(),snmp.c_str());

		return RetCode::OK;
}


RetCode::type DialHandler::delSnmpProcessInfo(const std::string& snmp, const std::string& processname)
{
		map<string,snmp_node_t>::iterator iter;
		vector<ProcessInfo>::iterator piter;
		
		iter = snmp_map.find(snmp);
		if(iter == snmp_map.end())
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delprocess:failed!!!,can not fand snmp_node id=%s\n",snmp.c_str());
				return RetCode::FAIL;
		}

		for(piter = iter->second.process.begin() ; piter != iter->second.process.end() ; piter++)
		{
				if(piter->name == processname)
				{
						pthread_rwlock_wrlock(&iter->second.process_lock);
						iter->second.process.erase(piter);
						pthread_rwlock_unlock(&iter->second.process_lock);
						cfg_debug_printf(LOG_LEVEL_BASIC,"delprocess:success!!!,process=%s,id=%s\n",processname.c_str(),snmp.c_str());
						return RetCode::OK;
				}
		}
		
		cfg_debug_printf(LOG_LEVEL_BASIC,"delprocess:failed!!!,can not find process=%s,id=%s\n",processname.c_str(),snmp.c_str());
		return RetCode::FAIL;
}


RetCode::type DialHandler::addNginxGroup(const std::string& groupName, const std::string& policyName) 
{
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		nginxgroup_info_t *ng = NULL;
		nginxgroup_info_t ng_node;
		nginxgroup_info_t *nginx_node = NULL;
		pPolicy_node_t *pPolicy_node = NULL;
		healthpolicy_info_t *policy = NULL;
		int key = 0;

		policy = find_healthpolicy_node_by_name((const char *)policyName.c_str());
		if(NULL == policy) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:can not find policy node<%s>!!!\n",policyName.c_str());
				return RetCode::FAIL;
		}

		pPolicy_node = (pPolicy_node_t *)calloc(1,sizeof(pPolicy_node_t));
		if(NULL == pPolicy_node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:malloc pPolicy_node failed!!!\n");
				return RetCode::FAIL;
		}

		pPolicy_node->pPolicy = policy;
		gettimeofday(&pPolicy_node->t_insert,NULL);
		pPolicy_node->t_insert.tv_sec += pPolicy_node->pPolicy->freq;


		memset(&ng_node,0,sizeof(nginxgroup_info_t));
		strcpy(ng_node.name,groupName.c_str());

		key = hs_nginx_group.hash_key(ng_node.name,hs_nginx_group.num);

		head = &hs_nginx_group.tab[key].head;
		head_node = &hs_nginx_group.tab[key];


		list_for_each_safe(cur,tmp,head) 
		{
				ng = (nginxgroup_info_t *)cur;
				if(!strcmp(ng->name,ng_node.name)) 
				{
						break;
				}
		}


		if(cur != head) 
		{
				list_add(&ng->pPolicy_head,&pPolicy_node->node);	
				cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:attach a policy=%s to nginxgroup=%s!!!\n",policyName.c_str(),groupName.c_str());		
		}
		else 
		{
				nginx_node = (nginxgroup_info_t *)calloc(1,sizeof(nginxgroup_info_t));
				if(NULL == nginx_node) 
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:malloc nginx_node failed!!!\n");
						free(pPolicy_node);
						return RetCode::FAIL;
				}		

				strcpy(nginx_node->name,groupName.c_str());
				list_head_init(&nginx_node->srv_head);
				list_head_init(&nginx_node->pPolicy_head);

				list_add(&nginx_node->pPolicy_head,&pPolicy_node->node);
				hs_nginx_group.hash_add(&hs_nginx_group,nginx_node->name,&nginx_node->node);

				cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:add a new nginxgroup=%s,policy=%s\n",groupName.c_str(),policyName.c_str());
		}


		return RetCode::OK;

}


#if 0
RetCode::type DialHandler::addNginxGroup(const std::string&groupName,const std::string&policyName,const std::vector<DialNginxServer>&servers)
{
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		nginxgroup_info_t *ng = NULL;
		nginxgroup_info_t ng_node;
		nginxgroup_info_t *nginx_node = NULL;
		pPolicy_node_t *pPolicy_node = NULL;
		healthpolicy_info_t *policy = NULL;
		nginx_srv_t *nginx_srv = NULL;
		int key = 0,size = 0,i = 0;

		policy = find_healthpolicy_node_by_name((char *)policyName.c_str());
		if(NULL == policy) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:can not find policy node<%s>!!!\n",policyName.c_str());
				return RetCode::FAIL;
		}

		pPolicy_node = (pPolicy_node_t *)calloc(1,sizeof(pPolicy_node_t));
		if(NULL == pPolicy_node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:malloc pPolicy_node failed!!!\n");
				return RetCode::FAIL;
		}

		pPolicy_node->pPolicy = policy;
		gettimeofday(&pPolicy_node->t_insert,NULL);
		pPolicy_node->t_insert.tv_sec += pPolicy_node->pPolicy->freq;

		memset(&ng_node,0,sizeof(nginxgroup_info_t));
		strcpy(ng_node.name,groupName.c_str());

		key = hs_nginx_group.hash_key((void *)ng_node.name,hs_nginx_group.num);

		head = &hs_nginx_group.tab[key].head;
		head_node = &hs_nginx_group.tab[key];

		pthread_mutex_lock(&head_node->lock);

		list_for_each(cur, head) 
		{
				ng = (nginxgroup_info_t *)cur;
				if(!strcmp(ng->name,ng_node.name)) 
				{
						break;
				}
		}

		pthread_mutex_unlock(&head_node->lock);

		if(cur != head) 
		{
				list_add(&ng->pPolicy_head,&pPolicy_node->node);

				head_node = &ng->srv_head;
				head = &head_node->head;

				cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:attach a policy=%s to nginxgroup=%s!!!\n",policyName.c_str(),groupName.c_str());		
		}
		else 
		{
				nginx_node = (nginxgroup_info_t *)calloc(1,sizeof(nginxgroup_info_t));
				if(NULL == nginx_node) 
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:malloc nginx_node failed!!!\n");
						free(pPolicy_node);
						return RetCode::FAIL;
				}		

				strcpy(nginx_node->name,groupName.c_str());
				list_head_init(&nginx_node->srv_head);
				list_head_init(&nginx_node->pPolicy_head);

				list_add(&nginx_node->pPolicy_head,&pPolicy_node->node);
				hs_nginx_group.hash_add(&hs_nginx_group,nginx_node->name,&nginx_node->node);

				head_node = &nginx_node->srv_head;
				head = &head_node->head;

				cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:add a new nginxgroup=%s,policy=%s\n",groupName.c_str(),policyName.c_str());
		}

		size = servers.size();

		//cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:servers size=%d\n",size);

		for(i = 0 ; i < size ; i++)
		{

				list_for_each(cur,head)
				{
						nginx_srv = (nginx_srv_t*)cur;			
						if(!strcmp(nginx_srv->url,servers[i].localURL.c_str()))
						{
								break;
						}
				}

				if(cur != head)
				{
						//cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:already exist!!!nginxgroup=%s,url=%s\n",groupName.c_str(),servers[i].localURL.c_str());
						continue;
				}
				else
				{
						nginx_srv_t *srv_node = (nginx_srv_t *)calloc(1,sizeof(nginx_srv_t));
						if(NULL == srv_node) 
						{
								cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:malloc failed!!!\n");
								return RetCode::FAIL;
						}
						srv_node->priority = servers[i].priority;
						strcpy(srv_node->url,servers[i].localURL.c_str());
						list_add(head_node,&srv_node->node);
						cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:success!!!nginxgroup=%s,url=%s\n",groupName.c_str(),servers[i].localURL.c_str());
				}
		}

		return RetCode::OK;


}

RetCode::type DialHandler::modNginxGroup(const std::string& groupName, const std::string& policyName)
{

		nginxgroup_info_t ng_node;
		int key = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		nginxgroup_info_t *ng = NULL;
		RetCode::type ret = RetCode::OK;

		memset(&ng_node,0,sizeof(nginxgroup_info_t));

		strcpy(ng_node.name,groupName.c_str());

		ng_node.pPolicy = find_healthpolicy_node_by_name((char *)policyName.c_str());
		if(NULL == ng_node.pPolicy) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxGroup:find_healthpolicy_node_by_name failed,no policy node<%s>!!!\n",policyName.c_str());
				return RetCode::FAIL;
		}

		key = hs_nginx_group.hash_key((void *)ng_node.name,hs_nginx_group.num);

		head = &hs_nginx_group.tab[key].head;
		head_node = &hs_nginx_group.tab[key];

		pthread_mutex_lock(&head_node->lock);

		list_for_each(cur, head) 
		{
				ng = (nginxgroup_info_t *)cur;
				if(!strcmp(ng->name,ng_node.name)) 
				{
						break;
				}
		}

		if(cur != head) 
		{
				ng->pPolicy = ng_node.pPolicy;
				ng->enable = dialing;
		} 
		else
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxGroup:can not find the target node!!!name=%s\n",ng_node.name);
				ret = RetCode::FAIL;
		}

		pthread_mutex_unlock(&head_node->lock);

		cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxGroup:success!!!groupName = %s,policyName=%s,dialing=%d\n",groupName.c_str(),policyName.c_str(),dialing);

		cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxGroup:success!!!groupName = %s,policyName=%s\n",groupName.c_str(),policyName.c_str());

		return ret;

}
#endif


RetCode::type DialHandler::delNginxGroup(const std::string& groupName, const std::string& policyName) 
{
		nginxgroup_info_t ng_node;
		int key = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *node = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_NODE *srv_head_node = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		DIAL_LIST_HEAD *srv_head = NULL;
		nginxgroup_info_t *ng = NULL;
		pPolicy_node_t *pPolicy_node = NULL;
		nginx_srv_t* srv_node = NULL;

		memset(&ng_node,0,sizeof(nginxgroup_info_t));
		strcpy(ng_node.name,groupName.c_str());

		key = hs_nginx_group.hash_key(ng_node.name,hs_nginx_group.num);
		node = hs_nginx_group.hash_search(&hs_nginx_group,(char *)ng_node.name);

		if(NULL == node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxGroup:failed,can not find nginx groupnode=%s!!!\n",groupName.c_str());
				return RetCode::FAIL;
		}

		head_node = &hs_nginx_group.tab[key];
		ng = (nginxgroup_info_t *)node;
		head = &ng->pPolicy_head.head;


		list_for_each_safe(cur,tmp,head) 
		{
				pPolicy_node = (pPolicy_node_t *)cur;
				if(!strcmp(pPolicy_node->pPolicy->policyname,policyName.c_str()))
				{
						break;
				}	
		}


		if(cur != head) 
		{
				list_del(&ng->pPolicy_head,&pPolicy_node->node);
				free(pPolicy_node);
				cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxGroup:del policy = %s from nginxgroup = %s\n",policyName.c_str(),groupName.c_str());

				if(ng->pPolicy_head.num < 1)
				{
								
						srv_head = &(ng->srv_head);
						srv_head_node = &(srv_head->head);

						list_for_each_safe(cur,tmp,srv_head_node) 
						{
								list_del(srv_head,cur);
								srv_node = (nginx_srv_t *)cur;
								cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxGroup:del nginx_srv=%s from nginxgroupname=%s\n",srv_node->url,groupName.c_str());
								free(srv_node);
						}
					
						list_del(head_node,&ng->node);
						free(ng);
						cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxGroup:success!!!,del all nginx_srv and policy!!!,nginxgroupname=%s\n",groupName.c_str());
				}
				
				
		}
		else
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxGroup:can not find target policynode=%s from nginxgroup=%s!!!\n",policyName.c_str(),groupName.c_str());

				return RetCode::FAIL;
		}

		return RetCode::OK;

}


RetCode::type DialHandler::addNginxServer(const std::string& groupName, const std::vector<DialNginxServer>&servers) 
{
		int size = 0, i = 0;
		nginxgroup_info_t ng_node;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		nginxgroup_info_t *ng = NULL;
		nginx_srv_t *nginx_srv = NULL;

		memset(&ng_node,0,sizeof(nginxgroup_info_t));
		strcpy(ng_node.name,groupName.c_str());

		cur = hs_nginx_group.hash_search(&hs_nginx_group,ng_node.name);
		if(NULL == cur) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:failed,can not find nginx group node!!!,name=%s\n",ng_node.name);
				return RetCode::FAIL;
		}

		ng = (nginxgroup_info_t *)cur;
		head_node = &ng->srv_head;
		head = &head_node->head;

		size = servers.size();

		for(i = 0 ; i < size ; i++)
		{

				list_for_each_safe(cur,tmp,head)
				{
						nginx_srv = (nginx_srv_t*)cur;			
						if(!strcmp(nginx_srv->url,servers[i].localURL.c_str()))
						{
								break;
						}
				}

				if(cur != head)
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:already exist!!!nginxgroup=%s,url=%s\n",groupName.c_str(),servers[i].localURL.c_str());
						continue;
				}
				else
				{
						nginx_srv_t *srv_node = (nginx_srv_t *)calloc(1,sizeof(nginx_srv_t));
						if(NULL == srv_node) 
						{
								cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:malloc failed!!!\n");
								return RetCode::FAIL;
						}
						srv_node->priority = servers[i].priority;
						strcpy(srv_node->url,servers[i].localURL.c_str());
						list_add(head_node,&srv_node->node);
						cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:success!!!nginxgroup=%s,url=%s\n",groupName.c_str(),servers[i].localURL.c_str());
				}
		}

		return RetCode::OK;
}


#if 0
RetCode::type DialHandler::modNginxServer(const std::string& groupName, const DialNginxServer& server) 
{
		nginxgroup_info_t ng_node;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		nginxgroup_info_t *ng = NULL;
		nginx_srv_t *psrv = NULL;
		RetCode::type ret = RetCode::OK;

		memset(&ng_node,0,sizeof(nginxgroup_info_t));

		strcpy(ng_node.name,groupName.c_str());

		cur = hs_nginx_group.hash_search(&hs_nginx_group,(char *)ng_node.name);
		if(NULL == cur) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxServer:failed,can not find nginx group node!!!\n");
				return RetCode::FAIL;
		}

		ng = (nginxgroup_info_t *)cur;

		head_node = &ng->srv_head;
		head = &head_node->head;

		pthread_mutex_lock(&head_node->lock);

		list_for_each(cur, head) 
		{
				psrv = (nginx_srv_t *)cur;
				if(!strcmp(psrv->url,server.localURL.c_str()))
				{
						break;
				}	
		}
		if(cur != head) 
		{
				strcpy(psrv->url,server.localURL.c_str());
				psrv->priority = server.priority;
				cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxServer:success!!!,groupName=%s,priority=%d,url=%s\n",groupName.c_str(),server.priority,server.localURL.c_str());
		}
		else 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"modNginxServer:failed,can not find target node.groupname=%s,url=%s,priority=%d!!!\n",groupName.c_str(),server.localURL.c_str(),server.priority);
				ret = RetCode::FAIL;
		}

		pthread_mutex_unlock(&head_node->lock);

		return ret;

}
#endif


RetCode::type DialHandler::delNginxServer(const std::string& groupName, const std::vector<DialNginxServer>&servers) 
{
		int size = 0,i = 0;
		nginxgroup_info_t ng_node;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *node = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		nginxgroup_info_t *ng = NULL;
		nginx_srv_t *nginx_srv = NULL;

		memset(&ng_node,0,sizeof(nginxgroup_info_t));
		strcpy(ng_node.name,groupName.c_str());

		node = hs_nginx_group.hash_search(&hs_nginx_group,(const char *)ng_node.name);
		if(NULL == node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxServer:failed,can not find nginx group node!!!groupName=%s\n",groupName.c_str());
				return RetCode::FAIL;
		}

		ng = (nginxgroup_info_t *)node;
		head_node = &ng->srv_head;
		head = &head_node->head;

		size = servers.size();


		for(i = 0 ; i < size ; i++)
		{
				list_for_each_safe(cur,tmp,head)
				{
						nginx_srv = (nginx_srv_t*)cur;			
						if(!strcmp(nginx_srv->url,servers[i].localURL.c_str()))
						{
								break;
						}
				}

				if(cur != head)
				{
						list_del(head_node,cur);
						cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxServer:del nginx_srv=%s from nginxgroupname=%s\n",nginx_srv->url,groupName.c_str());
						free(nginx_srv);
						nginx_srv = NULL;
				}
				else
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxServer:failed del nginx_srv=%s from nginxgroupname=%s\n",servers[i].localURL.c_str(),groupName.c_str());
						pthread_mutex_unlock(&head_node->lock);
						return RetCode::FAIL;
				}
		}
		

		return RetCode::OK;

}


int create_client_udp_fd()
{
		int rtn = 0;
		int fd = 0;
		int flag = 0;
		int fdbuflen;
		struct sockaddr_in cliaddr;
		struct timeval timeout;

		fd = socket(AF_INET,SOCK_DGRAM,0);
		if(fd < 0) 
		{
				debug_printf(LOG_LEVEL_ERROR,"create_client_udp_fd failed\n");
				return ERROR;
		}

		timeout.tv_sec=0;
		timeout.tv_usec=(g_cfg.srv_cfg.timeout + 1)*1000;
		rtn = setsockopt(fd,SOL_SOCKET,SO_RCVTIMEO,(char *)&timeout,sizeof(struct timeval));
		if(rtn < 0)
		{
				debug_printf(LOG_LEVEL_ERROR,"create_client_udp_fd:setsockopt SO_RCVTIMEO failed \n");
				return ERROR;
		}

		return fd;
}



RetCode::type send_update_health_status(const std::vector<DialHealthResult> & results)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);
				//AgentClient client(tprotocol);

				rtn = client.updateHealthStatus(results);
				debug_printf(LOG_LEVEL_DEBUG,"send_update_health_status: update num=%d,rtn=%d\n",results.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"send_update_health_status:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"send_update_health_status:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;

}


RetCode::type send_update_server_status(const std::vector<DialServerResult> & results)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);
				//AgentClient client(tprotocol);

				rtn = client.updateServerStatus(results);
				debug_printf(LOG_LEVEL_DEBUG,"send_update_server_status:update num=%d,rtn=%d\n",results.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"send_update_server_status:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"send_update_server_status:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}


RetCode::type send_update_nginx_status(const std::vector<DialNginxResult> & results)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);
				//AgentClient client(tprotocol);

				rtn = client.updateNginxStatus(results);
				debug_printf(LOG_LEVEL_DEBUG,"send_update_nginx_status:update num=%d,rtn=%d\n",results.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"send_update_nginx_status:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"send_update_nginx_status:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}


RetCode::type update_ipsec_online_ip(const std::string& ipsecid, const std::vector<IpAddr> & iplist)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateIpSecOnlineIp(ipsecid,iplist);
				debug_printf(LOG_LEVEL_DEBUG,"update_ipsec_online_ip:ipsecid=%s,iplist_szie=%d,rtn=%d\n",ipsecid.c_str(),iplist.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_ipsec_online_ip:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_ipsec_online_ip:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}


RetCode::type update_interface_info(const std::string& snmp, const std::vector<InterfaceInfo> & interfaces)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateInterfaceInfo(snmp,interfaces);
				debug_printf(LOG_LEVEL_DEBUG,"update_interface_info:interface szie=%d,rtn=%d\n",interfaces.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_interface_info:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_interface_info:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}


RetCode::type update_interface_traffic(const std::string& snmp, const std::vector<InterfaceTraffic> & traffic)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateInterfaceTraffic(snmp,traffic);
				debug_printf(LOG_LEVEL_DEBUG,"update_interface_traffic:rtn=%d\n",rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_interface_traffic:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_interface_traffic:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}


RetCode::type update_interface_ipmac(const std::string& snmp, const std::vector<IpMac> & ipmac) 
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateInterfaceIpMac(snmp,ipmac);
				debug_printf(LOG_LEVEL_DEBUG,"update_interface_ipmac:ipmac szie=%d,rtn=%d\n",ipmac.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_interface_ipmac:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_interface_ipmac:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}



RetCode::type update_route_info(const std::string& snmp, const std::vector<RouteInfo> & routeinfo)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateRouteInfo(snmp,routeinfo);
				debug_printf(LOG_LEVEL_DEBUG,"update_route_info:route szie=%d,rtn=%d\n",routeinfo.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_route_info:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_route_info:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}



RetCode::type update_sys_info(const std::string& snmp, const SysInfo& sysinfo)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateSysInfo(snmp,sysinfo);
				debug_printf(LOG_LEVEL_DEBUG,"update_sys_info:route rtn=%d\n",rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_sys_info:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_sys_info:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}



RetCode::type update_process_info(const std::string& snmp, const ProcessInfo& processinfo)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateProcessInfo(snmp,processinfo);
				debug_printf(LOG_LEVEL_DEBUG,"update_process_info:route rtn=%d\n",rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_process_info:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_process_info:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}



int handle_dial_by_policy(healthgroup_info_t *hg,healthpolicy_info_t *policy,char *ip,int * delay)
{
		int ret = 0;

		switch(policy->method) 
		{
				case DIAL_TCPPORT:
				{
						ret = handle_tcp_and_port_dialing(ip,policy->port,delay);
						break;
				}		
				case DIAL_IMCP:
				{
						ret = handle_icmp_dialing(ip,delay);
						break;
				}		
				case DIAL_HTTPGET:
				{
						//ret = handle_httpget_dialing(ip,hg->pPolicy->port,(char *)"/",hg->name);
						if(0 == policy->port)
						{
								ret = handle_httpget_dialing(ip,HTTPGET_PORT,(char *)"/",ip,delay);
						}
						else
						{
								ret = handle_httpget_dialing(ip,policy->port,(char *)"/",ip,delay);
						}
						break;
				}		
				case DIAL_DATABASE:
				{
						ret = handle_db_dialing(ip,policy->dial_option.dest_url,policy->dial_option.test_method,delay);
						break;	
				}		
				case DIAL_EXTHTTPGET:
				{
						//ret = handle_exthttpget_dialing(ip,hg->name,&hg->pPolicy->dial_option);
						ret = handle_exthttpget_dialing(ip,ip,&policy->dial_option,delay);
						break;
				}		
				case DIAL_NETBIOS:
				{
						ret = handle_netbios_dialing(ip,NETBIOS_PORT,delay);
						break;
				}		
				default:
				{
						ret = ERROR;
						debug_printf(LOG_LEVEL_ERROR,"handle_dial_by_policy:error dial method type=%d",policy->method);
						break;
				}		
		}


		return ret;		
}


int get_parameters_from_url(char *src,char *resource,char *ip,int *port,bool *https_flag)
{
	char *pstart = NULL;
	char pport[10] = {0};
	int i = 0;
	
	if(NULL == src) 
	{
		debug_printf(LOG_LEVEL_ERROR,"get_parameters_from_url:invalid parameter,src is NULL\n");	
		return ERROR;
	}
	
	pstart = strstr(src,"http://");
	if(NULL == pstart) {
		pstart = strstr(src,"https://");
		if(NULL == pstart) {
			debug_printf(LOG_LEVEL_ERROR,"get_parameters_from_url:invalid parameter,src format error\n");
			return ERROR;
		} else {
			pstart += strlen("https://");
			*https_flag = true;
		}
		
	}else {
		pstart += strlen("http://");
		*https_flag = false;
	}


	//ip
	while(*pstart != '\0') {
		if(':' == *pstart || '/' == *pstart) {
			//pstart++;
			break;
		}else {
			*ip++ = *pstart++;
		}
	}

	if('\0' == *pstart || '/' == *pstart) {
		if(false == *https_flag)
			*port = 80;
		else
			*port = 443;
		
		if('\0' == *pstart)
			strcpy(resource,"/");
		else
			strcpy(resource,pstart);
		
		return NO_ERROR;
	}

	pstart++;
	//port
	while(*pstart != '\0') {
		if('/' == *pstart)
			break;
		else
			pport[i++] = *pstart++;
	}	
	
	if('\0' == *pstart) {
		*port = atoi(pport);
		strcpy(resource,"/");
	} else {
		*port = atoi(pport);
		strcpy(resource,pstart);
	}

	return NO_ERROR;
}


//handle_nginxgroup_dial(nginxgroup_info_t *ng,char *ip,char *resource,int port,bool https_flag)
int handle_nginxgroup_dial(nginxgroup_info_t *ng,healthpolicy_info_t *policy,char *ip,int port,int * delay)
{
		int ret = 0;

		switch(policy->method) 
		{
				case DIAL_TCPPORT:
				{
						ret = handle_tcp_and_port_dialing(ip,policy->port,delay);
						break;
				}		
				case DIAL_IMCP:
				{
						ret = handle_icmp_dialing(ip,delay);
						break;
				}		
				case DIAL_HTTPGET:
				{
						//ret = handle_httpget_dialing(ip,ng->pPolicy->port,(char *)"/",ng->name);
						ret = handle_httpget_dialing(ip,port,(char *)"/",ip,delay);
						break;
				}		
				case DIAL_DATABASE:
				{
						ret = handle_db_dialing(ip,policy->dial_option.dest_url,policy->dial_option.test_method,delay);
						break;	
				}		
				case DIAL_EXTHTTPGET:
				{
						ret = handle_exthttpget_dialing(ip,ip,&policy->dial_option,delay);
						//ret = handle_exthttpget_dialing(ip,ng->name,&ng->pPolicy->dial_option);
						break;
				}		
				case DIAL_NETBIOS:
				{
						ret = handle_netbios_dialing(ip,NETBIOS_PORT,delay);
						break;
				}		
				default:
				{
						ret = ERROR;
						debug_printf(LOG_LEVEL_ERROR,"handle_nginxgroup_dial:error dial method type=%d",policy->method);
						break;
				}		
		}

		return ret;		
}



void do_a_dial_healthgroup(healthgroup_info_t * hg,healthpolicy_info_t * policy)
{
		int ret = 0,i = 0,j = 0,delay = 0,timeout = 0;
		int success = 0,success_times = 0,failed_times = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = &hg->record_head.head;
		DIAL_LIST_HEAD *phead = &hg->record_head;
		record_info_t *rec = NULL;
		DialHealthResult result;
		std::vector<DialRecordStatus> rr(phead->num);

		list_for_each(cur, head) 
		{
				rec = (record_info_t *)cur;
				success = 0;
				timeout = 0;
				rr[j].rid.assign(rec->rid);

				for(i = 0 ; i < policy->times ; i++) 
				{
						delay = 0;
						ret = handle_dial_by_policy(hg,policy,rec->ip.addr,&delay);
						if(NO_ERROR == ret)
						{
								timeout += delay;
								success++;
						}	
						usleep(50);
				}


				if(success > 0)
				{
						rr[j].delay = timeout/success;
				}
				else
				{
						rr[j].delay = 0;
				}

				if(success < policy->passed) 
				{
						rr[j].status = DialStatus::FAIL;
						failed_times++;
				}
				else 
				{
						rr[j].status = DialStatus::OK;
						success_times++;
				}

				debug_printf(LOG_LEVEL_DEBUG,"record:ip=%s,timeout=%d,delay=%lld\n",rec->ip.addr,timeout,rr[j].delay);

				j++;
		}

		debug_printf(LOG_LEVEL_BASIC,"do_a_dial_healthgroup:group=%s,policy=%s,record_num=%d,success_record=%d,failed_record=%d\n",hg->name,policy->policyname,phead->num,success_times,failed_times);

		if(j > 0) 
		{
				result.groupName.assign(hg->name);
				result.policyName.assign(policy->policyname);
				result.statusList = rr;
				
				pthread_mutex_lock(&health_results_lock);
				health_results.push_back(result);
				pthread_mutex_unlock(&health_results_lock);

		}

}


int generate_dns_package(char *snd_msg,char *domain,int id)
{
		int msglen = 0;

		msglen = dns_fill_query((struct dnshdr_s *)snd_msg,domain,id, __cpu_to_be16(NS_FLAG_RD), __cpu_to_be16(NS_CLASS_IN),__cpu_to_be16(NS_TYPE_A));

		return msglen;
}


int do_dns_dial(char *msg,int msg_len,struct sockaddr_in *servaddr,int fd)
{
		int rtn;
		int anslen;
		union 
		{
				HEADER hdr;
				u_char buf[NS_PACKETSZ];
		} answer;
		struct timeval t_start;
		struct timeval t_end;

		rtn = sendto(fd,msg,msg_len,0,(struct sockaddr *)servaddr, sizeof(struct sockaddr_in));
		if(rtn < 0) 
		{
				debug_printf(LOG_LEVEL_ERROR,"do_dns_dial:sendto failed,rtn = %d\n",rtn);
				return g_cfg.srv_cfg.timeout;
		}

		gettimeofday(&t_start,NULL);

		anslen = recvfrom(fd,&answer,sizeof(answer),0,NULL,NULL);

		if(anslen < 0) 
		{
				debug_printf(LOG_LEVEL_ERROR,"do_dns_dial:recvfrom failed,fd=%d,anslen = %d\n",fd,anslen);
		}

		gettimeofday(&t_end,NULL);

		return ((t_end.tv_sec * 1000*1000 + t_end.tv_usec) - (t_start.tv_sec * 1000*1000 + t_start.tv_usec));

}


void server_dial_by_httpget(dial_srv_node_t *srv)
{
		int i = 0,rtn = 0,delay = 0;
		DialServerStatus server_status;
		RetCode::type rslt = RetCode::OK;
		DialServerResult result;

		for(i = 0;i < g_cfg.srv_cfg.count;i++) 
		{	
				delay = 0;		
				rtn = handle_httpget_dialing(srv->ip.addr,HTTPGET_PORT,(char *)"/",srv->ip.addr,&delay);
				if(NO_ERROR == rtn)
				{
						break;			
				}	
		}

		server_status.rid.assign(srv->srv_id);
		server_status.ip.addr.assign(srv->ip.addr);
		server_status.ip.version = srv->ip.version;
		server_status.delay = delay;


		if(rtn == NO_ERROR && i < g_cfg.srv_cfg.count) 
		{
				server_status.status = DialStatus::OK;
				debug_printf(LOG_LEVEL_BASIC,"do_a_dial_server:success!!!ip=%s,type=%d,delay=%lld\n",srv->ip.addr,srv->srv_tpye,server_status.delay);
		}	
		else
		{
				server_status.status = DialStatus::FAIL;
				debug_printf(LOG_LEVEL_BASIC,"do_a_dial_server:failed!!!ip=%s,type=%d,delay=%lld\n",srv->ip.addr,srv->srv_tpye,server_status.delay);
		}

		result.status = server_status;
		result.typ = srv->srv_tpye;
		pthread_mutex_lock(&server_results_lock);
		server_results.push_back(result);
		pthread_mutex_unlock(&server_results_lock);

}


int do_a_dial_server(dial_srv_node_t *srv)
{
		int fd = 0;
		int i = 0;
		int rtn = 0;
		char msg[512] = {0};
		struct sockaddr_in servaddr;
		int msg_len = 0;
		int success = 0;
		int timeout = 0;
		int health_value = 0;
		DialServerStatus server_status;
		DialServerResult result;

		if(DialServerType::REDIRECT == srv->srv_tpye)
		{
				server_dial_by_httpget(srv);
				return 0;
		}

		fd = create_client_udp_fd();
		if(ERROR == fd) 
		{
				debug_printf(LOG_LEVEL_ERROR,"do_a_dial_server:creat socket failed!!!ip=%s,type=%d\n",srv->ip.addr,srv->srv_tpye);
				return ERROR;
		}

		memset(&servaddr, 0, sizeof(servaddr));	
		servaddr.sin_family = AF_INET;	
		servaddr.sin_port = htons(53);	
		inet_pton(AF_INET, srv->ip.addr, &servaddr.sin_addr);

		msg_len = generate_dns_package(msg,g_cfg.srv_cfg.dname,(pthread_self() + 1)%0xffff);

		for(i = 0;i < g_cfg.srv_cfg.count;i++) 
		{
				rtn = do_dns_dial(msg,msg_len,&servaddr,fd);
				if(rtn < g_cfg.srv_cfg.timeout*1000) 
				{
						success++;
						timeout += rtn;
				}
		}

		close(fd);

		if(success > 0)
		{
				server_status.delay = timeout/success;
				health_value = (timeout/1000/success*g_cfg.srv_cfg.delay_weight) + (g_cfg.srv_cfg.count - success)*g_cfg.srv_cfg.lost_weight;
		}
		else
		{
				server_status.delay = 0;
		}

		server_status.rid.assign(srv->srv_id);
		server_status.ip.addr.assign(srv->ip.addr);
		server_status.ip.version = srv->ip.version;

		if(success > 0 && health_value < g_cfg.srv_cfg.health) 
		{	
				server_status.status = DialStatus::OK;
				debug_printf(LOG_LEVEL_BASIC,"do_a_dial_server:success!!!ip=%s,type=%d,health_value=%d,dial_success_times=%d,total_timeout=%d,delay=%lld\n",srv->ip.addr,srv->srv_tpye,health_value,success,timeout,server_status.delay);
		}	
		else
		{
				server_status.status = DialStatus::FAIL;
				debug_printf(LOG_LEVEL_BASIC,"do_a_dial_server:failed!!!ip=%s,type=%d,health_value=%d,dial_success_times=%d,total_timeout=%d,delay=%lld\n",srv->ip.addr,srv->srv_tpye,health_value,success,timeout,server_status.delay);
		}	

		result.status = server_status;
		result.typ = srv->srv_tpye;

		pthread_mutex_lock(&server_results_lock);
		server_results.push_back(result);
		pthread_mutex_unlock(&server_results_lock);

}


void do_a_dial_nginxgroup(nginxgroup_info_t *ng,healthpolicy_info_t *policy)
{
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = &ng->srv_head.head;
		DIAL_LIST_HEAD *phead = &ng->srv_head;
		nginx_srv_t *srv = NULL;
		int ret = 0,i = 0,j = 0,port = 0,delay = 0,timeout = 0;
		int success = 0,success_times = 0,failed_times = 0;
		char resource[1024];
		char ip[26];
		bool httpsflag;

		DialNginxResult result;
		std::vector<DialNginxStatus> sr(phead->num);
		
		list_for_each(cur, head) 
		{
				srv = (nginx_srv_t *)cur;
				success = 0;
				timeout = 0;
				sr[j].server.localURL.assign(srv->url);
				sr[j].server.priority = srv->priority;

				port = 0;
				httpsflag = false;
				memset(resource,0,sizeof(resource));
				memset(ip,0,sizeof(ip));

				ret = get_parameters_from_url(srv->url,resource,ip,&port,&httpsflag);
				if(ret < 0) 
				{
						goto NEXT_STEP;
				}

				for(i = 0 ; i < policy->times ; i++) 
				{
						delay = 0;
						ret = handle_nginxgroup_dial(ng,policy,ip,port,&delay);
						if(NO_ERROR == ret)
						{
								timeout += delay;
								success++;
						}	
						usleep(50);
				}

NEXT_STEP:

				if(success > 0)
				{
						sr[j].delay = timeout/success;
				}
				else
				{
						sr[j].delay = 0;
				}


				if(success < policy->passed) 
				{
						sr[j].status = DialStatus::FAIL;
						failed_times++;
				}
				else 
				{
						sr[j].status = DialStatus::OK;
						success_times++;
				}

				debug_printf(LOG_LEVEL_DEBUG,"nginx_server:ip=%s,delay=%lld\n",ip,timeout,sr[j].delay);

				j++;
		}

		debug_printf(LOG_LEVEL_BASIC,"do_a_dial_nginxgroup:group=%s,policy=%s,srv_num=%d,success_srv=%d,failed_srv=%d\n",ng->name,policy->policyname,phead->num,success_times,failed_times);

		if(j > 0) 
		{
				result.groupName.assign(ng->name);
				result.policyName.assign(policy->policyname);
				result.statusList = sr;

				pthread_mutex_lock(&nginx_results_lock);
				nginx_results.push_back(result);
				pthread_mutex_unlock(&nginx_results_lock);
		}

}




int 
dial_config_check(dial_cfg_t *config)
{
	config->srv_cfg.allowed[0] = true;
	config->srv_cfg.allowed[1] = true;
	config->srv_cfg.allowed[2] = true;

	if(config->srv_cfg.count <= 0)
		config->srv_cfg.count = 1;
	if(config->srv_cfg.health  <= 0)
		config->srv_cfg.count = 5000;
	if(config->srv_cfg.delay_weight  <= 0)
		config->srv_cfg.delay_weight = 10;
	if(config->srv_cfg.lost_weight  <= 0)
		config->srv_cfg.lost_weight = 10;
	if(config->srv_cfg.timeout<= 0)
		config->srv_cfg.timeout = 50;
	if(config->srv_cfg.interval<= 0)
		config->srv_cfg.interval = 5;

	if(strlen(config->srv_cfg.dname) <= 0) {
		memset(config->srv_cfg.dname,0,sizeof(config->srv_cfg.dname));
		strcpy(config->srv_cfg.dname,"www.sina.com");
	}
	
	if(strlen(config->log_path) <= 0) {
		strcpy(config->log_path,"/var/log/");
	}
	
	if(config->log_level <= 0) {
		config->log_level = 1;
	}
	
	cfg_debug_printf(LOG_LEVEL_BASIC,"dial_config_check:dial_config===>health=%d,delay_weight=%d,lost_weight=%d,count=%d,timeout=%d,interval=%d,dname=%s\n",
						config->srv_cfg.health,config->srv_cfg.delay_weight,config->srv_cfg.lost_weight,config->srv_cfg.count,config->srv_cfg.timeout,config->srv_cfg.interval,config->srv_cfg.dname);

}


int load_sys_config(dial_cfg_t *cfg,char *filename)
{
	FILE *fp = NULL;
	char tmp[500] = {0};
	
	fp = fopen(filename,"r");
	if(NULL == fp) {
		cfg_debug_printf(LOG_LEVEL_ERROR,"load_sys_config:open the file %s failed\n",filename);
		return ERROR;
	}


	while(!feof(fp)) {
	
		memset(tmp,0,sizeof(tmp));
		fgets(tmp,sizeof(tmp),fp);
		
		//debug_printf("get tmp is %s",tmp);		
		if(NULL != strstr(tmp,"#dial process port")) {

			fscanf(fp,"port=%d",&cfg->dial_port);
			
		}else if(NULL != strstr(tmp,"#Agent info")) {
			fscanf(fp,"port=%d",&cfg->agent_port);
			fgets(tmp,sizeof(tmp),fp);
			fscanf(fp,"ip=%s",cfg->agent_ip);
		}else if(NULL != strstr(tmp,"#server dial config")) {
			fscanf(fp,"health=%d",&cfg->srv_cfg.health);
			fgets(tmp,sizeof(tmp),fp);
			fscanf(fp,"delay_weight=%d",&cfg->srv_cfg.delay_weight);
			fgets(tmp,sizeof(tmp),fp);
			fscanf(fp,"lost_weight=%d",&cfg->srv_cfg.lost_weight);
			fgets(tmp,sizeof(tmp),fp);
			fscanf(fp,"count=%d",&cfg->srv_cfg.count);
			fgets(tmp,sizeof(tmp),fp);
			fscanf(fp,"timeout=%d",&cfg->srv_cfg.timeout);
			fgets(tmp,sizeof(tmp),fp);
			fscanf(fp,"interval=%d",&cfg->srv_cfg.interval);
			fgets(tmp,sizeof(tmp),fp);			
			fscanf(fp,"dname=%s",cfg->srv_cfg.dname);
		}else if(NULL != strstr(tmp,"#log config")) {
			fscanf(fp,"path=%s",cfg->log_path);		
			fgets(tmp,sizeof(tmp),fp);
			fscanf(fp,"level=%d",&cfg->log_level);
		}else if(NULL != strstr(tmp,"#certificate config")) {
			fscanf(fp,"path=%s",cfg->certificate_file);		
		}

	}
	fclose(fp);
	cfg_debug_printf(LOG_LEVEL_BASIC,"load_sys_config:agent_ip = %s,agent_port=%d,dial_server_port=%d\n",cfg->agent_ip,cfg->agent_port,cfg->dial_port);
	cfg_debug_printf(LOG_LEVEL_BASIC,"load_sys_config:dial_config===>health=%d,delay_weight=%d,lost_weight=%d,count=%d,timeout=%d,interval=%d,dname=%s,log_path=%s,log_level=%d,certificate_file=%s\n",
					cfg->srv_cfg.health,cfg->srv_cfg.delay_weight,cfg->srv_cfg.lost_weight,cfg->srv_cfg.count,cfg->srv_cfg.timeout,cfg->srv_cfg.interval,cfg->srv_cfg.dname,cfg->log_path,cfg->log_level,cfg->certificate_file);

	return NO_ERROR;
}



void thrift_init(int port)
{
		//int port = 9092;
		shared_ptr<DialHandler> handler(new DialHandler());
		shared_ptr<TProcessor> processor(new DialProcessor(handler));
		shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
		shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
		shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

		TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);

		server.serve();
}


void thrift_client_init(char *ip,int port)
{
		boost::shared_ptr<TSocket> tsocket(new TSocket(ip, port));  
		boost::shared_ptr<TTransport> ttransport(new TBufferedTransport(tsocket));  
		boost::shared_ptr<TProtocol> tprotocol(new TBinaryProtocol(ttransport)); 

		transport_client = ttransport;
		protocol_client = tprotocol;
}


int sys_init()
{
		int rtn = 0;
		int agent_port = 0;
		char agent_ip[50] = {0};

		pthread_mutex_init(&g_log_lock,NULL);

#if 0

		s_debug_switch = true;

		rtn = signal_init();
		if(rtn != NO_ERROR) 
		{
				debug_printf(LOG_LEVEL_ERROR,"sys_init:switch_signal_init  failed!!\n");
				return ERROR;
		}

		rtn = sys_log_timer_init();
		if(rtn != NO_ERROR) 
		{
				debug_printf(LOG_LEVEL_ERROR,"sys_init:sys_log_timer_init  failed!!\n");
				return ERROR;
		}

#endif

		memset(&g_cfg,0,sizeof(dial_cfg_t));
		rtn = load_sys_config(&g_cfg,(char *)CONFIG_FILE);
		if(rtn != NO_ERROR) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:load_sys_config  failed!!\n");
				return ERROR;
		}

		dial_config_check(&g_cfg);

		thrift_client_init(g_cfg.agent_ip,g_cfg.agent_port);

		rtn = hash_init_healthpolicy(&hs_health_policy,HASH_POLICY_NUM);
		if(rtn != NO_ERROR) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:init hs_health_policy failed!!\n");
				return ERROR;
		}

		rtn = hash_init_healthgroup(&hs_health_group,HASH_GROUP_NUM);
		if(rtn != NO_ERROR) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:init hs_health_group failed!!\n");
				return ERROR;
		}

		rtn = hash_init_nginxgroup(&hs_nginx_group,HASH_NGINX_NUM);
		if(rtn != NO_ERROR) 
		{
				debug_printf(LOG_LEVEL_ERROR,"sys_init:init hs_nginx_group failed!!\n");
				return ERROR;
		}

		list_head_init(&list_dial_srv);

		list_head_init(&list_snmp);

		queue_init(&queue_info);


		thread_exit_flag = true;
		cfg_debug_printf(LOG_LEVEL_BASIC,"isPrimary:enable = %d,thread_exit_flag = %d\n",primary_flag,thread_exit_flag);

		if ((rtn = pthread_mutex_init(&client_lock,NULL)) != 0) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:pthread_mutex_init client_lock failed!!\n");
				return ERROR;
		}

		if ((rtn = pthread_mutex_init(&health_results_lock,NULL)) != 0) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:pthread_mutex_init health_results_lock failed!!\n");
				return ERROR;
		}

		if ((rtn = pthread_mutex_init(&nginx_results_lock,NULL)) != 0) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:pthread_mutex_init nginx_results_lock failed!!\n");
				return ERROR;
		}

		if ((rtn = pthread_rwlock_init(&ipsec_map_lock,NULL)) != 0) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:pthread_rwlock_init ipsec_map_lock failed!!\n");
				return ERROR;
		}

		if ((rtn = pthread_rwlock_init(&snmp_map_lock,NULL)) != 0) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:pthread_rwlock_init snmp_map_lock failed!!\n");
				return ERROR;
		}

		init_openssl();

		return NO_ERROR;
}


inline void add_healthgroup_task_to_queue(healthgroup_info_t *hg,healthpolicy_info_t *policy)
{
		DIAL_LIST_NODE * cur = NULL;
		DIAL_LIST_NODE * tmp = NULL;
		DIAL_LIST_NODE * head = &hg->record_head.head;
		record_info_t * record = NULL;
		record_info_t * record_tmp = NULL;

		healthgroup_info_t *hg_node = (healthgroup_info_t *)calloc(1,sizeof(healthgroup_info_t));
		dial_node_t *task_node = (dial_node_t *)calloc(1,sizeof(dial_node_t));

		strcpy(hg_node->name,hg->name);
		list_head_init(&hg_node->record_head);

		list_for_each_safe(cur,tmp,head)
		{
				record_tmp = (record_info_t*)cur;
				record = (record_info_t*)calloc(1,sizeof(record_info_t));
				memcpy(record,record_tmp,sizeof(record_info_t));
				list_add(&hg_node->record_head,&record->node);
		}

		task_node->policy = policy;
		task_node->type = HEALTHGROUP;
		task_node->dial_node.healthgroup = hg_node;

		queue_push(&queue_info, &task_node->node);
}


inline void add_server_task_to_queue(dial_srv_node_t *node)
{
		dial_srv_node_t *srv_node = (dial_srv_node_t *)calloc(1,sizeof(dial_srv_node_t));
		dial_node_t *task_node = (dial_node_t *)calloc(1,sizeof(dial_node_t));

		memcpy(srv_node,node,sizeof(dial_srv_node_t));
		srv_node->node.next = NULL;
		srv_node->node.prev = NULL;

		task_node->type = SERVER;
		task_node->dial_node.srv = srv_node;

		queue_push(&queue_info, &task_node->node);
}


inline void add_nginxgroup_task_to_queue(nginxgroup_info_t *ng,healthpolicy_info_t *policy)
{
		DIAL_LIST_NODE * cur = NULL;
		DIAL_LIST_NODE * tmp = NULL;
		DIAL_LIST_NODE * head = &ng->srv_head.head;
		nginx_srv_t * nginx_srv = NULL;
		nginx_srv_t * nginx_srv_tmp = NULL;

		nginxgroup_info_t *ng_node = (nginxgroup_info_t *)calloc(1,sizeof(nginxgroup_info_t));
		dial_node_t *task_node = (dial_node_t *)calloc(1,sizeof(dial_node_t));

		strcpy(ng_node->name,ng->name);
		list_head_init(&ng_node->srv_head);

		list_for_each_safe(cur,tmp,head)
		{
				nginx_srv_tmp = (nginx_srv_t*)cur;
				nginx_srv = (nginx_srv_t*)calloc(1,sizeof(nginx_srv_t));
				memcpy(nginx_srv,nginx_srv_tmp,sizeof(nginx_srv_t));
				list_add(&ng_node->srv_head,&nginx_srv->node);
		}

		task_node->policy = policy;
		task_node->type = NGINX;
		task_node->dial_node.nginxgroup = ng_node;

		queue_push(&queue_info, &task_node->node);
}


# if 0
inline void add_snmptask_to_queue(snmp_dev_node_t *node)
{
		snmp_dev_node_t *snmp_node = (snmp_dev_node_t *)calloc(1,sizeof(snmp_dev_node_t));
		dial_node_t *task_node = (dial_node_t *)calloc(1,sizeof(dial_node_t));

		memcpy(snmp_node,node,sizeof(snmp_dev_node_t));
		snmp_node->node.next = NULL;
		snmp_node->node.prev = NULL;

		task_node->type = SNMPDIAL;
		task_node->dial_node.snmp = snmp_node;

		queue_push(&queue_info, &task_node->node);
}
#endif

void queue_buffer_destroy(queue_info_t *info)
{
		DIAL_LIST_NODE *node = NULL;	
		healthgroup_info_t *hg = NULL;

		while(NULL != info->tail) 
		{

				node = queue_pop(info);
				hg = (healthgroup_info_t *)node;
				if(NULL != node)
						free(hg);	
		}
}


void dial_srv_list_destroy(DIAL_LIST_HEAD *list)
{
		DIAL_LIST_NODE *cur = NULL;	
		DIAL_LIST_NODE *tmp = NULL;	
		DIAL_LIST_NODE *head = &list->head;
		dial_srv_node_t *srv_node = NULL;

		list_for_each_safe(cur, tmp, head) 
		{
				list_del(&list_dial_srv,cur);
				srv_node = (dial_srv_node_t *)cur;
				if(NULL != srv_node)
						free(srv_node);
		}

}



int sys_free()
{
		threadpool_destroy(&tp);
		hash_destory_healthgroup(&hs_health_group);
		hash_destory_healthgroup(&hs_nginx_group);
		hash_destory_healthpolicy(&hs_health_policy);
		queue_buffer_destroy(&queue_info);	
		dial_srv_list_destroy(&list_dial_srv);

		transport_client->close(); 

		return NO_ERROR;
}


#define TIME_CMPARE(a,b) (((a)->tv_sec * 1000*1000 + (a)->tv_usec) - ((b)->tv_sec * 1000*1000 + (b)->tv_usec)) 



void *healthgroup_monitor_thread(void *arg)
{
		int i = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head =NULL;
		DIAL_LIST_NODE *cur_p = NULL;
		DIAL_LIST_NODE *tmp_p = NULL;
		DIAL_LIST_NODE *head_p =NULL;
		DIAL_LIST_HEAD *phead = NULL;
		pPolicy_node_t *policy = NULL;
		healthgroup_info_t *hg = NULL;
		struct timeval t_now;


		while(thread_exit_flag) 
		{

				if(false == client_connecting_flag || 1 != primary_flag)
				{
						sleep(1);
						continue;
				}

				for(i = 0; i < hs_health_group.num; ++i) 
				{
						cur = NULL;
						head = &(hs_health_group.tab[i].head);
						phead = &(hs_health_group.tab[i]);

						pthread_mutex_lock(&phead->lock);
						list_for_each_safe(cur,tmp,head) 
						{
								hg = (healthgroup_info_t *)cur;
								head_p = &hg->pPolicy_head.head;

								list_for_each_safe(cur_p,tmp_p,head_p) 
								{
										policy = (pPolicy_node_t *)cur_p;

										gettimeofday(&t_now,NULL);
										//if(TIME_CMPARE(&t_now,&hg->t_insert) > 0) 
										if(((t_now.tv_sec * 1000*1000 + t_now.tv_usec) - (policy->t_insert.tv_sec * 1000*1000 + policy->t_insert.tv_usec)) >= 0) 
										{

												add_healthgroup_task_to_queue(hg,policy->pPolicy);


#if 0
												if(tp.threads_used < tp.act_threads_num) 
												{
														pthread_cond_signal(&tp.cond);
														debug_printf(LOG_LEVEL_BASIC,"queue task num=%d task,used thread num=%d!!\n",queue_info.cnt,tp.threads_used);
												}
#endif


												policy->t_insert = t_now;
												policy->t_insert.tv_sec += policy->pPolicy->freq;					
										}
								}
						}
						pthread_mutex_unlock(&phead->lock);
				}	
				sleep(1);
		}

}



void *server_monitor_thread(void *arg)
{
		int i = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head =NULL;
		DIAL_LIST_HEAD *phead = NULL;

		dial_srv_node_t *srv_node = NULL;
		struct timeval t_now;

		while(thread_exit_flag) 
		{

				if(false == client_connecting_flag || 1 != primary_flag)
				{
						sleep(1);
						continue;
				}

				cur = NULL;
				head = &list_dial_srv.head;
				phead = &list_dial_srv;

				pthread_mutex_lock(&phead->lock);
				list_for_each(cur,head) 
				{

						srv_node = (dial_srv_node_t *)cur;
						if(true != g_cfg.srv_cfg.allowed[srv_node->srv_tpye])//server dial switch
						{
								continue;
						}

						gettimeofday(&t_now,NULL);	
						if(((t_now.tv_sec * 1000*1000 + t_now.tv_usec) - (srv_node->t_insert.tv_sec * 1000*1000 + srv_node->t_insert.tv_usec)) >= 0) 
						{

								add_server_task_to_queue(srv_node);

								srv_node->t_insert = t_now;
								srv_node->t_insert.tv_sec += g_cfg.srv_cfg.interval;					
						}				
				}
				pthread_mutex_unlock(&phead->lock);

				sleep(1);
		}

}



void *nginxgroup_monitor_thread(void *arg)
{
		int i = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head =NULL;
		DIAL_LIST_HEAD *phead = NULL;
		DIAL_LIST_NODE *cur_p = NULL;
		DIAL_LIST_NODE *tmp_p = NULL;
		DIAL_LIST_NODE *head_p =NULL;
		pPolicy_node_t *policy = NULL;
		nginxgroup_info_t *ng = NULL;
		struct timeval t_now;


		while(thread_exit_flag) 
		{

				if(false == client_connecting_flag || 1 != primary_flag)
				{
						sleep(1);
						continue;
				}	

				for(i = 0; i < hs_nginx_group.num; ++i) 
				{

						cur = NULL;
						head = &(hs_nginx_group.tab[i].head);
						phead = &(hs_nginx_group.tab[i]);

						pthread_mutex_lock(&phead->lock);
						list_for_each_safe(cur,tmp,head) 
						{
								ng = (nginxgroup_info_t *)cur;

								head_p = &ng->pPolicy_head.head;
								list_for_each_safe(cur_p,tmp_p,head_p) 
								{
										policy = (pPolicy_node_t *)cur_p;

										gettimeofday(&t_now,NULL);
										if(((t_now.tv_sec * 1000*1000 + t_now.tv_usec) - (policy->t_insert.tv_sec * 1000*1000 + policy->t_insert.tv_usec)) >= 0) 
										{

												add_nginxgroup_task_to_queue(ng,policy->pPolicy);

												policy->t_insert = t_now;
												policy->t_insert.tv_sec += policy->pPolicy->freq;					
										}
								}
						}
						pthread_mutex_unlock(&phead->lock);
				}	
				sleep(1);
		}

}


void *ipsec_monitor_thread(void *arg)
{
		int res = 0;
		map<string,ipsec_node_t>::iterator iter;

		while(thread_exit_flag) 
		{
				if(false == client_connecting_flag || 1 != primary_flag)
				{
						sleep(1);
						continue;
				}
				
				pthread_rwlock_rdlock(&ipsec_map_lock);

				for(iter = ipsec_map.begin() ; iter != ipsec_map.end() ; iter++)
				{
						if(0 != iter->second.tid)
						{
								continue;
						}

						iter->second.work_flag = true;
						res = pthread_create(&iter->second.tid,NULL,ipsec_work_thread,&iter->second);
						if(0 != res)
						{
								iter->second.tid = 0;
								iter->second.work_flag = false;
								debug_printf(LOG_LEVEL_ERROR,"create ipsec work thread failed,ip=%s\n",iter->second.ipsec.ipsec.ip.addr.c_str());
						}

						debug_printf(LOG_LEVEL_BASIC,"create a ipsec task thread ipsec=%s,tid=%u\n",iter->second.ipsec.ipsec.ip.addr.c_str(),iter->second.tid);
				}

				pthread_rwlock_unlock(&ipsec_map_lock);

				sleep(1);
		}
}


void *snmpgroup_monitor_thread(void *arg)
{
		int res = 0;
		map<string,snmp_node_t>::iterator iter;

		debug_printf(LOG_LEVEL_BASIC,"my tid=%u\n",pthread_self());
		while(thread_exit_flag) 
		{
				//if(false == client_connecting_flag || 1 != primary_flag)
				if(false == client_connecting_flag)
				{
						sleep(1);
						continue;
				}

				pthread_rwlock_rdlock(&snmp_map_lock);

				for(iter = snmp_map.begin() ; iter != snmp_map.end() ; iter++)
				{
						if(0 != iter->second.tid)
						{
								continue;
						}

						iter->second.work_flag = true;
						res = pthread_create(&iter->second.tid,NULL,snmp_work_thread,&iter->second);
						if(0 != res)
						{
								iter->second.tid = 0;
								iter->second.work_flag = false;
								debug_printf(LOG_LEVEL_ERROR,"create snmp work thread failed\n");
						}
						debug_printf(LOG_LEVEL_BASIC,"create a snmp task thread ip=%s,tid=%u\n",iter->second.snmp.ip.addr.c_str(),iter->second.tid);
				}

				pthread_rwlock_unlock(&snmp_map_lock);

				sleep(1);
		}
}



void *healthgroup_updata_result_thread(void*arg)
{
		int sec = 0,size = 0;

		while(thread_exit_flag)
		{
				size = health_results.size();

				if(size >= 2000 || (size > 0 && size < 2000 && sec >= 5))
				{
						debug_printf(LOG_LEVEL_TEST,"send update health group num = %d\n",size);
						pthread_mutex_lock(&health_results_lock);
						send_update_health_status(health_results);
						health_results.clear();
						pthread_mutex_unlock(&health_results_lock);
						sec = 0;
						continue;
				}
				else if(size == 0 && sec == 5)
				{
						sec = 0;	
				}
				
				sleep(1);
				sec++;
		}
}


void *nginxgroup_updata_result_thread(void*arg)
{
		int sec = 0,size = 0;

		while(thread_exit_flag)
		{
				size = nginx_results.size();

				if(size >= 2000 || (size > 0 && size < 2000 && sec >= 5))
				{
						debug_printf(LOG_LEVEL_TEST,"send update nginx group num = %d\n",size);
						pthread_mutex_lock(&nginx_results_lock);
						send_update_nginx_status(nginx_results);
						nginx_results.clear();
						pthread_mutex_unlock(&nginx_results_lock);
						sec = 0;
						continue;
				}
				else if(size == 0 && sec == 5)
				{
						sec = 0;	
				}
				
				sleep(1);
				sec++;
		}
}


void *server_updata_result_thread(void*arg)
{
		int sec = 0,size = 0;

		while(thread_exit_flag)
		{
				size = server_results.size();

				if(size >= 2000 || (size > 0 && size < 2000 && sec >= 10))
				{
						debug_printf(LOG_LEVEL_TEST,"send update server num = %d\n",size);
						pthread_mutex_lock(&server_results_lock);
						send_update_server_status(server_results);
						server_results.clear();
						pthread_mutex_unlock(&server_results_lock);
						sec = 0;
						continue;
				}
				else if(size == 0 && sec == 10)
				{
						sec = 0;	
				}
				
				sleep(1);
				sec++;
		}
}


void *dial_monitor_queue_thread(void *arg)
{    
		int i = 0,count = 0;

		while(thread_exit_flag) 
		{
				if(false == client_connecting_flag || 1 != primary_flag)
				{
						//debug_printf(LOG_LEVEL_DEBUG,"client_connecting_flag=%d,primary_flag=%d!!\n",client_connecting_flag,primary_flag);
						sleep(1);
						continue;
				}	
				
				if(tp.threads_used < tp.act_threads_num && NULL != queue_info.tail && queue_info.cnt > 0) 
				{
						pthread_cond_signal(&tp.cond);
						debug_printf(LOG_LEVEL_TEST,"signaling queue task num=%d task,used thread num=%d!!\n",queue_info.cnt,tp.threads_used);
						continue;
				}
				else if(queue_info.cnt > 20000 && NULL != queue_info.tail && tp.threads_used == tp.act_threads_num)
				{
						debug_printf(LOG_LEVEL_TEST,"clear start! queue task num=%d,used thread num=%d!!\n",queue_info.cnt,tp.threads_used);
						queue_clear(&queue_info);
						debug_printf(LOG_LEVEL_TEST,"clear over! queue task num=%d,used thread num=%d!!\n",queue_info.cnt,tp.threads_used);
				}
		
				sleep(1);
				//debug_printf(LOG_LEVEL_DEBUG,"queue task num=%d task,used thread num=%d!!\n",queue_info.cnt,tp.threads_used);

		}
}


void *start_register_thread(void *arg)
{
		cfg_debug_printf(LOG_LEVEL_BASIC,"start_register_thread:register start!!!\n");
		bool success_flag = true;

		while(1) 
		{
				if(success_flag)
				{
						usleep(50*1000);
				}	
				else
				{
						sleep(2);
				}

				try
				{
						RetCode::type ret;

						transport_client->open(); 
						AgentClient client(protocol_client);
						ret = client.registerModule(ModuleType::DIALING);
						if(ret != RetCode::OK) 
						{
								debug_printf(LOG_LEVEL_ERROR,"start_register_thread:register failed,continue!!\n");
								continue;
						}

				}
				catch(std::exception &e) 
				{
						success_flag = false;
						debug_printf(LOG_LEVEL_ERROR,"start_register_thread:catch an exception!-->%s\n",e.what());
						continue;
				}
				client_connecting_flag = true;
				registered_flag = true;
				break;
		}
		cfg_debug_printf(LOG_LEVEL_BASIC,"start_register_thread:register success!!!\n");
}



void *client_reconnect_thread(void *arg)
{
		cfg_debug_printf(LOG_LEVEL_BASIC,"client_reconnect_thread: register start!\n");
		bool success_flag = true;

		while(1) 
		{
				sleep(1);

				try
				{

						transport_client->open(); 

				}
				catch(std::exception &e) 
				{
						debug_printf(LOG_LEVEL_ERROR,"client_reconnect_thread:catch an exception!-->%s\n",e.what());
						continue;
				}
				client_connecting_flag = true;
				break;
		}
		cfg_debug_printf(LOG_LEVEL_DEBUG,"client_reconnect_thread: register success!!!\n");
}



int
set_core_file()
{
	struct rlimit rlim_new,rlim;
	
	if (getrlimit(RLIMIT_CORE, &rlim)==0) {
  		rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;
  		if (setrlimit(RLIMIT_CORE, &rlim_new)!=0) {
   			rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
    		(void) setrlimit(RLIMIT_CORE, &rlim_new);			
			cfg_debug_printf(LOG_LEVEL_ERROR,"set_core_file:setrlimit failed!!\n");
			return -1;
 		 }
	}else{
		cfg_debug_printf(LOG_LEVEL_ERROR,"set_core_file:getrlimit failed!!\n");
		return -1;
	}

	return 0;
}


void
log_debug_open(int sig)
{
	s_debug_switch = true;
}


void
log_debug_close(int sig)
{
	s_debug_switch = false;
}


void 
set_timer_handler(int sig)
{
	debug_printf(LOG_LEVEL_BASIC,"set_timer_handler:log closed!!\n");

	log_debug_close(sig);
}


int
signal_init()
{

	// 
	if(SIG_ERR == signal(SIGUSR1,log_debug_close)) {
		cfg_debug_printf(LOG_LEVEL_ERROR,"signal_init:can't catch SIGUSR1!!\n");
		return ERROR;
	}
	if(SIG_ERR == signal(SIGUSR2,log_debug_open)) {
		cfg_debug_printf(LOG_LEVEL_ERROR,"signal_init:can't catch SIGUSR2!!\n");
		return ERROR;
	}
	//
	if(SIG_ERR == signal(SIGALRM,set_timer_handler)) {
		cfg_debug_printf(LOG_LEVEL_ERROR,"signal_init:can't catch SIGALRM!!\n");
		return ERROR;
	}
	return NO_ERROR;
}

int
sys_log_timer_init()
{	
	struct itimerval 		timer; 
	int ret = 0;

	memset(&timer, 0, sizeof(timer));

	
	// 5
	timer.it_value.tv_sec = 5*60;
	timer.it_value.tv_usec = 0;
	timer.it_interval = timer.it_value;
	
       // ITIMER_REAL
	ret = setitimer(ITIMER_REAL, &timer, NULL);
	if(ret < 0) 
	{
		debug_printf(LOG_LEVEL_ERROR,"sys_log_timer_init:setitimer failed!!\n");
		return ERROR;
	}

	return NO_ERROR;	   
}


void parse_arg(int argc,char **argv,bool &need_daemon)
{
		int i = 0;

		if(argc >= 2)
		{
				for(i = 1; i < argc; i++)
				{

						if (strcmp("start", argv[i]) == 0) 
						{
								need_daemon = true;
								continue;
						} 
						else if (strcmp("stop", argv[i]) == 0) 
						{
								daemon_stop();
								exit(0);
						} 
						else if (strcmp("restart", argv[i]) == 0) 
						{
								daemon_stop();
								need_daemon = true;
								continue;
						}
						else if(strcmp("-v", argv[i]) == 0)
						{
								printf("%s",DIAL_VERSION);
								exit(0);
						} 
						else 
						{
								printf("unkown param:%s\n",argv[i]);
								exit(0);
						}
				}
		}
		else
		{
				printf("usage:dial start|stop|restart\n");
				exit(0);
		}

}


int monitor_thread_init(pthread_t *td)
{
		int rtn = 0;

		if ((rtn = pthread_create(&td[0],NULL,healthgroup_monitor_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!healthgroup_monitor_thread,rtn = %d\n",rtn);
				return ERROR;
		}

		if ((rtn = pthread_create(&td[1],NULL,server_monitor_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!server_monitor_thread,rtn = %d\n",rtn);
				return ERROR;
		}

		if ((rtn = pthread_create(&td[2],NULL,nginxgroup_monitor_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!nginxgroup_monitor_thread,rtn = %d\n",rtn);
				return ERROR;
		}	

		if ((rtn = pthread_create(&td[3],NULL,snmpgroup_monitor_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!snmpgroup_monitor_thread,rtn = %d\n",rtn);
				return ERROR;
		}

		if ((rtn = pthread_create(&td[4],NULL,ipsec_monitor_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!ipsec_monitor_thread,rtn = %d\n",rtn);
				return ERROR;
		}

		if ((rtn = pthread_create(&td[5],NULL,dial_monitor_queue_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!dial_monitor_queue_thread,rtn = %d\n",rtn);
				return ERROR;
		}	

		if ((rtn = pthread_create(&td[6],NULL,healthgroup_updata_result_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!healthgroup_updata_result_thread,rtn = %d\n",rtn);
				return ERROR;
		}	

		if ((rtn = pthread_create(&td[7],NULL,nginxgroup_updata_result_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!nginxgroup_updata_result_thread,rtn = %d\n",rtn);
				return ERROR;
		}	

		if ((rtn = pthread_create(&td[8],NULL,server_updata_result_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!server_updata_result_thread,rtn = %d\n",rtn);
				return ERROR;
		}	

		if ((rtn = pthread_create(&td[9],NULL,start_register_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!start_register_thread,rtn = %d\n",rtn);
				return ERROR;
		}			
}


void monitor_thread_join(pthread_t*td,int monitor_thread_num)
{
		int i = 0;

		for(i = 0 ; i < monitor_thread_num ; i++)
		{
				pthread_join(td[i],NULL);
		}
}


void addprocess(const std::string& snmp, const std::string& processname)
{
		ProcessInfo process;	
		map<string,snmp_node_t>::iterator iter;
		
		iter = snmp_map.find(snmp);
		if(iter == snmp_map.end())
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addprocess:failed!!!,snmp node not exist snmp_id=%s,process=%s,id=%s\n",snmp.c_str(),processname.c_str(),snmp.c_str());
				return;
		}

		process.name = processname;
		pthread_rwlock_wrlock(&iter->second.process_lock);
		snmp_map[snmp].process.push_back(process);
		pthread_rwlock_unlock(&iter->second.process_lock);
		cfg_debug_printf(LOG_LEVEL_BASIC,"addprocess:success!!!,snmp_id=%s,process=%s,id=%s\n",snmp.c_str(),processname.c_str(),snmp.c_str());

}

int main(int argc, char **argv) 
{
		int rtn = NO_ERROR;
		pthread_t td[10] = {0};
		bool need_daemon = false;

		parse_arg(argc,argv,need_daemon);

		if(need_daemon)
		{
				daemon_start(1);
		}

		rtn = sys_init();
		if(rtn != NO_ERROR) 
		{
				printf("process start failed!\n");
				return ERROR;
		}

		set_core_file();

		rtn = threadpool_init(&tp,THREAD_POOL_NUM);
		if(0 != rtn) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"sys_init:threadpool_init  failed!!\n");
				return ERROR;
		}

		rtn = monitor_thread_init(td);
		if(ERROR == rtn)
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"monitor_thrad_init:failed!!\n");
				return ERROR;
		}

#if 1
		SnmpGroupInfo snmp;

		snmp.ip.addr.assign("192.168.6.55");
		//snmp.ip.addr.assign("127.0.0.1");
		snmp.community.assign("test");
		//snmp.community.assign("public");
		snmp.user.assign("hww");
		snmp.name.assign("snmptest");
		snmp.passwd.assign("heweiwei123");
		snmp.version = 3;
		snmp.interval = 10;

		snmp_node_t snmp_node;
		snmp_node.tid = 0;
		snmp_node.work_flag = false;
		pthread_rwlock_init(&snmp_node.process_lock,NULL);
		snmp_node.snmp = snmp;
		pthread_rwlock_wrlock(&snmp_map_lock);
		snmp_map[snmp.name] = snmp_node;
		pthread_rwlock_unlock(&snmp_map_lock);
		cfg_debug_printf(LOG_LEVEL_BASIC,"addSnmp:success!!!,ip=%s,id=%s\n",snmp.ip.addr.c_str(),snmp.name.c_str());
		
		string pro = "edns_dial";
		addprocess(snmp.name,pro);


#endif
		cfg_debug_printf(LOG_LEVEL_BASIC,"*****************dial module start ***********\n");
		thrift_init(g_cfg.dial_port);
		cfg_debug_printf(LOG_LEVEL_BASIC,"*****************dial module over,thrift died! ***********\n");

		thread_exit_flag = false;
		sleep(5);
		sys_free();
		monitor_thread_join(td,9);

		return NO_ERROR;
}

