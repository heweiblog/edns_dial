/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef dnsrpc_TYPES_H
#define dnsrpc_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace rpc { namespace yamutech { namespace com {

struct ModuleType {
  enum type {
    CRM = 1,
    DIALING = 2,
    YRDNS = 3
  };
};

extern const std::map<int, const char*> _ModuleType_VALUES_TO_NAMES;

struct LogLevel {
  enum type {
    NORMAL = 0,
    WARN = 1,
    ERROR = 2
  };
};

extern const std::map<int, const char*> _LogLevel_VALUES_TO_NAMES;

struct DialStatus {
  enum type {
    OK = 0,
    FAIL = 1
  };
};

extern const std::map<int, const char*> _DialStatus_VALUES_TO_NAMES;

struct RetCode {
  enum type {
    OK = 0,
    FAIL = 1
  };
};

extern const std::map<int, const char*> _RetCode_VALUES_TO_NAMES;

struct SecParamName {
  enum type {
    SEC_PARAM_WHITELIST = 0,
    SEC_PARAM_ACL = 1,
    SEC_PARAM_QPSLIMIT = 2,
    SEC_PARAM_BLACKLIST = 3,
    SEC_PARAM_TCP = 4,
    SEC_PARAM_TCPLIMIT = 5,
    SEC_PARAM_ICMPLIMIT = 6,
    SEC_PARAM_CACHEVIRUSLIMIT = 7,
    SEC_PARAM_FILTERIP = 8,
    SEC_PARAM_FILTERUDP = 9,
    SEC_PARAM_FILTERDNS = 10,
    SEC_PARAM_DDOSDEFEND = 11,
    SEC_PARAM_DNSFLOODDEFND = 12
  };
};

extern const std::map<int, const char*> _SecParamName_VALUES_TO_NAMES;

struct DnsParamName {
  enum type {
    DNS_PARAM_AUTH = 0,
    DNS_PARAM_XFORWARD = 1,
    DNS_PARAM_TTL = 2,
    DNS_PARAM_REDIRECT = 3,
    DNS_PARAM_SPREAD = 4,
    DNS_PARAM_RECUSIVE = 5,
    DNS_PARAM_CACHE = 6
  };
};

extern const std::map<int, const char*> _DnsParamName_VALUES_TO_NAMES;

struct Status {
  enum type {
    STATUS_INACTIVE = 0,
    STATUS_ACTIVE = 1
  };
};

extern const std::map<int, const char*> _Status_VALUES_TO_NAMES;

struct DialMethod {
  enum type {
    DIAL_TCPPORT = 0,
    DIAL_IMCP = 1,
    DIAL_HTTPGET = 2,
    DIAL_DATABASE = 3,
    DIAL_EXTHTTPGET = 4
  };
};

extern const std::map<int, const char*> _DialMethod_VALUES_TO_NAMES;

struct AlarmStatus {
  enum type {
    ALARM_OFF = 0,
    ALARM_ON = 1
  };
};

extern const std::map<int, const char*> _AlarmStatus_VALUES_TO_NAMES;

struct AlarmType {
  enum type {
    DNSysDeviceQpsOverAlarm = 0,
    DNSysDeviceRequestIpOverAlarm = 1,
    DNSysDeviceDomainQpsOverAlarm = 2,
    DNSysDeviceDnameQpsOverAlarm = 3,
    DNSysDeviceFocusDomainAlarm = 4,
    DeviceCpuUsageAlarm = 5,
    DeviceMemoryUsageAlarm = 6,
    DevicePartitionUsageAlarm = 7,
    DeviceNicFlowOverAlarm = 8,
    NoneDeviceConnectionAlarm = 9,
    DeviceProcessAlarm = 10,
    DNSysDeviceServfailOverAlarm = 11,
    ForwardFailAlarm = 12,
    ProxyFailAlarm = 13,
    ServiceFailAlarm = 14,
    DiskFailAlarm = 15,
    LogAlarm = 16,
    RecordialFailAlarm = 17,
    RedirectFailAlarm = 18,
    NginxServerFailAlarm = 19,
    DhcpPoolAlarm = 20,
    DhcpIpAddressConflictsAlarm = 21,
    DhcpQpsAlarm = 22,
    DhcpIlegalServerAlarm = 23,
    DDNSAlarm = 24,
    HostHaAlarm = 25
  };
};

extern const std::map<int, const char*> _AlarmType_VALUES_TO_NAMES;

struct ModuleState {
  enum type {
    STARTUP = 0,
    REGISTERED = 1
  };
};

extern const std::map<int, const char*> _ModuleState_VALUES_TO_NAMES;

struct SysCommand {
  enum type {
    RestoreConfig = 0
  };
};

extern const std::map<int, const char*> _SysCommand_VALUES_TO_NAMES;

struct DialServerType {
  enum type {
    XPROXY = 0,
    REDIRECT = 1,
    XFORWARD = 2
  };
};

extern const std::map<int, const char*> _DialServerType_VALUES_TO_NAMES;

struct RecordType {
  enum type {
    A = 0,
    AAAA = 1,
    NS = 2,
    CNAME = 3,
    PTR = 4,
    TXT = 5,
    SRV = 6,
    NAPTR = 7,
    MX = 8
  };
};

extern const std::map<int, const char*> _RecordType_VALUES_TO_NAMES;

struct DNameType {
  enum type {
    DNAME_NONE = 0,
    DNAME_WHOLE = 1,
    DNAME_PREFIX = 2,
    DNAME_POSTFIX = 3
  };
};

extern const std::map<int, const char*> _DNameType_VALUES_TO_NAMES;

typedef std::string ObjectId;

class Xception;

class RetRecord;

class IpAddr;

class DialNginxServer;

class DialRecordStatus;

class DialNginxStatus;

class DialRecordAlarm;

class DialServerStatus;

class IpsecAddress;

class DomainInfo;

class RangeInfo;

class SysIpSec;

class AclInfo;

class ZoneInfo;

class DnsQueryResultSRV;

class DnsQueryResultNAPTR;

class DnsQueryResultMX;

class DnsQueryResult;

class RecordInfo;

class ProxyServer;

class RecurForwardPolicyInfo;

class ProxyPolicyInfo;

class TtlPolicyInfo;

class ForwardPolicyInfo;

class DialRecord;

class HealthGroupInfo;

class DialOption;

class HealthPolicyInfo;

class FilterReportInfo;

class RequestReportInfo;

class GeneralReportInfo;

class DNameAccessInfo;

class XProxyReportInfo;

class XForwardReportInfo;

class RecursiveReportInfo;

class BackGroundReportInfo;

class TopnIpInfo;

class TopnDomainInfo;

class TopnDnameInfo;

class DDosInfo;

class HostInfo;

class HeartBeatState;

class IpOverAlarm;

class DomainOverAlarm;

class NginxServerAlarm;

class ZoneRequestReport;

class ZoneAnswerReport;

class XproxyReport;

class XforwardReport;

class RedirectServerInfo;

class NginxProxyInfo;

class CateWeight;

class DialHealthResult;

class DialServerResult;

class DialNginxResult;

class SnmpGroupInfo;

class InterfaceTraffic;

class IpMac;

class InterfaceInfo;

class RouteInfo;

class SysInfo;

class ProcessInfo;

typedef struct _Xception__isset {
  _Xception__isset() : errorCode(false), message(false) {}
  bool errorCode :1;
  bool message :1;
} _Xception__isset;

class Xception : public ::apache::thrift::TException {
 public:

  Xception(const Xception&);
  Xception& operator=(const Xception&);
  Xception() : errorCode(0), message() {
  }

  virtual ~Xception() throw();
  int32_t errorCode;
  std::string message;

  _Xception__isset __isset;

  void __set_errorCode(const int32_t val);

  void __set_message(const std::string& val);

  bool operator == (const Xception & rhs) const
  {
    if (!(errorCode == rhs.errorCode))
      return false;
    if (!(message == rhs.message))
      return false;
    return true;
  }
  bool operator != (const Xception &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Xception & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
  mutable std::string thriftTExceptionMessageHolder_;
  const char* what() const throw();
};

void swap(Xception &a, Xception &b);

inline std::ostream& operator<<(std::ostream& out, const Xception& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RetRecord__isset {
  _RetRecord__isset() : recordId(false), code(false) {}
  bool recordId :1;
  bool code :1;
} _RetRecord__isset;

class RetRecord {
 public:

  RetRecord(const RetRecord&);
  RetRecord& operator=(const RetRecord&);
  RetRecord() : recordId(), code((RetCode::type)0) {
  }

  virtual ~RetRecord() throw();
  std::string recordId;
  RetCode::type code;

  _RetRecord__isset __isset;

  void __set_recordId(const std::string& val);

  void __set_code(const RetCode::type val);

  bool operator == (const RetRecord & rhs) const
  {
    if (!(recordId == rhs.recordId))
      return false;
    if (!(code == rhs.code))
      return false;
    return true;
  }
  bool operator != (const RetRecord &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RetRecord & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RetRecord &a, RetRecord &b);

inline std::ostream& operator<<(std::ostream& out, const RetRecord& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _IpAddr__isset {
  _IpAddr__isset() : version(false), addr(false) {}
  bool version :1;
  bool addr :1;
} _IpAddr__isset;

class IpAddr {
 public:

  IpAddr(const IpAddr&);
  IpAddr& operator=(const IpAddr&);
  IpAddr() : version(0), addr() {
  }

  virtual ~IpAddr() throw();
  int32_t version;
  std::string addr;

  _IpAddr__isset __isset;

  void __set_version(const int32_t val);

  void __set_addr(const std::string& val);

  bool operator == (const IpAddr & rhs) const
  {
    if (!(version == rhs.version))
      return false;
    if (!(addr == rhs.addr))
      return false;
    return true;
  }
  bool operator != (const IpAddr &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IpAddr & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IpAddr &a, IpAddr &b);

inline std::ostream& operator<<(std::ostream& out, const IpAddr& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DialNginxServer__isset {
  _DialNginxServer__isset() : localURL(false), priority(false) {}
  bool localURL :1;
  bool priority :1;
} _DialNginxServer__isset;

class DialNginxServer {
 public:

  DialNginxServer(const DialNginxServer&);
  DialNginxServer& operator=(const DialNginxServer&);
  DialNginxServer() : localURL(), priority(0) {
  }

  virtual ~DialNginxServer() throw();
  std::string localURL;
  int32_t priority;

  _DialNginxServer__isset __isset;

  void __set_localURL(const std::string& val);

  void __set_priority(const int32_t val);

  bool operator == (const DialNginxServer & rhs) const
  {
    if (!(localURL == rhs.localURL))
      return false;
    if (!(priority == rhs.priority))
      return false;
    return true;
  }
  bool operator != (const DialNginxServer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialNginxServer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DialNginxServer &a, DialNginxServer &b);

inline std::ostream& operator<<(std::ostream& out, const DialNginxServer& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DialRecordStatus__isset {
  _DialRecordStatus__isset() : rid(false), status(false), delay(false) {}
  bool rid :1;
  bool status :1;
  bool delay :1;
} _DialRecordStatus__isset;

class DialRecordStatus {
 public:

  DialRecordStatus(const DialRecordStatus&);
  DialRecordStatus& operator=(const DialRecordStatus&);
  DialRecordStatus() : rid(), status((DialStatus::type)0), delay(0) {
  }

  virtual ~DialRecordStatus() throw();
  ObjectId rid;
  DialStatus::type status;
  int64_t delay;

  _DialRecordStatus__isset __isset;

  void __set_rid(const ObjectId& val);

  void __set_status(const DialStatus::type val);

  void __set_delay(const int64_t val);

  bool operator == (const DialRecordStatus & rhs) const
  {
    if (!(rid == rhs.rid))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(delay == rhs.delay))
      return false;
    return true;
  }
  bool operator != (const DialRecordStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialRecordStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DialRecordStatus &a, DialRecordStatus &b);

inline std::ostream& operator<<(std::ostream& out, const DialRecordStatus& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DialNginxStatus__isset {
  _DialNginxStatus__isset() : server(false), status(false), delay(false) {}
  bool server :1;
  bool status :1;
  bool delay :1;
} _DialNginxStatus__isset;

class DialNginxStatus {
 public:

  DialNginxStatus(const DialNginxStatus&);
  DialNginxStatus& operator=(const DialNginxStatus&);
  DialNginxStatus() : status((DialStatus::type)0), delay(0) {
  }

  virtual ~DialNginxStatus() throw();
  DialNginxServer server;
  DialStatus::type status;
  int64_t delay;

  _DialNginxStatus__isset __isset;

  void __set_server(const DialNginxServer& val);

  void __set_status(const DialStatus::type val);

  void __set_delay(const int64_t val);

  bool operator == (const DialNginxStatus & rhs) const
  {
    if (!(server == rhs.server))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(delay == rhs.delay))
      return false;
    return true;
  }
  bool operator != (const DialNginxStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialNginxStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DialNginxStatus &a, DialNginxStatus &b);

inline std::ostream& operator<<(std::ostream& out, const DialNginxStatus& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DialRecordAlarm__isset {
  _DialRecordAlarm__isset() : ip(false), enable(false), dial(false) {}
  bool ip :1;
  bool enable :1;
  bool dial :1;
} _DialRecordAlarm__isset;

class DialRecordAlarm {
 public:

  DialRecordAlarm(const DialRecordAlarm&);
  DialRecordAlarm& operator=(const DialRecordAlarm&);
  DialRecordAlarm() : enable(0), dial(0) {
  }

  virtual ~DialRecordAlarm() throw();
  IpAddr ip;
  bool enable;
  bool dial;

  _DialRecordAlarm__isset __isset;

  void __set_ip(const IpAddr& val);

  void __set_enable(const bool val);

  void __set_dial(const bool val);

  bool operator == (const DialRecordAlarm & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(enable == rhs.enable))
      return false;
    if (!(dial == rhs.dial))
      return false;
    return true;
  }
  bool operator != (const DialRecordAlarm &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialRecordAlarm & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DialRecordAlarm &a, DialRecordAlarm &b);

inline std::ostream& operator<<(std::ostream& out, const DialRecordAlarm& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DialServerStatus__isset {
  _DialServerStatus__isset() : rid(false), ip(false), status(false), delay(false) {}
  bool rid :1;
  bool ip :1;
  bool status :1;
  bool delay :1;
} _DialServerStatus__isset;

class DialServerStatus {
 public:

  DialServerStatus(const DialServerStatus&);
  DialServerStatus& operator=(const DialServerStatus&);
  DialServerStatus() : rid(), status((DialStatus::type)0), delay(0) {
  }

  virtual ~DialServerStatus() throw();
  ObjectId rid;
  IpAddr ip;
  DialStatus::type status;
  int64_t delay;

  _DialServerStatus__isset __isset;

  void __set_rid(const ObjectId& val);

  void __set_ip(const IpAddr& val);

  void __set_status(const DialStatus::type val);

  void __set_delay(const int64_t val);

  bool operator == (const DialServerStatus & rhs) const
  {
    if (!(rid == rhs.rid))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(delay == rhs.delay))
      return false;
    return true;
  }
  bool operator != (const DialServerStatus &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialServerStatus & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DialServerStatus &a, DialServerStatus &b);

inline std::ostream& operator<<(std::ostream& out, const DialServerStatus& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _IpsecAddress__isset {
  _IpsecAddress__isset() : ip(false), mask(false) {}
  bool ip :1;
  bool mask :1;
} _IpsecAddress__isset;

class IpsecAddress {
 public:

  IpsecAddress(const IpsecAddress&);
  IpsecAddress& operator=(const IpsecAddress&);
  IpsecAddress() : mask(0) {
  }

  virtual ~IpsecAddress() throw();
  IpAddr ip;
  int32_t mask;

  _IpsecAddress__isset __isset;

  void __set_ip(const IpAddr& val);

  void __set_mask(const int32_t val);

  bool operator == (const IpsecAddress & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(mask == rhs.mask))
      return false;
    return true;
  }
  bool operator != (const IpsecAddress &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IpsecAddress & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IpsecAddress &a, IpsecAddress &b);

inline std::ostream& operator<<(std::ostream& out, const IpsecAddress& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DomainInfo__isset {
  _DomainInfo__isset() : typ(false), name(false) {}
  bool typ :1;
  bool name :1;
} _DomainInfo__isset;

class DomainInfo {
 public:

  DomainInfo(const DomainInfo&);
  DomainInfo& operator=(const DomainInfo&);
  DomainInfo() : typ(), name() {
  }

  virtual ~DomainInfo() throw();
  std::string typ;
  std::string name;

  _DomainInfo__isset __isset;

  void __set_typ(const std::string& val);

  void __set_name(const std::string& val);

  bool operator == (const DomainInfo & rhs) const
  {
    if (!(typ == rhs.typ))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const DomainInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DomainInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DomainInfo &a, DomainInfo &b);

inline std::ostream& operator<<(std::ostream& out, const DomainInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RangeInfo__isset {
  _RangeInfo__isset() : start(false), ends(false) {}
  bool start :1;
  bool ends :1;
} _RangeInfo__isset;

class RangeInfo {
 public:

  RangeInfo(const RangeInfo&);
  RangeInfo& operator=(const RangeInfo&);
  RangeInfo() : start(0), ends(0) {
  }

  virtual ~RangeInfo() throw();
  int16_t start;
  int16_t ends;

  _RangeInfo__isset __isset;

  void __set_start(const int16_t val);

  void __set_ends(const int16_t val);

  bool operator == (const RangeInfo & rhs) const
  {
    if (!(start == rhs.start))
      return false;
    if (!(ends == rhs.ends))
      return false;
    return true;
  }
  bool operator != (const RangeInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RangeInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RangeInfo &a, RangeInfo &b);

inline std::ostream& operator<<(std::ostream& out, const RangeInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SysIpSec__isset {
  _SysIpSec__isset() : name(false), ipsec(false), recordId(false) {}
  bool name :1;
  bool ipsec :1;
  bool recordId :1;
} _SysIpSec__isset;

class SysIpSec {
 public:

  SysIpSec(const SysIpSec&);
  SysIpSec& operator=(const SysIpSec&);
  SysIpSec() : name(), recordId() {
  }

  virtual ~SysIpSec() throw();
  std::string name;
  IpsecAddress ipsec;
  std::string recordId;

  _SysIpSec__isset __isset;

  void __set_name(const std::string& val);

  void __set_ipsec(const IpsecAddress& val);

  void __set_recordId(const std::string& val);

  bool operator == (const SysIpSec & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(ipsec == rhs.ipsec))
      return false;
    if (!(recordId == rhs.recordId))
      return false;
    return true;
  }
  bool operator != (const SysIpSec &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SysIpSec & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SysIpSec &a, SysIpSec &b);

inline std::ostream& operator<<(std::ostream& out, const SysIpSec& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _AclInfo__isset {
  _AclInfo__isset() : id(false), priority(false), srcIpSec(false), dstIpSec(false), srcPortSec(false), dstPortSec(false), frameTypeSec(false), ipProtoSec(false), qpsLimit(false) {}
  bool id :1;
  bool priority :1;
  bool srcIpSec :1;
  bool dstIpSec :1;
  bool srcPortSec :1;
  bool dstPortSec :1;
  bool frameTypeSec :1;
  bool ipProtoSec :1;
  bool qpsLimit :1;
} _AclInfo__isset;

class AclInfo {
 public:

  AclInfo(const AclInfo&);
  AclInfo& operator=(const AclInfo&);
  AclInfo() : id(), priority(0), qpsLimit(0) {
  }

  virtual ~AclInfo() throw();
  ObjectId id;
  int32_t priority;
  IpsecAddress srcIpSec;
  IpsecAddress dstIpSec;
  RangeInfo srcPortSec;
  RangeInfo dstPortSec;
  RangeInfo frameTypeSec;
  RangeInfo ipProtoSec;
  int32_t qpsLimit;

  _AclInfo__isset __isset;

  void __set_id(const ObjectId& val);

  void __set_priority(const int32_t val);

  void __set_srcIpSec(const IpsecAddress& val);

  void __set_dstIpSec(const IpsecAddress& val);

  void __set_srcPortSec(const RangeInfo& val);

  void __set_dstPortSec(const RangeInfo& val);

  void __set_frameTypeSec(const RangeInfo& val);

  void __set_ipProtoSec(const RangeInfo& val);

  void __set_qpsLimit(const int32_t val);

  bool operator == (const AclInfo & rhs) const
  {
    if (!(id == rhs.id))
      return false;
    if (__isset.priority != rhs.__isset.priority)
      return false;
    else if (__isset.priority && !(priority == rhs.priority))
      return false;
    if (__isset.srcIpSec != rhs.__isset.srcIpSec)
      return false;
    else if (__isset.srcIpSec && !(srcIpSec == rhs.srcIpSec))
      return false;
    if (__isset.dstIpSec != rhs.__isset.dstIpSec)
      return false;
    else if (__isset.dstIpSec && !(dstIpSec == rhs.dstIpSec))
      return false;
    if (__isset.srcPortSec != rhs.__isset.srcPortSec)
      return false;
    else if (__isset.srcPortSec && !(srcPortSec == rhs.srcPortSec))
      return false;
    if (__isset.dstPortSec != rhs.__isset.dstPortSec)
      return false;
    else if (__isset.dstPortSec && !(dstPortSec == rhs.dstPortSec))
      return false;
    if (__isset.frameTypeSec != rhs.__isset.frameTypeSec)
      return false;
    else if (__isset.frameTypeSec && !(frameTypeSec == rhs.frameTypeSec))
      return false;
    if (__isset.ipProtoSec != rhs.__isset.ipProtoSec)
      return false;
    else if (__isset.ipProtoSec && !(ipProtoSec == rhs.ipProtoSec))
      return false;
    if (__isset.qpsLimit != rhs.__isset.qpsLimit)
      return false;
    else if (__isset.qpsLimit && !(qpsLimit == rhs.qpsLimit))
      return false;
    return true;
  }
  bool operator != (const AclInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const AclInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(AclInfo &a, AclInfo &b);

inline std::ostream& operator<<(std::ostream& out, const AclInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ZoneInfo__isset {
  _ZoneInfo__isset() : name(false), viewName(false), typ(false), nsRecord(false), aRecord(false), soaName(false), soaHost(false), serial(false), refresh(false), retries(false), expire(false), minTtl(false), recordId(false) {}
  bool name :1;
  bool viewName :1;
  bool typ :1;
  bool nsRecord :1;
  bool aRecord :1;
  bool soaName :1;
  bool soaHost :1;
  bool serial :1;
  bool refresh :1;
  bool retries :1;
  bool expire :1;
  bool minTtl :1;
  bool recordId :1;
} _ZoneInfo__isset;

class ZoneInfo {
 public:

  ZoneInfo(const ZoneInfo&);
  ZoneInfo& operator=(const ZoneInfo&);
  ZoneInfo() : name(), viewName(), typ(0), nsRecord(), aRecord(), soaName(), soaHost(), serial(0), refresh(0), retries(0), expire(0), minTtl(0), recordId() {
  }

  virtual ~ZoneInfo() throw();
  std::string name;
  std::string viewName;
  int32_t typ;
  std::string nsRecord;
  std::string aRecord;
  std::string soaName;
  std::string soaHost;
  int32_t serial;
  int32_t refresh;
  int32_t retries;
  int32_t expire;
  int32_t minTtl;
  std::string recordId;

  _ZoneInfo__isset __isset;

  void __set_name(const std::string& val);

  void __set_viewName(const std::string& val);

  void __set_typ(const int32_t val);

  void __set_nsRecord(const std::string& val);

  void __set_aRecord(const std::string& val);

  void __set_soaName(const std::string& val);

  void __set_soaHost(const std::string& val);

  void __set_serial(const int32_t val);

  void __set_refresh(const int32_t val);

  void __set_retries(const int32_t val);

  void __set_expire(const int32_t val);

  void __set_minTtl(const int32_t val);

  void __set_recordId(const std::string& val);

  bool operator == (const ZoneInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(viewName == rhs.viewName))
      return false;
    if (__isset.typ != rhs.__isset.typ)
      return false;
    else if (__isset.typ && !(typ == rhs.typ))
      return false;
    if (__isset.nsRecord != rhs.__isset.nsRecord)
      return false;
    else if (__isset.nsRecord && !(nsRecord == rhs.nsRecord))
      return false;
    if (__isset.aRecord != rhs.__isset.aRecord)
      return false;
    else if (__isset.aRecord && !(aRecord == rhs.aRecord))
      return false;
    if (__isset.soaName != rhs.__isset.soaName)
      return false;
    else if (__isset.soaName && !(soaName == rhs.soaName))
      return false;
    if (__isset.soaHost != rhs.__isset.soaHost)
      return false;
    else if (__isset.soaHost && !(soaHost == rhs.soaHost))
      return false;
    if (__isset.serial != rhs.__isset.serial)
      return false;
    else if (__isset.serial && !(serial == rhs.serial))
      return false;
    if (__isset.refresh != rhs.__isset.refresh)
      return false;
    else if (__isset.refresh && !(refresh == rhs.refresh))
      return false;
    if (__isset.retries != rhs.__isset.retries)
      return false;
    else if (__isset.retries && !(retries == rhs.retries))
      return false;
    if (__isset.expire != rhs.__isset.expire)
      return false;
    else if (__isset.expire && !(expire == rhs.expire))
      return false;
    if (__isset.minTtl != rhs.__isset.minTtl)
      return false;
    else if (__isset.minTtl && !(minTtl == rhs.minTtl))
      return false;
    if (!(recordId == rhs.recordId))
      return false;
    return true;
  }
  bool operator != (const ZoneInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ZoneInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ZoneInfo &a, ZoneInfo &b);

inline std::ostream& operator<<(std::ostream& out, const ZoneInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DnsQueryResultSRV__isset {
  _DnsQueryResultSRV__isset() : priority(false), weight(false), port(false), target(false) {}
  bool priority :1;
  bool weight :1;
  bool port :1;
  bool target :1;
} _DnsQueryResultSRV__isset;

class DnsQueryResultSRV {
 public:

  DnsQueryResultSRV(const DnsQueryResultSRV&);
  DnsQueryResultSRV& operator=(const DnsQueryResultSRV&);
  DnsQueryResultSRV() : priority(0), weight(0), port(0), target() {
  }

  virtual ~DnsQueryResultSRV() throw();
  int16_t priority;
  int16_t weight;
  int16_t port;
  std::string target;

  _DnsQueryResultSRV__isset __isset;

  void __set_priority(const int16_t val);

  void __set_weight(const int16_t val);

  void __set_port(const int16_t val);

  void __set_target(const std::string& val);

  bool operator == (const DnsQueryResultSRV & rhs) const
  {
    if (!(priority == rhs.priority))
      return false;
    if (!(weight == rhs.weight))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(target == rhs.target))
      return false;
    return true;
  }
  bool operator != (const DnsQueryResultSRV &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DnsQueryResultSRV & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DnsQueryResultSRV &a, DnsQueryResultSRV &b);

inline std::ostream& operator<<(std::ostream& out, const DnsQueryResultSRV& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DnsQueryResultNAPTR__isset {
  _DnsQueryResultNAPTR__isset() : order(false), pref(false), flags(false), svc(false), regexp(false), domainName(false) {}
  bool order :1;
  bool pref :1;
  bool flags :1;
  bool svc :1;
  bool regexp :1;
  bool domainName :1;
} _DnsQueryResultNAPTR__isset;

class DnsQueryResultNAPTR {
 public:

  DnsQueryResultNAPTR(const DnsQueryResultNAPTR&);
  DnsQueryResultNAPTR& operator=(const DnsQueryResultNAPTR&);
  DnsQueryResultNAPTR() : order(0), pref(0), flags(), svc(), regexp(), domainName() {
  }

  virtual ~DnsQueryResultNAPTR() throw();
  int16_t order;
  int16_t pref;
  std::string flags;
  std::string svc;
  std::string regexp;
  std::string domainName;

  _DnsQueryResultNAPTR__isset __isset;

  void __set_order(const int16_t val);

  void __set_pref(const int16_t val);

  void __set_flags(const std::string& val);

  void __set_svc(const std::string& val);

  void __set_regexp(const std::string& val);

  void __set_domainName(const std::string& val);

  bool operator == (const DnsQueryResultNAPTR & rhs) const
  {
    if (!(order == rhs.order))
      return false;
    if (!(pref == rhs.pref))
      return false;
    if (!(flags == rhs.flags))
      return false;
    if (!(svc == rhs.svc))
      return false;
    if (!(regexp == rhs.regexp))
      return false;
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const DnsQueryResultNAPTR &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DnsQueryResultNAPTR & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DnsQueryResultNAPTR &a, DnsQueryResultNAPTR &b);

inline std::ostream& operator<<(std::ostream& out, const DnsQueryResultNAPTR& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DnsQueryResultMX__isset {
  _DnsQueryResultMX__isset() : pref(false), domainName(false) {}
  bool pref :1;
  bool domainName :1;
} _DnsQueryResultMX__isset;

class DnsQueryResultMX {
 public:

  DnsQueryResultMX(const DnsQueryResultMX&);
  DnsQueryResultMX& operator=(const DnsQueryResultMX&);
  DnsQueryResultMX() : pref(0), domainName() {
  }

  virtual ~DnsQueryResultMX() throw();
  int16_t pref;
  std::string domainName;

  _DnsQueryResultMX__isset __isset;

  void __set_pref(const int16_t val);

  void __set_domainName(const std::string& val);

  bool operator == (const DnsQueryResultMX & rhs) const
  {
    if (!(pref == rhs.pref))
      return false;
    if (!(domainName == rhs.domainName))
      return false;
    return true;
  }
  bool operator != (const DnsQueryResultMX &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DnsQueryResultMX & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DnsQueryResultMX &a, DnsQueryResultMX &b);

inline std::ostream& operator<<(std::ostream& out, const DnsQueryResultMX& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DnsQueryResult__isset {
  _DnsQueryResult__isset() : a(false), aaaa(false), ns(false), cname(false), ptr(false), txt(false), dname(false), srv(false), naptr(false), mx(false) {}
  bool a :1;
  bool aaaa :1;
  bool ns :1;
  bool cname :1;
  bool ptr :1;
  bool txt :1;
  bool dname :1;
  bool srv :1;
  bool naptr :1;
  bool mx :1;
} _DnsQueryResult__isset;

class DnsQueryResult {
 public:

  DnsQueryResult(const DnsQueryResult&);
  DnsQueryResult& operator=(const DnsQueryResult&);
  DnsQueryResult() : a(), aaaa(), ns(), cname(), ptr(), txt(), dname() {
  }

  virtual ~DnsQueryResult() throw();
  std::string a;
  std::string aaaa;
  std::string ns;
  std::string cname;
  std::string ptr;
  std::string txt;
  std::string dname;
  DnsQueryResultSRV srv;
  DnsQueryResultNAPTR naptr;
  DnsQueryResultMX mx;

  _DnsQueryResult__isset __isset;

  void __set_a(const std::string& val);

  void __set_aaaa(const std::string& val);

  void __set_ns(const std::string& val);

  void __set_cname(const std::string& val);

  void __set_ptr(const std::string& val);

  void __set_txt(const std::string& val);

  void __set_dname(const std::string& val);

  void __set_srv(const DnsQueryResultSRV& val);

  void __set_naptr(const DnsQueryResultNAPTR& val);

  void __set_mx(const DnsQueryResultMX& val);

  bool operator == (const DnsQueryResult & rhs) const
  {
    if (!(a == rhs.a))
      return false;
    if (!(aaaa == rhs.aaaa))
      return false;
    if (!(ns == rhs.ns))
      return false;
    if (!(cname == rhs.cname))
      return false;
    if (!(ptr == rhs.ptr))
      return false;
    if (!(txt == rhs.txt))
      return false;
    if (!(dname == rhs.dname))
      return false;
    if (!(srv == rhs.srv))
      return false;
    if (!(naptr == rhs.naptr))
      return false;
    if (!(mx == rhs.mx))
      return false;
    return true;
  }
  bool operator != (const DnsQueryResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DnsQueryResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DnsQueryResult &a, DnsQueryResult &b);

inline std::ostream& operator<<(std::ostream& out, const DnsQueryResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RecordInfo__isset {
  _RecordInfo__isset() : name(false), viewName(false), zoneName(false), typ(false), result(false), ttl(false), weight(false), status(false), recordId(false), dispatchStatus(false) {}
  bool name :1;
  bool viewName :1;
  bool zoneName :1;
  bool typ :1;
  bool result :1;
  bool ttl :1;
  bool weight :1;
  bool status :1;
  bool recordId :1;
  bool dispatchStatus :1;
} _RecordInfo__isset;

class RecordInfo {
 public:

  RecordInfo(const RecordInfo&);
  RecordInfo& operator=(const RecordInfo&);
  RecordInfo() : name(), viewName(), zoneName(), typ(0), ttl(0), weight(0), status((Status::type)0), recordId(), dispatchStatus(0) {
  }

  virtual ~RecordInfo() throw();
  std::string name;
  std::string viewName;
  std::string zoneName;
  int32_t typ;
  DnsQueryResult result;
  int32_t ttl;
  int32_t weight;
  Status::type status;
  std::string recordId;
  int32_t dispatchStatus;

  _RecordInfo__isset __isset;

  void __set_name(const std::string& val);

  void __set_viewName(const std::string& val);

  void __set_zoneName(const std::string& val);

  void __set_typ(const int32_t val);

  void __set_result(const DnsQueryResult& val);

  void __set_ttl(const int32_t val);

  void __set_weight(const int32_t val);

  void __set_status(const Status::type val);

  void __set_recordId(const std::string& val);

  void __set_dispatchStatus(const int32_t val);

  bool operator == (const RecordInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(viewName == rhs.viewName))
      return false;
    if (!(zoneName == rhs.zoneName))
      return false;
    if (!(typ == rhs.typ))
      return false;
    if (!(result == rhs.result))
      return false;
    if (__isset.ttl != rhs.__isset.ttl)
      return false;
    else if (__isset.ttl && !(ttl == rhs.ttl))
      return false;
    if (__isset.weight != rhs.__isset.weight)
      return false;
    else if (__isset.weight && !(weight == rhs.weight))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    if (!(recordId == rhs.recordId))
      return false;
    if (!(dispatchStatus == rhs.dispatchStatus))
      return false;
    return true;
  }
  bool operator != (const RecordInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RecordInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RecordInfo &a, RecordInfo &b);

inline std::ostream& operator<<(std::ostream& out, const RecordInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ProxyServer__isset {
  _ProxyServer__isset() : ip(false), weight(false), status(false) {}
  bool ip :1;
  bool weight :1;
  bool status :1;
} _ProxyServer__isset;

class ProxyServer {
 public:

  ProxyServer(const ProxyServer&);
  ProxyServer& operator=(const ProxyServer&);
  ProxyServer() : weight(0), status((Status::type)0) {
  }

  virtual ~ProxyServer() throw();
  IpAddr ip;
  int32_t weight;
  Status::type status;

  _ProxyServer__isset __isset;

  void __set_ip(const IpAddr& val);

  void __set_weight(const int32_t val);

  void __set_status(const Status::type val);

  bool operator == (const ProxyServer & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(weight == rhs.weight))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const ProxyServer &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProxyServer & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ProxyServer &a, ProxyServer &b);

inline std::ostream& operator<<(std::ostream& out, const ProxyServer& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RecurForwardPolicyInfo__isset {
  _RecurForwardPolicyInfo__isset() : viewName(false), domain(false), serverGroupName(false), type(false), esc_zone(false) {}
  bool viewName :1;
  bool domain :1;
  bool serverGroupName :1;
  bool type :1;
  bool esc_zone :1;
} _RecurForwardPolicyInfo__isset;

class RecurForwardPolicyInfo {
 public:

  RecurForwardPolicyInfo(const RecurForwardPolicyInfo&);
  RecurForwardPolicyInfo& operator=(const RecurForwardPolicyInfo&);
  RecurForwardPolicyInfo() : viewName(), serverGroupName(), type(0), esc_zone(0) {
  }

  virtual ~RecurForwardPolicyInfo() throw();
  std::string viewName;
  DomainInfo domain;
  std::string serverGroupName;
  int32_t type;
  int32_t esc_zone;

  _RecurForwardPolicyInfo__isset __isset;

  void __set_viewName(const std::string& val);

  void __set_domain(const DomainInfo& val);

  void __set_serverGroupName(const std::string& val);

  void __set_type(const int32_t val);

  void __set_esc_zone(const int32_t val);

  bool operator == (const RecurForwardPolicyInfo & rhs) const
  {
    if (!(viewName == rhs.viewName))
      return false;
    if (!(domain == rhs.domain))
      return false;
    if (__isset.serverGroupName != rhs.__isset.serverGroupName)
      return false;
    else if (__isset.serverGroupName && !(serverGroupName == rhs.serverGroupName))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(esc_zone == rhs.esc_zone))
      return false;
    return true;
  }
  bool operator != (const RecurForwardPolicyInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RecurForwardPolicyInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RecurForwardPolicyInfo &a, RecurForwardPolicyInfo &b);

inline std::ostream& operator<<(std::ostream& out, const RecurForwardPolicyInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ProxyPolicyInfo__isset {
  _ProxyPolicyInfo__isset() : viewName(false), domain(false), serverGroupName(false) {}
  bool viewName :1;
  bool domain :1;
  bool serverGroupName :1;
} _ProxyPolicyInfo__isset;

class ProxyPolicyInfo {
 public:

  ProxyPolicyInfo(const ProxyPolicyInfo&);
  ProxyPolicyInfo& operator=(const ProxyPolicyInfo&);
  ProxyPolicyInfo() : viewName(), serverGroupName() {
  }

  virtual ~ProxyPolicyInfo() throw();
  std::string viewName;
  DomainInfo domain;
  std::string serverGroupName;

  _ProxyPolicyInfo__isset __isset;

  void __set_viewName(const std::string& val);

  void __set_domain(const DomainInfo& val);

  void __set_serverGroupName(const std::string& val);

  bool operator == (const ProxyPolicyInfo & rhs) const
  {
    if (!(viewName == rhs.viewName))
      return false;
    if (!(domain == rhs.domain))
      return false;
    if (__isset.serverGroupName != rhs.__isset.serverGroupName)
      return false;
    else if (__isset.serverGroupName && !(serverGroupName == rhs.serverGroupName))
      return false;
    return true;
  }
  bool operator != (const ProxyPolicyInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProxyPolicyInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ProxyPolicyInfo &a, ProxyPolicyInfo &b);

inline std::ostream& operator<<(std::ostream& out, const ProxyPolicyInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TtlPolicyInfo__isset {
  _TtlPolicyInfo__isset() : domain(false), minTtl(false), maxTtl(false) {}
  bool domain :1;
  bool minTtl :1;
  bool maxTtl :1;
} _TtlPolicyInfo__isset;

class TtlPolicyInfo {
 public:

  TtlPolicyInfo(const TtlPolicyInfo&);
  TtlPolicyInfo& operator=(const TtlPolicyInfo&);
  TtlPolicyInfo() : minTtl(0), maxTtl(0) {
  }

  virtual ~TtlPolicyInfo() throw();
  DomainInfo domain;
  int32_t minTtl;
  int32_t maxTtl;

  _TtlPolicyInfo__isset __isset;

  void __set_domain(const DomainInfo& val);

  void __set_minTtl(const int32_t val);

  void __set_maxTtl(const int32_t val);

  bool operator == (const TtlPolicyInfo & rhs) const
  {
    if (!(domain == rhs.domain))
      return false;
    if (__isset.minTtl != rhs.__isset.minTtl)
      return false;
    else if (__isset.minTtl && !(minTtl == rhs.minTtl))
      return false;
    if (__isset.maxTtl != rhs.__isset.maxTtl)
      return false;
    else if (__isset.maxTtl && !(maxTtl == rhs.maxTtl))
      return false;
    return true;
  }
  bool operator != (const TtlPolicyInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TtlPolicyInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TtlPolicyInfo &a, TtlPolicyInfo &b);

inline std::ostream& operator<<(std::ostream& out, const TtlPolicyInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ForwardPolicyInfo__isset {
  _ForwardPolicyInfo__isset() : ip(false), port(false), weight(false), status(false) {}
  bool ip :1;
  bool port :1;
  bool weight :1;
  bool status :1;
} _ForwardPolicyInfo__isset;

class ForwardPolicyInfo {
 public:

  ForwardPolicyInfo(const ForwardPolicyInfo&);
  ForwardPolicyInfo& operator=(const ForwardPolicyInfo&);
  ForwardPolicyInfo() : port(0), weight(0), status((Status::type)0) {
  }

  virtual ~ForwardPolicyInfo() throw();
  IpAddr ip;
  int16_t port;
  int32_t weight;
  Status::type status;

  _ForwardPolicyInfo__isset __isset;

  void __set_ip(const IpAddr& val);

  void __set_port(const int16_t val);

  void __set_weight(const int32_t val);

  void __set_status(const Status::type val);

  bool operator == (const ForwardPolicyInfo & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(port == rhs.port))
      return false;
    if (__isset.weight != rhs.__isset.weight)
      return false;
    else if (__isset.weight && !(weight == rhs.weight))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const ForwardPolicyInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ForwardPolicyInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ForwardPolicyInfo &a, ForwardPolicyInfo &b);

inline std::ostream& operator<<(std::ostream& out, const ForwardPolicyInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DialRecord__isset {
  _DialRecord__isset() : rid(false), ip(false), ttl(false), priority(false), enabled(false) {}
  bool rid :1;
  bool ip :1;
  bool ttl :1;
  bool priority :1;
  bool enabled :1;
} _DialRecord__isset;

class DialRecord {
 public:

  DialRecord(const DialRecord&);
  DialRecord& operator=(const DialRecord&);
  DialRecord() : rid(), ttl(0), priority(0), enabled(0) {
  }

  virtual ~DialRecord() throw();
  ObjectId rid;
  IpAddr ip;
  int32_t ttl;
  int32_t priority;
  bool enabled;

  _DialRecord__isset __isset;

  void __set_rid(const ObjectId& val);

  void __set_ip(const IpAddr& val);

  void __set_ttl(const int32_t val);

  void __set_priority(const int32_t val);

  void __set_enabled(const bool val);

  bool operator == (const DialRecord & rhs) const
  {
    if (!(rid == rhs.rid))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(ttl == rhs.ttl))
      return false;
    if (!(priority == rhs.priority))
      return false;
    if (!(enabled == rhs.enabled))
      return false;
    return true;
  }
  bool operator != (const DialRecord &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialRecord & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DialRecord &a, DialRecord &b);

inline std::ostream& operator<<(std::ostream& out, const DialRecord& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _HealthGroupInfo__isset {
  _HealthGroupInfo__isset() : zoneName(false), viewName(false), name(false) {}
  bool zoneName :1;
  bool viewName :1;
  bool name :1;
} _HealthGroupInfo__isset;

class HealthGroupInfo {
 public:

  HealthGroupInfo(const HealthGroupInfo&);
  HealthGroupInfo& operator=(const HealthGroupInfo&);
  HealthGroupInfo() : zoneName(), viewName(), name() {
  }

  virtual ~HealthGroupInfo() throw();
  std::string zoneName;
  std::string viewName;
  std::string name;

  _HealthGroupInfo__isset __isset;

  void __set_zoneName(const std::string& val);

  void __set_viewName(const std::string& val);

  void __set_name(const std::string& val);

  bool operator == (const HealthGroupInfo & rhs) const
  {
    if (!(zoneName == rhs.zoneName))
      return false;
    if (!(viewName == rhs.viewName))
      return false;
    if (!(name == rhs.name))
      return false;
    return true;
  }
  bool operator != (const HealthGroupInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HealthGroupInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HealthGroupInfo &a, HealthGroupInfo &b);

inline std::ostream& operator<<(std::ostream& out, const HealthGroupInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DialOption__isset {
  _DialOption__isset() : destUrl(false), testMethod(false), expectCode(false), expectMatch(false) {}
  bool destUrl :1;
  bool testMethod :1;
  bool expectCode :1;
  bool expectMatch :1;
} _DialOption__isset;

class DialOption {
 public:

  DialOption(const DialOption&);
  DialOption& operator=(const DialOption&);
  DialOption() : destUrl(), testMethod(), expectMatch() {
  }

  virtual ~DialOption() throw();
  std::string destUrl;
  std::string testMethod;
  std::vector<int32_t>  expectCode;
  std::string expectMatch;

  _DialOption__isset __isset;

  void __set_destUrl(const std::string& val);

  void __set_testMethod(const std::string& val);

  void __set_expectCode(const std::vector<int32_t> & val);

  void __set_expectMatch(const std::string& val);

  bool operator == (const DialOption & rhs) const
  {
    if (!(destUrl == rhs.destUrl))
      return false;
    if (!(testMethod == rhs.testMethod))
      return false;
    if (!(expectCode == rhs.expectCode))
      return false;
    if (!(expectMatch == rhs.expectMatch))
      return false;
    return true;
  }
  bool operator != (const DialOption &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialOption & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DialOption &a, DialOption &b);

inline std::ostream& operator<<(std::ostream& out, const DialOption& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _HealthPolicyInfo__isset {
  _HealthPolicyInfo__isset() : name(false), method(false), port(false), freq(false), times(false), passed(false), option(false) {}
  bool name :1;
  bool method :1;
  bool port :1;
  bool freq :1;
  bool times :1;
  bool passed :1;
  bool option :1;
} _HealthPolicyInfo__isset;

class HealthPolicyInfo {
 public:

  HealthPolicyInfo(const HealthPolicyInfo&);
  HealthPolicyInfo& operator=(const HealthPolicyInfo&);
  HealthPolicyInfo() : name(), method((DialMethod::type)0), port(0), freq(0), times(0), passed(0) {
  }

  virtual ~HealthPolicyInfo() throw();
  std::string name;
  DialMethod::type method;
  int16_t port;
  int32_t freq;
  int32_t times;
  int32_t passed;
  DialOption option;

  _HealthPolicyInfo__isset __isset;

  void __set_name(const std::string& val);

  void __set_method(const DialMethod::type val);

  void __set_port(const int16_t val);

  void __set_freq(const int32_t val);

  void __set_times(const int32_t val);

  void __set_passed(const int32_t val);

  void __set_option(const DialOption& val);

  bool operator == (const HealthPolicyInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(method == rhs.method))
      return false;
    if (__isset.port != rhs.__isset.port)
      return false;
    else if (__isset.port && !(port == rhs.port))
      return false;
    if (!(freq == rhs.freq))
      return false;
    if (!(times == rhs.times))
      return false;
    if (!(passed == rhs.passed))
      return false;
    if (!(option == rhs.option))
      return false;
    return true;
  }
  bool operator != (const HealthPolicyInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HealthPolicyInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HealthPolicyInfo &a, HealthPolicyInfo &b);

inline std::ostream& operator<<(std::ostream& out, const HealthPolicyInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _FilterReportInfo__isset {
  _FilterReportInfo__isset() : total(false), exceptIpLimit(false), exceptUdpLimit(false), exceptDnsLimit(false), ipLimit(false), domainLimit(false), aclLimit(false), userWhiteLimit(false), userBlackLimit(false), domainBlackLimit(false) {}
  bool total :1;
  bool exceptIpLimit :1;
  bool exceptUdpLimit :1;
  bool exceptDnsLimit :1;
  bool ipLimit :1;
  bool domainLimit :1;
  bool aclLimit :1;
  bool userWhiteLimit :1;
  bool userBlackLimit :1;
  bool domainBlackLimit :1;
} _FilterReportInfo__isset;

class FilterReportInfo {
 public:

  FilterReportInfo(const FilterReportInfo&);
  FilterReportInfo& operator=(const FilterReportInfo&);
  FilterReportInfo() : total(0), exceptIpLimit(0), exceptUdpLimit(0), exceptDnsLimit(0), ipLimit(0), domainLimit(0), aclLimit(0), userWhiteLimit(0), userBlackLimit(0), domainBlackLimit(0) {
  }

  virtual ~FilterReportInfo() throw();
  int32_t total;
  int32_t exceptIpLimit;
  int32_t exceptUdpLimit;
  int32_t exceptDnsLimit;
  int32_t ipLimit;
  int32_t domainLimit;
  int32_t aclLimit;
  int32_t userWhiteLimit;
  int32_t userBlackLimit;
  int32_t domainBlackLimit;

  _FilterReportInfo__isset __isset;

  void __set_total(const int32_t val);

  void __set_exceptIpLimit(const int32_t val);

  void __set_exceptUdpLimit(const int32_t val);

  void __set_exceptDnsLimit(const int32_t val);

  void __set_ipLimit(const int32_t val);

  void __set_domainLimit(const int32_t val);

  void __set_aclLimit(const int32_t val);

  void __set_userWhiteLimit(const int32_t val);

  void __set_userBlackLimit(const int32_t val);

  void __set_domainBlackLimit(const int32_t val);

  bool operator == (const FilterReportInfo & rhs) const
  {
    if (!(total == rhs.total))
      return false;
    if (!(exceptIpLimit == rhs.exceptIpLimit))
      return false;
    if (!(exceptUdpLimit == rhs.exceptUdpLimit))
      return false;
    if (!(exceptDnsLimit == rhs.exceptDnsLimit))
      return false;
    if (!(ipLimit == rhs.ipLimit))
      return false;
    if (!(domainLimit == rhs.domainLimit))
      return false;
    if (!(aclLimit == rhs.aclLimit))
      return false;
    if (!(userWhiteLimit == rhs.userWhiteLimit))
      return false;
    if (!(userBlackLimit == rhs.userBlackLimit))
      return false;
    if (!(domainBlackLimit == rhs.domainBlackLimit))
      return false;
    return true;
  }
  bool operator != (const FilterReportInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FilterReportInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FilterReportInfo &a, FilterReportInfo &b);

inline std::ostream& operator<<(std::ostream& out, const FilterReportInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RequestReportInfo__isset {
  _RequestReportInfo__isset() : total(false), a(false), aaaa(false), cname(false), ptr(false), txt(false), srv(false), naptr(false), mx(false), soa(false), ns(false), any(false) {}
  bool total :1;
  bool a :1;
  bool aaaa :1;
  bool cname :1;
  bool ptr :1;
  bool txt :1;
  bool srv :1;
  bool naptr :1;
  bool mx :1;
  bool soa :1;
  bool ns :1;
  bool any :1;
} _RequestReportInfo__isset;

class RequestReportInfo {
 public:

  RequestReportInfo(const RequestReportInfo&);
  RequestReportInfo& operator=(const RequestReportInfo&);
  RequestReportInfo() : total(0), a(0), aaaa(0), cname(0), ptr(0), txt(0), srv(0), naptr(0), mx(0), soa(0), ns(0), any(0) {
  }

  virtual ~RequestReportInfo() throw();
  int32_t total;
  int32_t a;
  int32_t aaaa;
  int32_t cname;
  int32_t ptr;
  int32_t txt;
  int32_t srv;
  int32_t naptr;
  int32_t mx;
  int32_t soa;
  int32_t ns;
  int32_t any;

  _RequestReportInfo__isset __isset;

  void __set_total(const int32_t val);

  void __set_a(const int32_t val);

  void __set_aaaa(const int32_t val);

  void __set_cname(const int32_t val);

  void __set_ptr(const int32_t val);

  void __set_txt(const int32_t val);

  void __set_srv(const int32_t val);

  void __set_naptr(const int32_t val);

  void __set_mx(const int32_t val);

  void __set_soa(const int32_t val);

  void __set_ns(const int32_t val);

  void __set_any(const int32_t val);

  bool operator == (const RequestReportInfo & rhs) const
  {
    if (!(total == rhs.total))
      return false;
    if (!(a == rhs.a))
      return false;
    if (!(aaaa == rhs.aaaa))
      return false;
    if (!(cname == rhs.cname))
      return false;
    if (!(ptr == rhs.ptr))
      return false;
    if (!(txt == rhs.txt))
      return false;
    if (!(srv == rhs.srv))
      return false;
    if (!(naptr == rhs.naptr))
      return false;
    if (!(mx == rhs.mx))
      return false;
    if (!(soa == rhs.soa))
      return false;
    if (!(ns == rhs.ns))
      return false;
    if (!(any == rhs.any))
      return false;
    return true;
  }
  bool operator != (const RequestReportInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RequestReportInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RequestReportInfo &a, RequestReportInfo &b);

inline std::ostream& operator<<(std::ostream& out, const RequestReportInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _GeneralReportInfo__isset {
  _GeneralReportInfo__isset() : total(false), noerr(false), servfail(false), nxdomain(false), refuse(false), formerr(false) {}
  bool total :1;
  bool noerr :1;
  bool servfail :1;
  bool nxdomain :1;
  bool refuse :1;
  bool formerr :1;
} _GeneralReportInfo__isset;

class GeneralReportInfo {
 public:

  GeneralReportInfo(const GeneralReportInfo&);
  GeneralReportInfo& operator=(const GeneralReportInfo&);
  GeneralReportInfo() : total(0), noerr(0), servfail(0), nxdomain(0), refuse(0), formerr(0) {
  }

  virtual ~GeneralReportInfo() throw();
  int32_t total;
  int32_t noerr;
  int32_t servfail;
  int32_t nxdomain;
  int32_t refuse;
  int32_t formerr;

  _GeneralReportInfo__isset __isset;

  void __set_total(const int32_t val);

  void __set_noerr(const int32_t val);

  void __set_servfail(const int32_t val);

  void __set_nxdomain(const int32_t val);

  void __set_refuse(const int32_t val);

  void __set_formerr(const int32_t val);

  bool operator == (const GeneralReportInfo & rhs) const
  {
    if (!(total == rhs.total))
      return false;
    if (!(noerr == rhs.noerr))
      return false;
    if (!(servfail == rhs.servfail))
      return false;
    if (!(nxdomain == rhs.nxdomain))
      return false;
    if (!(refuse == rhs.refuse))
      return false;
    if (!(formerr == rhs.formerr))
      return false;
    return true;
  }
  bool operator != (const GeneralReportInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const GeneralReportInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(GeneralReportInfo &a, GeneralReportInfo &b);

inline std::ostream& operator<<(std::ostream& out, const GeneralReportInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DNameAccessInfo__isset {
  _DNameAccessInfo__isset() : zoneName(false), viewName(false), domain(false), access(false), rcode(false), qtype(false) {}
  bool zoneName :1;
  bool viewName :1;
  bool domain :1;
  bool access :1;
  bool rcode :1;
  bool qtype :1;
} _DNameAccessInfo__isset;

class DNameAccessInfo {
 public:

  DNameAccessInfo(const DNameAccessInfo&);
  DNameAccessInfo& operator=(const DNameAccessInfo&);
  DNameAccessInfo() : zoneName(), viewName(), domain(), access(0) {
  }

  virtual ~DNameAccessInfo() throw();
  std::string zoneName;
  std::string viewName;
  std::string domain;
  int32_t access;
  GeneralReportInfo rcode;
  RequestReportInfo qtype;

  _DNameAccessInfo__isset __isset;

  void __set_zoneName(const std::string& val);

  void __set_viewName(const std::string& val);

  void __set_domain(const std::string& val);

  void __set_access(const int32_t val);

  void __set_rcode(const GeneralReportInfo& val);

  void __set_qtype(const RequestReportInfo& val);

  bool operator == (const DNameAccessInfo & rhs) const
  {
    if (!(zoneName == rhs.zoneName))
      return false;
    if (!(viewName == rhs.viewName))
      return false;
    if (!(domain == rhs.domain))
      return false;
    if (!(access == rhs.access))
      return false;
    if (!(rcode == rhs.rcode))
      return false;
    if (!(qtype == rhs.qtype))
      return false;
    return true;
  }
  bool operator != (const DNameAccessInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DNameAccessInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DNameAccessInfo &a, DNameAccessInfo &b);

inline std::ostream& operator<<(std::ostream& out, const DNameAccessInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _XProxyReportInfo__isset {
  _XProxyReportInfo__isset() : total(false), proxyRequest(false), proxyAnswer(false), proxyForwardRequest(false), proxyForwardAnswer(false) {}
  bool total :1;
  bool proxyRequest :1;
  bool proxyAnswer :1;
  bool proxyForwardRequest :1;
  bool proxyForwardAnswer :1;
} _XProxyReportInfo__isset;

class XProxyReportInfo {
 public:

  XProxyReportInfo(const XProxyReportInfo&);
  XProxyReportInfo& operator=(const XProxyReportInfo&);
  XProxyReportInfo() : total(0), proxyRequest(0), proxyAnswer(0), proxyForwardRequest(0), proxyForwardAnswer(0) {
  }

  virtual ~XProxyReportInfo() throw();
  int32_t total;
  int32_t proxyRequest;
  int32_t proxyAnswer;
  int32_t proxyForwardRequest;
  int32_t proxyForwardAnswer;

  _XProxyReportInfo__isset __isset;

  void __set_total(const int32_t val);

  void __set_proxyRequest(const int32_t val);

  void __set_proxyAnswer(const int32_t val);

  void __set_proxyForwardRequest(const int32_t val);

  void __set_proxyForwardAnswer(const int32_t val);

  bool operator == (const XProxyReportInfo & rhs) const
  {
    if (!(total == rhs.total))
      return false;
    if (!(proxyRequest == rhs.proxyRequest))
      return false;
    if (!(proxyAnswer == rhs.proxyAnswer))
      return false;
    if (!(proxyForwardRequest == rhs.proxyForwardRequest))
      return false;
    if (!(proxyForwardAnswer == rhs.proxyForwardAnswer))
      return false;
    return true;
  }
  bool operator != (const XProxyReportInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XProxyReportInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(XProxyReportInfo &a, XProxyReportInfo &b);

inline std::ostream& operator<<(std::ostream& out, const XProxyReportInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _XForwardReportInfo__isset {
  _XForwardReportInfo__isset() : total(false), xforwardRequest(false), xforwardAnswer(false) {}
  bool total :1;
  bool xforwardRequest :1;
  bool xforwardAnswer :1;
} _XForwardReportInfo__isset;

class XForwardReportInfo {
 public:

  XForwardReportInfo(const XForwardReportInfo&);
  XForwardReportInfo& operator=(const XForwardReportInfo&);
  XForwardReportInfo() : total(0), xforwardRequest(0), xforwardAnswer(0) {
  }

  virtual ~XForwardReportInfo() throw();
  int32_t total;
  int32_t xforwardRequest;
  int32_t xforwardAnswer;

  _XForwardReportInfo__isset __isset;

  void __set_total(const int32_t val);

  void __set_xforwardRequest(const int32_t val);

  void __set_xforwardAnswer(const int32_t val);

  bool operator == (const XForwardReportInfo & rhs) const
  {
    if (!(total == rhs.total))
      return false;
    if (!(xforwardRequest == rhs.xforwardRequest))
      return false;
    if (!(xforwardAnswer == rhs.xforwardAnswer))
      return false;
    return true;
  }
  bool operator != (const XForwardReportInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XForwardReportInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(XForwardReportInfo &a, XForwardReportInfo &b);

inline std::ostream& operator<<(std::ostream& out, const XForwardReportInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RecursiveReportInfo__isset {
  _RecursiveReportInfo__isset() : total(false), recursiveRequest(false), recursiveAnswer(false) {}
  bool total :1;
  bool recursiveRequest :1;
  bool recursiveAnswer :1;
} _RecursiveReportInfo__isset;

class RecursiveReportInfo {
 public:

  RecursiveReportInfo(const RecursiveReportInfo&);
  RecursiveReportInfo& operator=(const RecursiveReportInfo&);
  RecursiveReportInfo() : total(0), recursiveRequest(0), recursiveAnswer(0) {
  }

  virtual ~RecursiveReportInfo() throw();
  int32_t total;
  int32_t recursiveRequest;
  int32_t recursiveAnswer;

  _RecursiveReportInfo__isset __isset;

  void __set_total(const int32_t val);

  void __set_recursiveRequest(const int32_t val);

  void __set_recursiveAnswer(const int32_t val);

  bool operator == (const RecursiveReportInfo & rhs) const
  {
    if (!(total == rhs.total))
      return false;
    if (!(recursiveRequest == rhs.recursiveRequest))
      return false;
    if (!(recursiveAnswer == rhs.recursiveAnswer))
      return false;
    return true;
  }
  bool operator != (const RecursiveReportInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RecursiveReportInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RecursiveReportInfo &a, RecursiveReportInfo &b);

inline std::ostream& operator<<(std::ostream& out, const RecursiveReportInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _BackGroundReportInfo__isset {
  _BackGroundReportInfo__isset() : total(false), smartUpdate(false), cacheUpdate(false), limitDrop(false), ttlExpire(false) {}
  bool total :1;
  bool smartUpdate :1;
  bool cacheUpdate :1;
  bool limitDrop :1;
  bool ttlExpire :1;
} _BackGroundReportInfo__isset;

class BackGroundReportInfo {
 public:

  BackGroundReportInfo(const BackGroundReportInfo&);
  BackGroundReportInfo& operator=(const BackGroundReportInfo&);
  BackGroundReportInfo() : total(0), smartUpdate(0), cacheUpdate(0), limitDrop(0), ttlExpire(0) {
  }

  virtual ~BackGroundReportInfo() throw();
  int32_t total;
  int32_t smartUpdate;
  int32_t cacheUpdate;
  int32_t limitDrop;
  int32_t ttlExpire;

  _BackGroundReportInfo__isset __isset;

  void __set_total(const int32_t val);

  void __set_smartUpdate(const int32_t val);

  void __set_cacheUpdate(const int32_t val);

  void __set_limitDrop(const int32_t val);

  void __set_ttlExpire(const int32_t val);

  bool operator == (const BackGroundReportInfo & rhs) const
  {
    if (!(total == rhs.total))
      return false;
    if (!(smartUpdate == rhs.smartUpdate))
      return false;
    if (!(cacheUpdate == rhs.cacheUpdate))
      return false;
    if (!(limitDrop == rhs.limitDrop))
      return false;
    if (!(ttlExpire == rhs.ttlExpire))
      return false;
    return true;
  }
  bool operator != (const BackGroundReportInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const BackGroundReportInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(BackGroundReportInfo &a, BackGroundReportInfo &b);

inline std::ostream& operator<<(std::ostream& out, const BackGroundReportInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TopnIpInfo__isset {
  _TopnIpInfo__isset() : ip(false), access(false) {}
  bool ip :1;
  bool access :1;
} _TopnIpInfo__isset;

class TopnIpInfo {
 public:

  TopnIpInfo(const TopnIpInfo&);
  TopnIpInfo& operator=(const TopnIpInfo&);
  TopnIpInfo() : ip(), access(0) {
  }

  virtual ~TopnIpInfo() throw();
  std::string ip;
  int32_t access;

  _TopnIpInfo__isset __isset;

  void __set_ip(const std::string& val);

  void __set_access(const int32_t val);

  bool operator == (const TopnIpInfo & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(access == rhs.access))
      return false;
    return true;
  }
  bool operator != (const TopnIpInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TopnIpInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TopnIpInfo &a, TopnIpInfo &b);

inline std::ostream& operator<<(std::ostream& out, const TopnIpInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TopnDomainInfo__isset {
  _TopnDomainInfo__isset() : domain(false), access(false) {}
  bool domain :1;
  bool access :1;
} _TopnDomainInfo__isset;

class TopnDomainInfo {
 public:

  TopnDomainInfo(const TopnDomainInfo&);
  TopnDomainInfo& operator=(const TopnDomainInfo&);
  TopnDomainInfo() : domain(), access(0) {
  }

  virtual ~TopnDomainInfo() throw();
  std::string domain;
  int32_t access;

  _TopnDomainInfo__isset __isset;

  void __set_domain(const std::string& val);

  void __set_access(const int32_t val);

  bool operator == (const TopnDomainInfo & rhs) const
  {
    if (!(domain == rhs.domain))
      return false;
    if (!(access == rhs.access))
      return false;
    return true;
  }
  bool operator != (const TopnDomainInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TopnDomainInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TopnDomainInfo &a, TopnDomainInfo &b);

inline std::ostream& operator<<(std::ostream& out, const TopnDomainInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _TopnDnameInfo__isset {
  _TopnDnameInfo__isset() : dname(false), access(false) {}
  bool dname :1;
  bool access :1;
} _TopnDnameInfo__isset;

class TopnDnameInfo {
 public:

  TopnDnameInfo(const TopnDnameInfo&);
  TopnDnameInfo& operator=(const TopnDnameInfo&);
  TopnDnameInfo() : dname(), access(0) {
  }

  virtual ~TopnDnameInfo() throw();
  std::string dname;
  int32_t access;

  _TopnDnameInfo__isset __isset;

  void __set_dname(const std::string& val);

  void __set_access(const int32_t val);

  bool operator == (const TopnDnameInfo & rhs) const
  {
    if (!(dname == rhs.dname))
      return false;
    if (!(access == rhs.access))
      return false;
    return true;
  }
  bool operator != (const TopnDnameInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const TopnDnameInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(TopnDnameInfo &a, TopnDnameInfo &b);

inline std::ostream& operator<<(std::ostream& out, const TopnDnameInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DDosInfo__isset {
  _DDosInfo__isset() : ip(false), domain(false), access(false) {}
  bool ip :1;
  bool domain :1;
  bool access :1;
} _DDosInfo__isset;

class DDosInfo {
 public:

  DDosInfo(const DDosInfo&);
  DDosInfo& operator=(const DDosInfo&);
  DDosInfo() : ip(), domain(), access(0) {
  }

  virtual ~DDosInfo() throw();
  std::string ip;
  std::string domain;
  int32_t access;

  _DDosInfo__isset __isset;

  void __set_ip(const std::string& val);

  void __set_domain(const std::string& val);

  void __set_access(const int32_t val);

  bool operator == (const DDosInfo & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(domain == rhs.domain))
      return false;
    if (!(access == rhs.access))
      return false;
    return true;
  }
  bool operator != (const DDosInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DDosInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DDosInfo &a, DDosInfo &b);

inline std::ostream& operator<<(std::ostream& out, const DDosInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _HostInfo__isset {
  _HostInfo__isset() : cpu(false), memory(false), nicin(false), nicout(false) {}
  bool cpu :1;
  bool memory :1;
  bool nicin :1;
  bool nicout :1;
} _HostInfo__isset;

class HostInfo {
 public:

  HostInfo(const HostInfo&);
  HostInfo& operator=(const HostInfo&);
  HostInfo() : cpu(0), memory(0), nicin(0), nicout(0) {
  }

  virtual ~HostInfo() throw();
  int32_t cpu;
  int32_t memory;
  int32_t nicin;
  int32_t nicout;

  _HostInfo__isset __isset;

  void __set_cpu(const int32_t val);

  void __set_memory(const int32_t val);

  void __set_nicin(const int32_t val);

  void __set_nicout(const int32_t val);

  bool operator == (const HostInfo & rhs) const
  {
    if (!(cpu == rhs.cpu))
      return false;
    if (!(memory == rhs.memory))
      return false;
    if (!(nicin == rhs.nicin))
      return false;
    if (!(nicout == rhs.nicout))
      return false;
    return true;
  }
  bool operator != (const HostInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HostInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HostInfo &a, HostInfo &b);

inline std::ostream& operator<<(std::ostream& out, const HostInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _HeartBeatState__isset {
  _HeartBeatState__isset() : mState(false), serverState(false) {}
  bool mState :1;
  bool serverState :1;
} _HeartBeatState__isset;

class HeartBeatState {
 public:

  HeartBeatState(const HeartBeatState&);
  HeartBeatState& operator=(const HeartBeatState&);
  HeartBeatState() : mState((ModuleState::type)0), serverState(0) {
  }

  virtual ~HeartBeatState() throw();
  ModuleState::type mState;
  bool serverState;

  _HeartBeatState__isset __isset;

  void __set_mState(const ModuleState::type val);

  void __set_serverState(const bool val);

  bool operator == (const HeartBeatState & rhs) const
  {
    if (!(mState == rhs.mState))
      return false;
    if (!(serverState == rhs.serverState))
      return false;
    return true;
  }
  bool operator != (const HeartBeatState &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const HeartBeatState & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(HeartBeatState &a, HeartBeatState &b);

inline std::ostream& operator<<(std::ostream& out, const HeartBeatState& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _IpOverAlarm__isset {
  _IpOverAlarm__isset() : ip(false), qps(false), status(false) {}
  bool ip :1;
  bool qps :1;
  bool status :1;
} _IpOverAlarm__isset;

class IpOverAlarm {
 public:

  IpOverAlarm(const IpOverAlarm&);
  IpOverAlarm& operator=(const IpOverAlarm&);
  IpOverAlarm() : qps(0), status((AlarmStatus::type)0) {
  }

  virtual ~IpOverAlarm() throw();
  IpAddr ip;
  int32_t qps;
  AlarmStatus::type status;

  _IpOverAlarm__isset __isset;

  void __set_ip(const IpAddr& val);

  void __set_qps(const int32_t val);

  void __set_status(const AlarmStatus::type val);

  bool operator == (const IpOverAlarm & rhs) const
  {
    if (!(ip == rhs.ip))
      return false;
    if (!(qps == rhs.qps))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const IpOverAlarm &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IpOverAlarm & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IpOverAlarm &a, IpOverAlarm &b);

inline std::ostream& operator<<(std::ostream& out, const IpOverAlarm& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DomainOverAlarm__isset {
  _DomainOverAlarm__isset() : domain(false), qps(false), status(false) {}
  bool domain :1;
  bool qps :1;
  bool status :1;
} _DomainOverAlarm__isset;

class DomainOverAlarm {
 public:

  DomainOverAlarm(const DomainOverAlarm&);
  DomainOverAlarm& operator=(const DomainOverAlarm&);
  DomainOverAlarm() : domain(), qps(0), status((AlarmStatus::type)0) {
  }

  virtual ~DomainOverAlarm() throw();
  std::string domain;
  int32_t qps;
  AlarmStatus::type status;

  _DomainOverAlarm__isset __isset;

  void __set_domain(const std::string& val);

  void __set_qps(const int32_t val);

  void __set_status(const AlarmStatus::type val);

  bool operator == (const DomainOverAlarm & rhs) const
  {
    if (!(domain == rhs.domain))
      return false;
    if (!(qps == rhs.qps))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const DomainOverAlarm &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DomainOverAlarm & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DomainOverAlarm &a, DomainOverAlarm &b);

inline std::ostream& operator<<(std::ostream& out, const DomainOverAlarm& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NginxServerAlarm__isset {
  _NginxServerAlarm__isset() : serverName(false), localUrl(false), status(false) {}
  bool serverName :1;
  bool localUrl :1;
  bool status :1;
} _NginxServerAlarm__isset;

class NginxServerAlarm {
 public:

  NginxServerAlarm(const NginxServerAlarm&);
  NginxServerAlarm& operator=(const NginxServerAlarm&);
  NginxServerAlarm() : serverName(), localUrl(), status((AlarmStatus::type)0) {
  }

  virtual ~NginxServerAlarm() throw();
  std::string serverName;
  std::string localUrl;
  AlarmStatus::type status;

  _NginxServerAlarm__isset __isset;

  void __set_serverName(const std::string& val);

  void __set_localUrl(const std::string& val);

  void __set_status(const AlarmStatus::type val);

  bool operator == (const NginxServerAlarm & rhs) const
  {
    if (!(serverName == rhs.serverName))
      return false;
    if (!(localUrl == rhs.localUrl))
      return false;
    if (!(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const NginxServerAlarm &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NginxServerAlarm & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NginxServerAlarm &a, NginxServerAlarm &b);

inline std::ostream& operator<<(std::ostream& out, const NginxServerAlarm& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ZoneRequestReport__isset {
  _ZoneRequestReport__isset() : zoneName(false), viewName(false), data(false) {}
  bool zoneName :1;
  bool viewName :1;
  bool data :1;
} _ZoneRequestReport__isset;

class ZoneRequestReport {
 public:

  ZoneRequestReport(const ZoneRequestReport&);
  ZoneRequestReport& operator=(const ZoneRequestReport&);
  ZoneRequestReport() : zoneName(), viewName() {
  }

  virtual ~ZoneRequestReport() throw();
  std::string zoneName;
  std::string viewName;
  RequestReportInfo data;

  _ZoneRequestReport__isset __isset;

  void __set_zoneName(const std::string& val);

  void __set_viewName(const std::string& val);

  void __set_data(const RequestReportInfo& val);

  bool operator == (const ZoneRequestReport & rhs) const
  {
    if (!(zoneName == rhs.zoneName))
      return false;
    if (!(viewName == rhs.viewName))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const ZoneRequestReport &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ZoneRequestReport & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ZoneRequestReport &a, ZoneRequestReport &b);

inline std::ostream& operator<<(std::ostream& out, const ZoneRequestReport& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ZoneAnswerReport__isset {
  _ZoneAnswerReport__isset() : zoneName(false), viewName(false), data(false), qtype(false) {}
  bool zoneName :1;
  bool viewName :1;
  bool data :1;
  bool qtype :1;
} _ZoneAnswerReport__isset;

class ZoneAnswerReport {
 public:

  ZoneAnswerReport(const ZoneAnswerReport&);
  ZoneAnswerReport& operator=(const ZoneAnswerReport&);
  ZoneAnswerReport() : zoneName(), viewName() {
  }

  virtual ~ZoneAnswerReport() throw();
  std::string zoneName;
  std::string viewName;
  GeneralReportInfo data;
  RequestReportInfo qtype;

  _ZoneAnswerReport__isset __isset;

  void __set_zoneName(const std::string& val);

  void __set_viewName(const std::string& val);

  void __set_data(const GeneralReportInfo& val);

  void __set_qtype(const RequestReportInfo& val);

  bool operator == (const ZoneAnswerReport & rhs) const
  {
    if (!(zoneName == rhs.zoneName))
      return false;
    if (!(viewName == rhs.viewName))
      return false;
    if (!(data == rhs.data))
      return false;
    if (!(qtype == rhs.qtype))
      return false;
    return true;
  }
  bool operator != (const ZoneAnswerReport &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ZoneAnswerReport & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ZoneAnswerReport &a, ZoneAnswerReport &b);

inline std::ostream& operator<<(std::ostream& out, const ZoneAnswerReport& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _XproxyReport__isset {
  _XproxyReport__isset() : xproxy(false), data(false) {}
  bool xproxy :1;
  bool data :1;
} _XproxyReport__isset;

class XproxyReport {
 public:

  XproxyReport(const XproxyReport&);
  XproxyReport& operator=(const XproxyReport&);
  XproxyReport() : xproxy() {
  }

  virtual ~XproxyReport() throw();
  std::string xproxy;
  XProxyReportInfo data;

  _XproxyReport__isset __isset;

  void __set_xproxy(const std::string& val);

  void __set_data(const XProxyReportInfo& val);

  bool operator == (const XproxyReport & rhs) const
  {
    if (!(xproxy == rhs.xproxy))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const XproxyReport &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XproxyReport & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(XproxyReport &a, XproxyReport &b);

inline std::ostream& operator<<(std::ostream& out, const XproxyReport& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _XforwardReport__isset {
  _XforwardReport__isset() : xforward(false), data(false) {}
  bool xforward :1;
  bool data :1;
} _XforwardReport__isset;

class XforwardReport {
 public:

  XforwardReport(const XforwardReport&);
  XforwardReport& operator=(const XforwardReport&);
  XforwardReport() : xforward() {
  }

  virtual ~XforwardReport() throw();
  std::string xforward;
  XForwardReportInfo data;

  _XforwardReport__isset __isset;

  void __set_xforward(const std::string& val);

  void __set_data(const XForwardReportInfo& val);

  bool operator == (const XforwardReport & rhs) const
  {
    if (!(xforward == rhs.xforward))
      return false;
    if (!(data == rhs.data))
      return false;
    return true;
  }
  bool operator != (const XforwardReport &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const XforwardReport & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(XforwardReport &a, XforwardReport &b);

inline std::ostream& operator<<(std::ostream& out, const XforwardReport& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RedirectServerInfo__isset {
  _RedirectServerInfo__isset() : viewName(false), ip(false), weight(false), status(false) {}
  bool viewName :1;
  bool ip :1;
  bool weight :1;
  bool status :1;
} _RedirectServerInfo__isset;

class RedirectServerInfo {
 public:

  RedirectServerInfo(const RedirectServerInfo&);
  RedirectServerInfo& operator=(const RedirectServerInfo&);
  RedirectServerInfo() : viewName(), weight(0), status((Status::type)0) {
  }

  virtual ~RedirectServerInfo() throw();
  std::string viewName;
  IpAddr ip;
  int32_t weight;
  Status::type status;

  _RedirectServerInfo__isset __isset;

  void __set_viewName(const std::string& val);

  void __set_ip(const IpAddr& val);

  void __set_weight(const int32_t val);

  void __set_status(const Status::type val);

  bool operator == (const RedirectServerInfo & rhs) const
  {
    if (!(viewName == rhs.viewName))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (__isset.weight != rhs.__isset.weight)
      return false;
    else if (__isset.weight && !(weight == rhs.weight))
      return false;
    if (__isset.status != rhs.__isset.status)
      return false;
    else if (__isset.status && !(status == rhs.status))
      return false;
    return true;
  }
  bool operator != (const RedirectServerInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RedirectServerInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RedirectServerInfo &a, RedirectServerInfo &b);

inline std::ostream& operator<<(std::ostream& out, const RedirectServerInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _NginxProxyInfo__isset {
  _NginxProxyInfo__isset() : proxyDomain(false), proxyPort(false), targetIpAddr(false), targetURL(false), protocol(false) {}
  bool proxyDomain :1;
  bool proxyPort :1;
  bool targetIpAddr :1;
  bool targetURL :1;
  bool protocol :1;
} _NginxProxyInfo__isset;

class NginxProxyInfo {
 public:

  NginxProxyInfo(const NginxProxyInfo&);
  NginxProxyInfo& operator=(const NginxProxyInfo&);
  NginxProxyInfo() : proxyDomain(), proxyPort(0), targetIpAddr(), targetURL(), protocol() {
  }

  virtual ~NginxProxyInfo() throw();
  std::string proxyDomain;
  int32_t proxyPort;
  std::string targetIpAddr;
  std::string targetURL;
  std::string protocol;

  _NginxProxyInfo__isset __isset;

  void __set_proxyDomain(const std::string& val);

  void __set_proxyPort(const int32_t val);

  void __set_targetIpAddr(const std::string& val);

  void __set_targetURL(const std::string& val);

  void __set_protocol(const std::string& val);

  bool operator == (const NginxProxyInfo & rhs) const
  {
    if (!(proxyDomain == rhs.proxyDomain))
      return false;
    if (!(proxyPort == rhs.proxyPort))
      return false;
    if (!(targetIpAddr == rhs.targetIpAddr))
      return false;
    if (!(targetURL == rhs.targetURL))
      return false;
    if (!(protocol == rhs.protocol))
      return false;
    return true;
  }
  bool operator != (const NginxProxyInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const NginxProxyInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(NginxProxyInfo &a, NginxProxyInfo &b);

inline std::ostream& operator<<(std::ostream& out, const NginxProxyInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _CateWeight__isset {
  _CateWeight__isset() : cate(false), weight(false) {}
  bool cate :1;
  bool weight :1;
} _CateWeight__isset;

class CateWeight {
 public:

  CateWeight(const CateWeight&);
  CateWeight& operator=(const CateWeight&);
  CateWeight() : cate(0), weight(0) {
  }

  virtual ~CateWeight() throw();
  int32_t cate;
  int32_t weight;

  _CateWeight__isset __isset;

  void __set_cate(const int32_t val);

  void __set_weight(const int32_t val);

  bool operator == (const CateWeight & rhs) const
  {
    if (!(cate == rhs.cate))
      return false;
    if (!(weight == rhs.weight))
      return false;
    return true;
  }
  bool operator != (const CateWeight &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const CateWeight & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(CateWeight &a, CateWeight &b);

inline std::ostream& operator<<(std::ostream& out, const CateWeight& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DialHealthResult__isset {
  _DialHealthResult__isset() : groupName(false), policyName(false), statusList(false) {}
  bool groupName :1;
  bool policyName :1;
  bool statusList :1;
} _DialHealthResult__isset;

class DialHealthResult {
 public:

  DialHealthResult(const DialHealthResult&);
  DialHealthResult& operator=(const DialHealthResult&);
  DialHealthResult() : groupName(), policyName() {
  }

  virtual ~DialHealthResult() throw();
  std::string groupName;
  std::string policyName;
  std::vector<DialRecordStatus>  statusList;

  _DialHealthResult__isset __isset;

  void __set_groupName(const std::string& val);

  void __set_policyName(const std::string& val);

  void __set_statusList(const std::vector<DialRecordStatus> & val);

  bool operator == (const DialHealthResult & rhs) const
  {
    if (!(groupName == rhs.groupName))
      return false;
    if (!(policyName == rhs.policyName))
      return false;
    if (!(statusList == rhs.statusList))
      return false;
    return true;
  }
  bool operator != (const DialHealthResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialHealthResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DialHealthResult &a, DialHealthResult &b);

inline std::ostream& operator<<(std::ostream& out, const DialHealthResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DialServerResult__isset {
  _DialServerResult__isset() : status(false), typ(false) {}
  bool status :1;
  bool typ :1;
} _DialServerResult__isset;

class DialServerResult {
 public:

  DialServerResult(const DialServerResult&);
  DialServerResult& operator=(const DialServerResult&);
  DialServerResult() : typ((DialServerType::type)0) {
  }

  virtual ~DialServerResult() throw();
  DialServerStatus status;
  DialServerType::type typ;

  _DialServerResult__isset __isset;

  void __set_status(const DialServerStatus& val);

  void __set_typ(const DialServerType::type val);

  bool operator == (const DialServerResult & rhs) const
  {
    if (!(status == rhs.status))
      return false;
    if (!(typ == rhs.typ))
      return false;
    return true;
  }
  bool operator != (const DialServerResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialServerResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DialServerResult &a, DialServerResult &b);

inline std::ostream& operator<<(std::ostream& out, const DialServerResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _DialNginxResult__isset {
  _DialNginxResult__isset() : groupName(false), policyName(false), statusList(false) {}
  bool groupName :1;
  bool policyName :1;
  bool statusList :1;
} _DialNginxResult__isset;

class DialNginxResult {
 public:

  DialNginxResult(const DialNginxResult&);
  DialNginxResult& operator=(const DialNginxResult&);
  DialNginxResult() : groupName(), policyName() {
  }

  virtual ~DialNginxResult() throw();
  std::string groupName;
  std::string policyName;
  std::vector<DialNginxStatus>  statusList;

  _DialNginxResult__isset __isset;

  void __set_groupName(const std::string& val);

  void __set_policyName(const std::string& val);

  void __set_statusList(const std::vector<DialNginxStatus> & val);

  bool operator == (const DialNginxResult & rhs) const
  {
    if (!(groupName == rhs.groupName))
      return false;
    if (!(policyName == rhs.policyName))
      return false;
    if (!(statusList == rhs.statusList))
      return false;
    return true;
  }
  bool operator != (const DialNginxResult &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const DialNginxResult & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(DialNginxResult &a, DialNginxResult &b);

inline std::ostream& operator<<(std::ostream& out, const DialNginxResult& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SnmpGroupInfo__isset {
  _SnmpGroupInfo__isset() : enable(false), name(false), community(false), user(false), passwd(false), version(false), interval(false), port(false), ip(false) {}
  bool enable :1;
  bool name :1;
  bool community :1;
  bool user :1;
  bool passwd :1;
  bool version :1;
  bool interval :1;
  bool port :1;
  bool ip :1;
} _SnmpGroupInfo__isset;

class SnmpGroupInfo {
 public:

  SnmpGroupInfo(const SnmpGroupInfo&);
  SnmpGroupInfo& operator=(const SnmpGroupInfo&);
  SnmpGroupInfo() : enable(0), name(), community(), user(), passwd(), version(0), interval(0), port(0) {
  }

  virtual ~SnmpGroupInfo() throw();
  bool enable;
  std::string name;
  std::string community;
  std::string user;
  std::string passwd;
  int32_t version;
  int32_t interval;
  int32_t port;
  IpAddr ip;

  _SnmpGroupInfo__isset __isset;

  void __set_enable(const bool val);

  void __set_name(const std::string& val);

  void __set_community(const std::string& val);

  void __set_user(const std::string& val);

  void __set_passwd(const std::string& val);

  void __set_version(const int32_t val);

  void __set_interval(const int32_t val);

  void __set_port(const int32_t val);

  void __set_ip(const IpAddr& val);

  bool operator == (const SnmpGroupInfo & rhs) const
  {
    if (!(enable == rhs.enable))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(community == rhs.community))
      return false;
    if (!(user == rhs.user))
      return false;
    if (!(passwd == rhs.passwd))
      return false;
    if (!(version == rhs.version))
      return false;
    if (!(interval == rhs.interval))
      return false;
    if (!(port == rhs.port))
      return false;
    if (!(ip == rhs.ip))
      return false;
    return true;
  }
  bool operator != (const SnmpGroupInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SnmpGroupInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SnmpGroupInfo &a, SnmpGroupInfo &b);

inline std::ostream& operator<<(std::ostream& out, const SnmpGroupInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _InterfaceTraffic__isset {
  _InterfaceTraffic__isset() : index(false), inoctets(false), outoctets(false) {}
  bool index :1;
  bool inoctets :1;
  bool outoctets :1;
} _InterfaceTraffic__isset;

class InterfaceTraffic {
 public:

  InterfaceTraffic(const InterfaceTraffic&);
  InterfaceTraffic& operator=(const InterfaceTraffic&);
  InterfaceTraffic() : index(0), inoctets(0), outoctets(0) {
  }

  virtual ~InterfaceTraffic() throw();
  int32_t index;
  int64_t inoctets;
  int64_t outoctets;

  _InterfaceTraffic__isset __isset;

  void __set_index(const int32_t val);

  void __set_inoctets(const int64_t val);

  void __set_outoctets(const int64_t val);

  bool operator == (const InterfaceTraffic & rhs) const
  {
    if (!(index == rhs.index))
      return false;
    if (!(inoctets == rhs.inoctets))
      return false;
    if (!(outoctets == rhs.outoctets))
      return false;
    return true;
  }
  bool operator != (const InterfaceTraffic &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InterfaceTraffic & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(InterfaceTraffic &a, InterfaceTraffic &b);

inline std::ostream& operator<<(std::ostream& out, const InterfaceTraffic& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _IpMac__isset {
  _IpMac__isset() : index(false), ip(false), physaddress(false) {}
  bool index :1;
  bool ip :1;
  bool physaddress :1;
} _IpMac__isset;

class IpMac {
 public:

  IpMac(const IpMac&);
  IpMac& operator=(const IpMac&);
  IpMac() : index(0), physaddress() {
  }

  virtual ~IpMac() throw();
  int32_t index;
  IpAddr ip;
  std::string physaddress;

  _IpMac__isset __isset;

  void __set_index(const int32_t val);

  void __set_ip(const IpAddr& val);

  void __set_physaddress(const std::string& val);

  bool operator == (const IpMac & rhs) const
  {
    if (!(index == rhs.index))
      return false;
    if (!(ip == rhs.ip))
      return false;
    if (!(physaddress == rhs.physaddress))
      return false;
    return true;
  }
  bool operator != (const IpMac &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const IpMac & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(IpMac &a, IpMac &b);

inline std::ostream& operator<<(std::ostream& out, const IpMac& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _InterfaceInfo__isset {
  _InterfaceInfo__isset() : index(false), descr(false), type(false), status(false), speed(false), mtu(false), physaddress(false) {}
  bool index :1;
  bool descr :1;
  bool type :1;
  bool status :1;
  bool speed :1;
  bool mtu :1;
  bool physaddress :1;
} _InterfaceInfo__isset;

class InterfaceInfo {
 public:

  InterfaceInfo(const InterfaceInfo&);
  InterfaceInfo& operator=(const InterfaceInfo&);
  InterfaceInfo() : index(0), descr(), type(0), status(0), speed(0), mtu(0), physaddress() {
  }

  virtual ~InterfaceInfo() throw();
  int32_t index;
  std::string descr;
  int32_t type;
  int32_t status;
  int64_t speed;
  int32_t mtu;
  std::string physaddress;

  _InterfaceInfo__isset __isset;

  void __set_index(const int32_t val);

  void __set_descr(const std::string& val);

  void __set_type(const int32_t val);

  void __set_status(const int32_t val);

  void __set_speed(const int64_t val);

  void __set_mtu(const int32_t val);

  void __set_physaddress(const std::string& val);

  bool operator == (const InterfaceInfo & rhs) const
  {
    if (!(index == rhs.index))
      return false;
    if (!(descr == rhs.descr))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(status == rhs.status))
      return false;
    if (!(speed == rhs.speed))
      return false;
    if (!(mtu == rhs.mtu))
      return false;
    if (!(physaddress == rhs.physaddress))
      return false;
    return true;
  }
  bool operator != (const InterfaceInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const InterfaceInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(InterfaceInfo &a, InterfaceInfo &b);

inline std::ostream& operator<<(std::ostream& out, const InterfaceInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _RouteInfo__isset {
  _RouteInfo__isset() : ifindex(false), destination(false), gateway(false), genmask(false), type(false), proto(false) {}
  bool ifindex :1;
  bool destination :1;
  bool gateway :1;
  bool genmask :1;
  bool type :1;
  bool proto :1;
} _RouteInfo__isset;

class RouteInfo {
 public:

  RouteInfo(const RouteInfo&);
  RouteInfo& operator=(const RouteInfo&);
  RouteInfo() : ifindex(0), type(0), proto(0) {
  }

  virtual ~RouteInfo() throw();
  int32_t ifindex;
  IpAddr destination;
  IpAddr gateway;
  IpAddr genmask;
  int32_t type;
  int32_t proto;

  _RouteInfo__isset __isset;

  void __set_ifindex(const int32_t val);

  void __set_destination(const IpAddr& val);

  void __set_gateway(const IpAddr& val);

  void __set_genmask(const IpAddr& val);

  void __set_type(const int32_t val);

  void __set_proto(const int32_t val);

  bool operator == (const RouteInfo & rhs) const
  {
    if (!(ifindex == rhs.ifindex))
      return false;
    if (!(destination == rhs.destination))
      return false;
    if (!(gateway == rhs.gateway))
      return false;
    if (!(genmask == rhs.genmask))
      return false;
    if (!(type == rhs.type))
      return false;
    if (!(proto == rhs.proto))
      return false;
    return true;
  }
  bool operator != (const RouteInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const RouteInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(RouteInfo &a, RouteInfo &b);

inline std::ostream& operator<<(std::ostream& out, const RouteInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _SysInfo__isset {
  _SysInfo__isset() : load(false), usercpu(false), syscpu(false), idlecpu(false), totalmem(false), freemem(false), buffer(false), cache(false), availmem(false) {}
  bool load :1;
  bool usercpu :1;
  bool syscpu :1;
  bool idlecpu :1;
  bool totalmem :1;
  bool freemem :1;
  bool buffer :1;
  bool cache :1;
  bool availmem :1;
} _SysInfo__isset;

class SysInfo {
 public:

  SysInfo(const SysInfo&);
  SysInfo& operator=(const SysInfo&);
  SysInfo() : load(0), usercpu(0), syscpu(0), idlecpu(0), totalmem(0), freemem(0), buffer(0), cache(0), availmem(0) {
  }

  virtual ~SysInfo() throw();
  int32_t load;
  int32_t usercpu;
  int32_t syscpu;
  int32_t idlecpu;
  int32_t totalmem;
  int32_t freemem;
  int32_t buffer;
  int32_t cache;
  int32_t availmem;

  _SysInfo__isset __isset;

  void __set_load(const int32_t val);

  void __set_usercpu(const int32_t val);

  void __set_syscpu(const int32_t val);

  void __set_idlecpu(const int32_t val);

  void __set_totalmem(const int32_t val);

  void __set_freemem(const int32_t val);

  void __set_buffer(const int32_t val);

  void __set_cache(const int32_t val);

  void __set_availmem(const int32_t val);

  bool operator == (const SysInfo & rhs) const
  {
    if (!(load == rhs.load))
      return false;
    if (!(usercpu == rhs.usercpu))
      return false;
    if (!(syscpu == rhs.syscpu))
      return false;
    if (!(idlecpu == rhs.idlecpu))
      return false;
    if (!(totalmem == rhs.totalmem))
      return false;
    if (!(freemem == rhs.freemem))
      return false;
    if (!(buffer == rhs.buffer))
      return false;
    if (!(cache == rhs.cache))
      return false;
    if (!(availmem == rhs.availmem))
      return false;
    return true;
  }
  bool operator != (const SysInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const SysInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(SysInfo &a, SysInfo &b);

inline std::ostream& operator<<(std::ostream& out, const SysInfo& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _ProcessInfo__isset {
  _ProcessInfo__isset() : name(false), existflag(false), pid(false), cputime(false), usedmem(false) {}
  bool name :1;
  bool existflag :1;
  bool pid :1;
  bool cputime :1;
  bool usedmem :1;
} _ProcessInfo__isset;

class ProcessInfo {
 public:

  ProcessInfo(const ProcessInfo&);
  ProcessInfo& operator=(const ProcessInfo&);
  ProcessInfo() : name(), existflag(0), pid(0), cputime(0), usedmem(0) {
  }

  virtual ~ProcessInfo() throw();
  std::string name;
  bool existflag;
  int32_t pid;
  int32_t cputime;
  int32_t usedmem;

  _ProcessInfo__isset __isset;

  void __set_name(const std::string& val);

  void __set_existflag(const bool val);

  void __set_pid(const int32_t val);

  void __set_cputime(const int32_t val);

  void __set_usedmem(const int32_t val);

  bool operator == (const ProcessInfo & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(existflag == rhs.existflag))
      return false;
    if (!(pid == rhs.pid))
      return false;
    if (!(cputime == rhs.cputime))
      return false;
    if (!(usedmem == rhs.usedmem))
      return false;
    return true;
  }
  bool operator != (const ProcessInfo &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const ProcessInfo & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(ProcessInfo &a, ProcessInfo &b);

inline std::ostream& operator<<(std::ostream& out, const ProcessInfo& obj)
{
  obj.printTo(out);
  return out;
}

}}} // namespace

#endif
