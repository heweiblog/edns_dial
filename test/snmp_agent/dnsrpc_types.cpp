/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "dnsrpc_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace rpc { namespace yamutech { namespace com {

int _kModuleTypeValues[] = {
  ModuleType::CRM,
  ModuleType::DIALING,
  ModuleType::YRDNS
};
const char* _kModuleTypeNames[] = {
  "CRM",
  "DIALING",
  "YRDNS"
};
const std::map<int, const char*> _ModuleType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kModuleTypeValues, _kModuleTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLogLevelValues[] = {
  LogLevel::NORMAL,
  LogLevel::WARN,
  LogLevel::ERROR
};
const char* _kLogLevelNames[] = {
  "NORMAL",
  "WARN",
  "ERROR"
};
const std::map<int, const char*> _LogLevel_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kLogLevelValues, _kLogLevelNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDialStatusValues[] = {
  DialStatus::OK,
  DialStatus::FAIL
};
const char* _kDialStatusNames[] = {
  "OK",
  "FAIL"
};
const std::map<int, const char*> _DialStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kDialStatusValues, _kDialStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kRetCodeValues[] = {
  RetCode::OK,
  RetCode::FAIL
};
const char* _kRetCodeNames[] = {
  "OK",
  "FAIL"
};
const std::map<int, const char*> _RetCode_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kRetCodeValues, _kRetCodeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSecParamNameValues[] = {
  SecParamName::SEC_PARAM_WHITELIST,
  SecParamName::SEC_PARAM_ACL,
  SecParamName::SEC_PARAM_QPSLIMIT,
  SecParamName::SEC_PARAM_BLACKLIST,
  SecParamName::SEC_PARAM_TCP,
  SecParamName::SEC_PARAM_TCPLIMIT,
  SecParamName::SEC_PARAM_ICMPLIMIT,
  SecParamName::SEC_PARAM_CACHEVIRUSLIMIT,
  SecParamName::SEC_PARAM_FILTERIP,
  SecParamName::SEC_PARAM_FILTERUDP,
  SecParamName::SEC_PARAM_FILTERDNS,
  SecParamName::SEC_PARAM_DDOSDEFEND,
  SecParamName::SEC_PARAM_DNSFLOODDEFND
};
const char* _kSecParamNameNames[] = {
  "SEC_PARAM_WHITELIST",
  "SEC_PARAM_ACL",
  "SEC_PARAM_QPSLIMIT",
  "SEC_PARAM_BLACKLIST",
  "SEC_PARAM_TCP",
  "SEC_PARAM_TCPLIMIT",
  "SEC_PARAM_ICMPLIMIT",
  "SEC_PARAM_CACHEVIRUSLIMIT",
  "SEC_PARAM_FILTERIP",
  "SEC_PARAM_FILTERUDP",
  "SEC_PARAM_FILTERDNS",
  "SEC_PARAM_DDOSDEFEND",
  "SEC_PARAM_DNSFLOODDEFND"
};
const std::map<int, const char*> _SecParamName_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(13, _kSecParamNameValues, _kSecParamNameNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDnsParamNameValues[] = {
  DnsParamName::DNS_PARAM_AUTH,
  DnsParamName::DNS_PARAM_XFORWARD,
  DnsParamName::DNS_PARAM_TTL,
  DnsParamName::DNS_PARAM_REDIRECT,
  DnsParamName::DNS_PARAM_SPREAD,
  DnsParamName::DNS_PARAM_RECUSIVE,
  DnsParamName::DNS_PARAM_CACHE
};
const char* _kDnsParamNameNames[] = {
  "DNS_PARAM_AUTH",
  "DNS_PARAM_XFORWARD",
  "DNS_PARAM_TTL",
  "DNS_PARAM_REDIRECT",
  "DNS_PARAM_SPREAD",
  "DNS_PARAM_RECUSIVE",
  "DNS_PARAM_CACHE"
};
const std::map<int, const char*> _DnsParamName_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kDnsParamNameValues, _kDnsParamNameNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kStatusValues[] = {
  Status::STATUS_INACTIVE,
  Status::STATUS_ACTIVE
};
const char* _kStatusNames[] = {
  "STATUS_INACTIVE",
  "STATUS_ACTIVE"
};
const std::map<int, const char*> _Status_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kStatusValues, _kStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDialMethodValues[] = {
  DialMethod::DIAL_TCPPORT,
  DialMethod::DIAL_IMCP,
  DialMethod::DIAL_HTTPGET,
  DialMethod::DIAL_DATABASE,
  DialMethod::DIAL_EXTHTTPGET
};
const char* _kDialMethodNames[] = {
  "DIAL_TCPPORT",
  "DIAL_IMCP",
  "DIAL_HTTPGET",
  "DIAL_DATABASE",
  "DIAL_EXTHTTPGET"
};
const std::map<int, const char*> _DialMethod_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(5, _kDialMethodValues, _kDialMethodNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kAlarmStatusValues[] = {
  AlarmStatus::ALARM_OFF,
  AlarmStatus::ALARM_ON
};
const char* _kAlarmStatusNames[] = {
  "ALARM_OFF",
  "ALARM_ON"
};
const std::map<int, const char*> _AlarmStatus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kAlarmStatusValues, _kAlarmStatusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kAlarmTypeValues[] = {
  AlarmType::DNSysDeviceQpsOverAlarm,
  AlarmType::DNSysDeviceRequestIpOverAlarm,
  AlarmType::DNSysDeviceDomainQpsOverAlarm,
  AlarmType::DNSysDeviceDnameQpsOverAlarm,
  AlarmType::DNSysDeviceFocusDomainAlarm,
  AlarmType::DeviceCpuUsageAlarm,
  AlarmType::DeviceMemoryUsageAlarm,
  AlarmType::DevicePartitionUsageAlarm,
  AlarmType::DeviceNicFlowOverAlarm,
  AlarmType::NoneDeviceConnectionAlarm,
  AlarmType::DeviceProcessAlarm,
  AlarmType::DNSysDeviceServfailOverAlarm,
  AlarmType::ForwardFailAlarm,
  AlarmType::ProxyFailAlarm,
  AlarmType::ServiceFailAlarm,
  AlarmType::DiskFailAlarm,
  AlarmType::LogAlarm,
  AlarmType::RecordialFailAlarm,
  AlarmType::RedirectFailAlarm,
  AlarmType::NginxServerFailAlarm,
  AlarmType::DhcpPoolAlarm,
  AlarmType::DhcpIpAddressConflictsAlarm,
  AlarmType::DhcpQpsAlarm,
  AlarmType::DhcpIlegalServerAlarm,
  AlarmType::DDNSAlarm,
  AlarmType::HostHaAlarm
};
const char* _kAlarmTypeNames[] = {
  "DNSysDeviceQpsOverAlarm",
  "DNSysDeviceRequestIpOverAlarm",
  "DNSysDeviceDomainQpsOverAlarm",
  "DNSysDeviceDnameQpsOverAlarm",
  "DNSysDeviceFocusDomainAlarm",
  "DeviceCpuUsageAlarm",
  "DeviceMemoryUsageAlarm",
  "DevicePartitionUsageAlarm",
  "DeviceNicFlowOverAlarm",
  "NoneDeviceConnectionAlarm",
  "DeviceProcessAlarm",
  "DNSysDeviceServfailOverAlarm",
  "ForwardFailAlarm",
  "ProxyFailAlarm",
  "ServiceFailAlarm",
  "DiskFailAlarm",
  "LogAlarm",
  "RecordialFailAlarm",
  "RedirectFailAlarm",
  "NginxServerFailAlarm",
  "DhcpPoolAlarm",
  "DhcpIpAddressConflictsAlarm",
  "DhcpQpsAlarm",
  "DhcpIlegalServerAlarm",
  "DDNSAlarm",
  "HostHaAlarm"
};
const std::map<int, const char*> _AlarmType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(26, _kAlarmTypeValues, _kAlarmTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kModuleStateValues[] = {
  ModuleState::STARTUP,
  ModuleState::REGISTERED
};
const char* _kModuleStateNames[] = {
  "STARTUP",
  "REGISTERED"
};
const std::map<int, const char*> _ModuleState_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kModuleStateValues, _kModuleStateNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSysCommandValues[] = {
  SysCommand::RestoreConfig
};
const char* _kSysCommandNames[] = {
  "RestoreConfig"
};
const std::map<int, const char*> _SysCommand_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(1, _kSysCommandValues, _kSysCommandNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDialServerTypeValues[] = {
  DialServerType::XPROXY,
  DialServerType::REDIRECT,
  DialServerType::XFORWARD
};
const char* _kDialServerTypeNames[] = {
  "XPROXY",
  "REDIRECT",
  "XFORWARD"
};
const std::map<int, const char*> _DialServerType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kDialServerTypeValues, _kDialServerTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kRecordTypeValues[] = {
  RecordType::A,
  RecordType::AAAA,
  RecordType::NS,
  RecordType::CNAME,
  RecordType::PTR,
  RecordType::TXT,
  RecordType::SRV,
  RecordType::NAPTR,
  RecordType::MX
};
const char* _kRecordTypeNames[] = {
  "A",
  "AAAA",
  "NS",
  "CNAME",
  "PTR",
  "TXT",
  "SRV",
  "NAPTR",
  "MX"
};
const std::map<int, const char*> _RecordType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(9, _kRecordTypeValues, _kRecordTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kDNameTypeValues[] = {
  DNameType::DNAME_NONE,
  DNameType::DNAME_WHOLE,
  DNameType::DNAME_PREFIX,
  DNameType::DNAME_POSTFIX
};
const char* _kDNameTypeNames[] = {
  "DNAME_NONE",
  "DNAME_WHOLE",
  "DNAME_PREFIX",
  "DNAME_POSTFIX"
};
const std::map<int, const char*> _DNameType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(4, _kDNameTypeValues, _kDNameTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Xception::~Xception() throw() {
}


void Xception::__set_errorCode(const int32_t val) {
  this->errorCode = val;
}

void Xception::__set_message(const std::string& val) {
  this->message = val;
}

uint32_t Xception::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->errorCode);
          this->__isset.errorCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->message);
          this->__isset.message = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Xception::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Xception");

  xfer += oprot->writeFieldBegin("errorCode", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->errorCode);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("message", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->message);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Xception &a, Xception &b) {
  using ::std::swap;
  swap(a.errorCode, b.errorCode);
  swap(a.message, b.message);
  swap(a.__isset, b.__isset);
}

Xception::Xception(const Xception& other0) : TException() {
  errorCode = other0.errorCode;
  message = other0.message;
  __isset = other0.__isset;
}
Xception& Xception::operator=(const Xception& other1) {
  errorCode = other1.errorCode;
  message = other1.message;
  __isset = other1.__isset;
  return *this;
}
void Xception::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Xception(";
  out << "errorCode=" << to_string(errorCode);
  out << ", " << "message=" << to_string(message);
  out << ")";
}

const char* Xception::what() const throw() {
  try {
    std::stringstream ss;
    ss << "TException - service has thrown: " << *this;
    this->thriftTExceptionMessageHolder_ = ss.str();
    return this->thriftTExceptionMessageHolder_.c_str();
  } catch (const std::exception&) {
    return "TException - service has thrown: Xception";
  }
}


RetRecord::~RetRecord() throw() {
}


void RetRecord::__set_recordId(const std::string& val) {
  this->recordId = val;
}

void RetRecord::__set_code(const RetCode::type val) {
  this->code = val;
}

uint32_t RetRecord::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->recordId);
          this->__isset.recordId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->code = (RetCode::type)ecast2;
          this->__isset.code = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RetRecord::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RetRecord");

  xfer += oprot->writeFieldBegin("recordId", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->recordId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("code", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->code);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RetRecord &a, RetRecord &b) {
  using ::std::swap;
  swap(a.recordId, b.recordId);
  swap(a.code, b.code);
  swap(a.__isset, b.__isset);
}

RetRecord::RetRecord(const RetRecord& other3) {
  recordId = other3.recordId;
  code = other3.code;
  __isset = other3.__isset;
}
RetRecord& RetRecord::operator=(const RetRecord& other4) {
  recordId = other4.recordId;
  code = other4.code;
  __isset = other4.__isset;
  return *this;
}
void RetRecord::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RetRecord(";
  out << "recordId=" << to_string(recordId);
  out << ", " << "code=" << to_string(code);
  out << ")";
}


IpAddr::~IpAddr() throw() {
}


void IpAddr::__set_version(const int32_t val) {
  this->version = val;
}

void IpAddr::__set_addr(const std::string& val) {
  this->addr = val;
}

uint32_t IpAddr::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->addr);
          this->__isset.addr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IpAddr::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IpAddr");

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("addr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->addr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IpAddr &a, IpAddr &b) {
  using ::std::swap;
  swap(a.version, b.version);
  swap(a.addr, b.addr);
  swap(a.__isset, b.__isset);
}

IpAddr::IpAddr(const IpAddr& other5) {
  version = other5.version;
  addr = other5.addr;
  __isset = other5.__isset;
}
IpAddr& IpAddr::operator=(const IpAddr& other6) {
  version = other6.version;
  addr = other6.addr;
  __isset = other6.__isset;
  return *this;
}
void IpAddr::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IpAddr(";
  out << "version=" << to_string(version);
  out << ", " << "addr=" << to_string(addr);
  out << ")";
}


DialNginxServer::~DialNginxServer() throw() {
}


void DialNginxServer::__set_localURL(const std::string& val) {
  this->localURL = val;
}

void DialNginxServer::__set_priority(const int32_t val) {
  this->priority = val;
}

uint32_t DialNginxServer::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->localURL);
          this->__isset.localURL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priority);
          this->__isset.priority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DialNginxServer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DialNginxServer");

  xfer += oprot->writeFieldBegin("localURL", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->localURL);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("priority", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->priority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DialNginxServer &a, DialNginxServer &b) {
  using ::std::swap;
  swap(a.localURL, b.localURL);
  swap(a.priority, b.priority);
  swap(a.__isset, b.__isset);
}

DialNginxServer::DialNginxServer(const DialNginxServer& other7) {
  localURL = other7.localURL;
  priority = other7.priority;
  __isset = other7.__isset;
}
DialNginxServer& DialNginxServer::operator=(const DialNginxServer& other8) {
  localURL = other8.localURL;
  priority = other8.priority;
  __isset = other8.__isset;
  return *this;
}
void DialNginxServer::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DialNginxServer(";
  out << "localURL=" << to_string(localURL);
  out << ", " << "priority=" << to_string(priority);
  out << ")";
}


DialRecordStatus::~DialRecordStatus() throw() {
}


void DialRecordStatus::__set_rid(const ObjectId& val) {
  this->rid = val;
}

void DialRecordStatus::__set_status(const DialStatus::type val) {
  this->status = val;
}

void DialRecordStatus::__set_delay(const int64_t val) {
  this->delay = val;
}

uint32_t DialRecordStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rid);
          this->__isset.rid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast9;
          xfer += iprot->readI32(ecast9);
          this->status = (DialStatus::type)ecast9;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->delay);
          this->__isset.delay = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DialRecordStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DialRecordStatus");

  xfer += oprot->writeFieldBegin("rid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->rid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delay", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->delay);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DialRecordStatus &a, DialRecordStatus &b) {
  using ::std::swap;
  swap(a.rid, b.rid);
  swap(a.status, b.status);
  swap(a.delay, b.delay);
  swap(a.__isset, b.__isset);
}

DialRecordStatus::DialRecordStatus(const DialRecordStatus& other10) {
  rid = other10.rid;
  status = other10.status;
  delay = other10.delay;
  __isset = other10.__isset;
}
DialRecordStatus& DialRecordStatus::operator=(const DialRecordStatus& other11) {
  rid = other11.rid;
  status = other11.status;
  delay = other11.delay;
  __isset = other11.__isset;
  return *this;
}
void DialRecordStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DialRecordStatus(";
  out << "rid=" << to_string(rid);
  out << ", " << "status=" << to_string(status);
  out << ", " << "delay=" << to_string(delay);
  out << ")";
}


DialNginxStatus::~DialNginxStatus() throw() {
}


void DialNginxStatus::__set_server(const DialNginxServer& val) {
  this->server = val;
}

void DialNginxStatus::__set_status(const DialStatus::type val) {
  this->status = val;
}

void DialNginxStatus::__set_delay(const int64_t val) {
  this->delay = val;
}

uint32_t DialNginxStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->server.read(iprot);
          this->__isset.server = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast12;
          xfer += iprot->readI32(ecast12);
          this->status = (DialStatus::type)ecast12;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->delay);
          this->__isset.delay = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DialNginxStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DialNginxStatus");

  xfer += oprot->writeFieldBegin("server", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->server.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delay", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->delay);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DialNginxStatus &a, DialNginxStatus &b) {
  using ::std::swap;
  swap(a.server, b.server);
  swap(a.status, b.status);
  swap(a.delay, b.delay);
  swap(a.__isset, b.__isset);
}

DialNginxStatus::DialNginxStatus(const DialNginxStatus& other13) {
  server = other13.server;
  status = other13.status;
  delay = other13.delay;
  __isset = other13.__isset;
}
DialNginxStatus& DialNginxStatus::operator=(const DialNginxStatus& other14) {
  server = other14.server;
  status = other14.status;
  delay = other14.delay;
  __isset = other14.__isset;
  return *this;
}
void DialNginxStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DialNginxStatus(";
  out << "server=" << to_string(server);
  out << ", " << "status=" << to_string(status);
  out << ", " << "delay=" << to_string(delay);
  out << ")";
}


DialRecordAlarm::~DialRecordAlarm() throw() {
}


void DialRecordAlarm::__set_ip(const IpAddr& val) {
  this->ip = val;
}

void DialRecordAlarm::__set_enable(const bool val) {
  this->enable = val;
}

void DialRecordAlarm::__set_dial(const bool val) {
  this->dial = val;
}

uint32_t DialRecordAlarm::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ip.read(iprot);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable);
          this->__isset.enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->dial);
          this->__isset.dial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DialRecordAlarm::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DialRecordAlarm");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->ip.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enable", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->enable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dial", ::apache::thrift::protocol::T_BOOL, 3);
  xfer += oprot->writeBool(this->dial);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DialRecordAlarm &a, DialRecordAlarm &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.enable, b.enable);
  swap(a.dial, b.dial);
  swap(a.__isset, b.__isset);
}

DialRecordAlarm::DialRecordAlarm(const DialRecordAlarm& other15) {
  ip = other15.ip;
  enable = other15.enable;
  dial = other15.dial;
  __isset = other15.__isset;
}
DialRecordAlarm& DialRecordAlarm::operator=(const DialRecordAlarm& other16) {
  ip = other16.ip;
  enable = other16.enable;
  dial = other16.dial;
  __isset = other16.__isset;
  return *this;
}
void DialRecordAlarm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DialRecordAlarm(";
  out << "ip=" << to_string(ip);
  out << ", " << "enable=" << to_string(enable);
  out << ", " << "dial=" << to_string(dial);
  out << ")";
}


DialServerStatus::~DialServerStatus() throw() {
}


void DialServerStatus::__set_rid(const ObjectId& val) {
  this->rid = val;
}

void DialServerStatus::__set_ip(const IpAddr& val) {
  this->ip = val;
}

void DialServerStatus::__set_status(const DialStatus::type val) {
  this->status = val;
}

void DialServerStatus::__set_delay(const int64_t val) {
  this->delay = val;
}

uint32_t DialServerStatus::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rid);
          this->__isset.rid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ip.read(iprot);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast17;
          xfer += iprot->readI32(ecast17);
          this->status = (DialStatus::type)ecast17;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->delay);
          this->__isset.delay = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DialServerStatus::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DialServerStatus");

  xfer += oprot->writeFieldBegin("rid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->rid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->ip.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("delay", ::apache::thrift::protocol::T_I64, 4);
  xfer += oprot->writeI64(this->delay);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DialServerStatus &a, DialServerStatus &b) {
  using ::std::swap;
  swap(a.rid, b.rid);
  swap(a.ip, b.ip);
  swap(a.status, b.status);
  swap(a.delay, b.delay);
  swap(a.__isset, b.__isset);
}

DialServerStatus::DialServerStatus(const DialServerStatus& other18) {
  rid = other18.rid;
  ip = other18.ip;
  status = other18.status;
  delay = other18.delay;
  __isset = other18.__isset;
}
DialServerStatus& DialServerStatus::operator=(const DialServerStatus& other19) {
  rid = other19.rid;
  ip = other19.ip;
  status = other19.status;
  delay = other19.delay;
  __isset = other19.__isset;
  return *this;
}
void DialServerStatus::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DialServerStatus(";
  out << "rid=" << to_string(rid);
  out << ", " << "ip=" << to_string(ip);
  out << ", " << "status=" << to_string(status);
  out << ", " << "delay=" << to_string(delay);
  out << ")";
}


IpsecAddress::~IpsecAddress() throw() {
}


void IpsecAddress::__set_ip(const IpAddr& val) {
  this->ip = val;
}

void IpsecAddress::__set_mask(const int32_t val) {
  this->mask = val;
}

uint32_t IpsecAddress::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ip.read(iprot);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mask);
          this->__isset.mask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IpsecAddress::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IpsecAddress");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->ip.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mask", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->mask);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IpsecAddress &a, IpsecAddress &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.mask, b.mask);
  swap(a.__isset, b.__isset);
}

IpsecAddress::IpsecAddress(const IpsecAddress& other20) {
  ip = other20.ip;
  mask = other20.mask;
  __isset = other20.__isset;
}
IpsecAddress& IpsecAddress::operator=(const IpsecAddress& other21) {
  ip = other21.ip;
  mask = other21.mask;
  __isset = other21.__isset;
  return *this;
}
void IpsecAddress::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IpsecAddress(";
  out << "ip=" << to_string(ip);
  out << ", " << "mask=" << to_string(mask);
  out << ")";
}


DomainInfo::~DomainInfo() throw() {
}


void DomainInfo::__set_typ(const std::string& val) {
  this->typ = val;
}

void DomainInfo::__set_name(const std::string& val) {
  this->name = val;
}

uint32_t DomainInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->typ);
          this->__isset.typ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DomainInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DomainInfo");

  xfer += oprot->writeFieldBegin("typ", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->typ);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DomainInfo &a, DomainInfo &b) {
  using ::std::swap;
  swap(a.typ, b.typ);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

DomainInfo::DomainInfo(const DomainInfo& other22) {
  typ = other22.typ;
  name = other22.name;
  __isset = other22.__isset;
}
DomainInfo& DomainInfo::operator=(const DomainInfo& other23) {
  typ = other23.typ;
  name = other23.name;
  __isset = other23.__isset;
  return *this;
}
void DomainInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DomainInfo(";
  out << "typ=" << to_string(typ);
  out << ", " << "name=" << to_string(name);
  out << ")";
}


RangeInfo::~RangeInfo() throw() {
}


void RangeInfo::__set_start(const int16_t val) {
  this->start = val;
}

void RangeInfo::__set_ends(const int16_t val) {
  this->ends = val;
}

uint32_t RangeInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->start);
          this->__isset.start = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->ends);
          this->__isset.ends = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RangeInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RangeInfo");

  xfer += oprot->writeFieldBegin("start", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->start);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ends", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->ends);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RangeInfo &a, RangeInfo &b) {
  using ::std::swap;
  swap(a.start, b.start);
  swap(a.ends, b.ends);
  swap(a.__isset, b.__isset);
}

RangeInfo::RangeInfo(const RangeInfo& other24) {
  start = other24.start;
  ends = other24.ends;
  __isset = other24.__isset;
}
RangeInfo& RangeInfo::operator=(const RangeInfo& other25) {
  start = other25.start;
  ends = other25.ends;
  __isset = other25.__isset;
  return *this;
}
void RangeInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RangeInfo(";
  out << "start=" << to_string(start);
  out << ", " << "ends=" << to_string(ends);
  out << ")";
}


SysIpSec::~SysIpSec() throw() {
}


void SysIpSec::__set_name(const std::string& val) {
  this->name = val;
}

void SysIpSec::__set_ipsec(const IpsecAddress& val) {
  this->ipsec = val;
}

void SysIpSec::__set_recordId(const std::string& val) {
  this->recordId = val;
}

uint32_t SysIpSec::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ipsec.read(iprot);
          this->__isset.ipsec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->recordId);
          this->__isset.recordId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SysIpSec::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SysIpSec");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ipsec", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->ipsec.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("recordId", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->recordId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SysIpSec &a, SysIpSec &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.ipsec, b.ipsec);
  swap(a.recordId, b.recordId);
  swap(a.__isset, b.__isset);
}

SysIpSec::SysIpSec(const SysIpSec& other26) {
  name = other26.name;
  ipsec = other26.ipsec;
  recordId = other26.recordId;
  __isset = other26.__isset;
}
SysIpSec& SysIpSec::operator=(const SysIpSec& other27) {
  name = other27.name;
  ipsec = other27.ipsec;
  recordId = other27.recordId;
  __isset = other27.__isset;
  return *this;
}
void SysIpSec::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SysIpSec(";
  out << "name=" << to_string(name);
  out << ", " << "ipsec=" << to_string(ipsec);
  out << ", " << "recordId=" << to_string(recordId);
  out << ")";
}


AclInfo::~AclInfo() throw() {
}


void AclInfo::__set_id(const ObjectId& val) {
  this->id = val;
}

void AclInfo::__set_priority(const int32_t val) {
  this->priority = val;
__isset.priority = true;
}

void AclInfo::__set_srcIpSec(const IpsecAddress& val) {
  this->srcIpSec = val;
__isset.srcIpSec = true;
}

void AclInfo::__set_dstIpSec(const IpsecAddress& val) {
  this->dstIpSec = val;
__isset.dstIpSec = true;
}

void AclInfo::__set_srcPortSec(const RangeInfo& val) {
  this->srcPortSec = val;
__isset.srcPortSec = true;
}

void AclInfo::__set_dstPortSec(const RangeInfo& val) {
  this->dstPortSec = val;
__isset.dstPortSec = true;
}

void AclInfo::__set_frameTypeSec(const RangeInfo& val) {
  this->frameTypeSec = val;
__isset.frameTypeSec = true;
}

void AclInfo::__set_ipProtoSec(const RangeInfo& val) {
  this->ipProtoSec = val;
__isset.ipProtoSec = true;
}

void AclInfo::__set_qpsLimit(const int32_t val) {
  this->qpsLimit = val;
__isset.qpsLimit = true;
}

uint32_t AclInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priority);
          this->__isset.priority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->srcIpSec.read(iprot);
          this->__isset.srcIpSec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dstIpSec.read(iprot);
          this->__isset.dstIpSec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->srcPortSec.read(iprot);
          this->__isset.srcPortSec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dstPortSec.read(iprot);
          this->__isset.dstPortSec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->frameTypeSec.read(iprot);
          this->__isset.frameTypeSec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ipProtoSec.read(iprot);
          this->__isset.ipProtoSec = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qpsLimit);
          this->__isset.qpsLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t AclInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("AclInfo");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->id);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.priority) {
    xfer += oprot->writeFieldBegin("priority", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->priority);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.srcIpSec) {
    xfer += oprot->writeFieldBegin("srcIpSec", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->srcIpSec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dstIpSec) {
    xfer += oprot->writeFieldBegin("dstIpSec", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->dstIpSec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.srcPortSec) {
    xfer += oprot->writeFieldBegin("srcPortSec", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->srcPortSec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dstPortSec) {
    xfer += oprot->writeFieldBegin("dstPortSec", ::apache::thrift::protocol::T_STRUCT, 6);
    xfer += this->dstPortSec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.frameTypeSec) {
    xfer += oprot->writeFieldBegin("frameTypeSec", ::apache::thrift::protocol::T_STRUCT, 7);
    xfer += this->frameTypeSec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ipProtoSec) {
    xfer += oprot->writeFieldBegin("ipProtoSec", ::apache::thrift::protocol::T_STRUCT, 8);
    xfer += this->ipProtoSec.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.qpsLimit) {
    xfer += oprot->writeFieldBegin("qpsLimit", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->qpsLimit);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(AclInfo &a, AclInfo &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.priority, b.priority);
  swap(a.srcIpSec, b.srcIpSec);
  swap(a.dstIpSec, b.dstIpSec);
  swap(a.srcPortSec, b.srcPortSec);
  swap(a.dstPortSec, b.dstPortSec);
  swap(a.frameTypeSec, b.frameTypeSec);
  swap(a.ipProtoSec, b.ipProtoSec);
  swap(a.qpsLimit, b.qpsLimit);
  swap(a.__isset, b.__isset);
}

AclInfo::AclInfo(const AclInfo& other28) {
  id = other28.id;
  priority = other28.priority;
  srcIpSec = other28.srcIpSec;
  dstIpSec = other28.dstIpSec;
  srcPortSec = other28.srcPortSec;
  dstPortSec = other28.dstPortSec;
  frameTypeSec = other28.frameTypeSec;
  ipProtoSec = other28.ipProtoSec;
  qpsLimit = other28.qpsLimit;
  __isset = other28.__isset;
}
AclInfo& AclInfo::operator=(const AclInfo& other29) {
  id = other29.id;
  priority = other29.priority;
  srcIpSec = other29.srcIpSec;
  dstIpSec = other29.dstIpSec;
  srcPortSec = other29.srcPortSec;
  dstPortSec = other29.dstPortSec;
  frameTypeSec = other29.frameTypeSec;
  ipProtoSec = other29.ipProtoSec;
  qpsLimit = other29.qpsLimit;
  __isset = other29.__isset;
  return *this;
}
void AclInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "AclInfo(";
  out << "id=" << to_string(id);
  out << ", " << "priority="; (__isset.priority ? (out << to_string(priority)) : (out << "<null>"));
  out << ", " << "srcIpSec="; (__isset.srcIpSec ? (out << to_string(srcIpSec)) : (out << "<null>"));
  out << ", " << "dstIpSec="; (__isset.dstIpSec ? (out << to_string(dstIpSec)) : (out << "<null>"));
  out << ", " << "srcPortSec="; (__isset.srcPortSec ? (out << to_string(srcPortSec)) : (out << "<null>"));
  out << ", " << "dstPortSec="; (__isset.dstPortSec ? (out << to_string(dstPortSec)) : (out << "<null>"));
  out << ", " << "frameTypeSec="; (__isset.frameTypeSec ? (out << to_string(frameTypeSec)) : (out << "<null>"));
  out << ", " << "ipProtoSec="; (__isset.ipProtoSec ? (out << to_string(ipProtoSec)) : (out << "<null>"));
  out << ", " << "qpsLimit="; (__isset.qpsLimit ? (out << to_string(qpsLimit)) : (out << "<null>"));
  out << ")";
}


ZoneInfo::~ZoneInfo() throw() {
}


void ZoneInfo::__set_name(const std::string& val) {
  this->name = val;
}

void ZoneInfo::__set_viewName(const std::string& val) {
  this->viewName = val;
}

void ZoneInfo::__set_typ(const int32_t val) {
  this->typ = val;
__isset.typ = true;
}

void ZoneInfo::__set_nsRecord(const std::string& val) {
  this->nsRecord = val;
__isset.nsRecord = true;
}

void ZoneInfo::__set_aRecord(const std::string& val) {
  this->aRecord = val;
__isset.aRecord = true;
}

void ZoneInfo::__set_soaName(const std::string& val) {
  this->soaName = val;
__isset.soaName = true;
}

void ZoneInfo::__set_soaHost(const std::string& val) {
  this->soaHost = val;
__isset.soaHost = true;
}

void ZoneInfo::__set_serial(const int32_t val) {
  this->serial = val;
__isset.serial = true;
}

void ZoneInfo::__set_refresh(const int32_t val) {
  this->refresh = val;
__isset.refresh = true;
}

void ZoneInfo::__set_retries(const int32_t val) {
  this->retries = val;
__isset.retries = true;
}

void ZoneInfo::__set_expire(const int32_t val) {
  this->expire = val;
__isset.expire = true;
}

void ZoneInfo::__set_minTtl(const int32_t val) {
  this->minTtl = val;
__isset.minTtl = true;
}

void ZoneInfo::__set_recordId(const std::string& val) {
  this->recordId = val;
}

uint32_t ZoneInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewName);
          this->__isset.viewName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->typ);
          this->__isset.typ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->nsRecord);
          this->__isset.nsRecord = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->aRecord);
          this->__isset.aRecord = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->soaName);
          this->__isset.soaName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->soaHost);
          this->__isset.soaHost = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->serial);
          this->__isset.serial = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->refresh);
          this->__isset.refresh = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->retries);
          this->__isset.retries = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->expire);
          this->__isset.expire = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minTtl);
          this->__isset.minTtl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 13:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->recordId);
          this->__isset.recordId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ZoneInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ZoneInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->viewName);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.typ) {
    xfer += oprot->writeFieldBegin("typ", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->typ);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.nsRecord) {
    xfer += oprot->writeFieldBegin("nsRecord", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->nsRecord);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.aRecord) {
    xfer += oprot->writeFieldBegin("aRecord", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->aRecord);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.soaName) {
    xfer += oprot->writeFieldBegin("soaName", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->soaName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.soaHost) {
    xfer += oprot->writeFieldBegin("soaHost", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->soaHost);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.serial) {
    xfer += oprot->writeFieldBegin("serial", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32(this->serial);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.refresh) {
    xfer += oprot->writeFieldBegin("refresh", ::apache::thrift::protocol::T_I32, 9);
    xfer += oprot->writeI32(this->refresh);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.retries) {
    xfer += oprot->writeFieldBegin("retries", ::apache::thrift::protocol::T_I32, 10);
    xfer += oprot->writeI32(this->retries);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.expire) {
    xfer += oprot->writeFieldBegin("expire", ::apache::thrift::protocol::T_I32, 11);
    xfer += oprot->writeI32(this->expire);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.minTtl) {
    xfer += oprot->writeFieldBegin("minTtl", ::apache::thrift::protocol::T_I32, 12);
    xfer += oprot->writeI32(this->minTtl);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("recordId", ::apache::thrift::protocol::T_STRING, 13);
  xfer += oprot->writeString(this->recordId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ZoneInfo &a, ZoneInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.viewName, b.viewName);
  swap(a.typ, b.typ);
  swap(a.nsRecord, b.nsRecord);
  swap(a.aRecord, b.aRecord);
  swap(a.soaName, b.soaName);
  swap(a.soaHost, b.soaHost);
  swap(a.serial, b.serial);
  swap(a.refresh, b.refresh);
  swap(a.retries, b.retries);
  swap(a.expire, b.expire);
  swap(a.minTtl, b.minTtl);
  swap(a.recordId, b.recordId);
  swap(a.__isset, b.__isset);
}

ZoneInfo::ZoneInfo(const ZoneInfo& other30) {
  name = other30.name;
  viewName = other30.viewName;
  typ = other30.typ;
  nsRecord = other30.nsRecord;
  aRecord = other30.aRecord;
  soaName = other30.soaName;
  soaHost = other30.soaHost;
  serial = other30.serial;
  refresh = other30.refresh;
  retries = other30.retries;
  expire = other30.expire;
  minTtl = other30.minTtl;
  recordId = other30.recordId;
  __isset = other30.__isset;
}
ZoneInfo& ZoneInfo::operator=(const ZoneInfo& other31) {
  name = other31.name;
  viewName = other31.viewName;
  typ = other31.typ;
  nsRecord = other31.nsRecord;
  aRecord = other31.aRecord;
  soaName = other31.soaName;
  soaHost = other31.soaHost;
  serial = other31.serial;
  refresh = other31.refresh;
  retries = other31.retries;
  expire = other31.expire;
  minTtl = other31.minTtl;
  recordId = other31.recordId;
  __isset = other31.__isset;
  return *this;
}
void ZoneInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ZoneInfo(";
  out << "name=" << to_string(name);
  out << ", " << "viewName=" << to_string(viewName);
  out << ", " << "typ="; (__isset.typ ? (out << to_string(typ)) : (out << "<null>"));
  out << ", " << "nsRecord="; (__isset.nsRecord ? (out << to_string(nsRecord)) : (out << "<null>"));
  out << ", " << "aRecord="; (__isset.aRecord ? (out << to_string(aRecord)) : (out << "<null>"));
  out << ", " << "soaName="; (__isset.soaName ? (out << to_string(soaName)) : (out << "<null>"));
  out << ", " << "soaHost="; (__isset.soaHost ? (out << to_string(soaHost)) : (out << "<null>"));
  out << ", " << "serial="; (__isset.serial ? (out << to_string(serial)) : (out << "<null>"));
  out << ", " << "refresh="; (__isset.refresh ? (out << to_string(refresh)) : (out << "<null>"));
  out << ", " << "retries="; (__isset.retries ? (out << to_string(retries)) : (out << "<null>"));
  out << ", " << "expire="; (__isset.expire ? (out << to_string(expire)) : (out << "<null>"));
  out << ", " << "minTtl="; (__isset.minTtl ? (out << to_string(minTtl)) : (out << "<null>"));
  out << ", " << "recordId=" << to_string(recordId);
  out << ")";
}


DnsQueryResultSRV::~DnsQueryResultSRV() throw() {
}


void DnsQueryResultSRV::__set_priority(const int16_t val) {
  this->priority = val;
}

void DnsQueryResultSRV::__set_weight(const int16_t val) {
  this->weight = val;
}

void DnsQueryResultSRV::__set_port(const int16_t val) {
  this->port = val;
}

void DnsQueryResultSRV::__set_target(const std::string& val) {
  this->target = val;
}

uint32_t DnsQueryResultSRV::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->priority);
          this->__isset.priority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->weight);
          this->__isset.weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->target);
          this->__isset.target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DnsQueryResultSRV::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DnsQueryResultSRV");

  xfer += oprot->writeFieldBegin("priority", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->priority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->weight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I16, 3);
  xfer += oprot->writeI16(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->target);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DnsQueryResultSRV &a, DnsQueryResultSRV &b) {
  using ::std::swap;
  swap(a.priority, b.priority);
  swap(a.weight, b.weight);
  swap(a.port, b.port);
  swap(a.target, b.target);
  swap(a.__isset, b.__isset);
}

DnsQueryResultSRV::DnsQueryResultSRV(const DnsQueryResultSRV& other32) {
  priority = other32.priority;
  weight = other32.weight;
  port = other32.port;
  target = other32.target;
  __isset = other32.__isset;
}
DnsQueryResultSRV& DnsQueryResultSRV::operator=(const DnsQueryResultSRV& other33) {
  priority = other33.priority;
  weight = other33.weight;
  port = other33.port;
  target = other33.target;
  __isset = other33.__isset;
  return *this;
}
void DnsQueryResultSRV::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DnsQueryResultSRV(";
  out << "priority=" << to_string(priority);
  out << ", " << "weight=" << to_string(weight);
  out << ", " << "port=" << to_string(port);
  out << ", " << "target=" << to_string(target);
  out << ")";
}


DnsQueryResultNAPTR::~DnsQueryResultNAPTR() throw() {
}


void DnsQueryResultNAPTR::__set_order(const int16_t val) {
  this->order = val;
}

void DnsQueryResultNAPTR::__set_pref(const int16_t val) {
  this->pref = val;
}

void DnsQueryResultNAPTR::__set_flags(const std::string& val) {
  this->flags = val;
}

void DnsQueryResultNAPTR::__set_svc(const std::string& val) {
  this->svc = val;
}

void DnsQueryResultNAPTR::__set_regexp(const std::string& val) {
  this->regexp = val;
}

void DnsQueryResultNAPTR::__set_domainName(const std::string& val) {
  this->domainName = val;
}

uint32_t DnsQueryResultNAPTR::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->order);
          this->__isset.order = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->pref);
          this->__isset.pref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->flags);
          this->__isset.flags = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->svc);
          this->__isset.svc = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->regexp);
          this->__isset.regexp = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domainName);
          this->__isset.domainName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DnsQueryResultNAPTR::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DnsQueryResultNAPTR");

  xfer += oprot->writeFieldBegin("order", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->order);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pref", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->pref);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("flags", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->flags);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("svc", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->svc);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("regexp", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->regexp);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("domainName", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->domainName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DnsQueryResultNAPTR &a, DnsQueryResultNAPTR &b) {
  using ::std::swap;
  swap(a.order, b.order);
  swap(a.pref, b.pref);
  swap(a.flags, b.flags);
  swap(a.svc, b.svc);
  swap(a.regexp, b.regexp);
  swap(a.domainName, b.domainName);
  swap(a.__isset, b.__isset);
}

DnsQueryResultNAPTR::DnsQueryResultNAPTR(const DnsQueryResultNAPTR& other34) {
  order = other34.order;
  pref = other34.pref;
  flags = other34.flags;
  svc = other34.svc;
  regexp = other34.regexp;
  domainName = other34.domainName;
  __isset = other34.__isset;
}
DnsQueryResultNAPTR& DnsQueryResultNAPTR::operator=(const DnsQueryResultNAPTR& other35) {
  order = other35.order;
  pref = other35.pref;
  flags = other35.flags;
  svc = other35.svc;
  regexp = other35.regexp;
  domainName = other35.domainName;
  __isset = other35.__isset;
  return *this;
}
void DnsQueryResultNAPTR::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DnsQueryResultNAPTR(";
  out << "order=" << to_string(order);
  out << ", " << "pref=" << to_string(pref);
  out << ", " << "flags=" << to_string(flags);
  out << ", " << "svc=" << to_string(svc);
  out << ", " << "regexp=" << to_string(regexp);
  out << ", " << "domainName=" << to_string(domainName);
  out << ")";
}


DnsQueryResultMX::~DnsQueryResultMX() throw() {
}


void DnsQueryResultMX::__set_pref(const int16_t val) {
  this->pref = val;
}

void DnsQueryResultMX::__set_domainName(const std::string& val) {
  this->domainName = val;
}

uint32_t DnsQueryResultMX::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->pref);
          this->__isset.pref = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domainName);
          this->__isset.domainName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DnsQueryResultMX::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DnsQueryResultMX");

  xfer += oprot->writeFieldBegin("pref", ::apache::thrift::protocol::T_I16, 1);
  xfer += oprot->writeI16(this->pref);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("domainName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->domainName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DnsQueryResultMX &a, DnsQueryResultMX &b) {
  using ::std::swap;
  swap(a.pref, b.pref);
  swap(a.domainName, b.domainName);
  swap(a.__isset, b.__isset);
}

DnsQueryResultMX::DnsQueryResultMX(const DnsQueryResultMX& other36) {
  pref = other36.pref;
  domainName = other36.domainName;
  __isset = other36.__isset;
}
DnsQueryResultMX& DnsQueryResultMX::operator=(const DnsQueryResultMX& other37) {
  pref = other37.pref;
  domainName = other37.domainName;
  __isset = other37.__isset;
  return *this;
}
void DnsQueryResultMX::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DnsQueryResultMX(";
  out << "pref=" << to_string(pref);
  out << ", " << "domainName=" << to_string(domainName);
  out << ")";
}


DnsQueryResult::~DnsQueryResult() throw() {
}


void DnsQueryResult::__set_a(const std::string& val) {
  this->a = val;
}

void DnsQueryResult::__set_aaaa(const std::string& val) {
  this->aaaa = val;
}

void DnsQueryResult::__set_ns(const std::string& val) {
  this->ns = val;
}

void DnsQueryResult::__set_cname(const std::string& val) {
  this->cname = val;
}

void DnsQueryResult::__set_ptr(const std::string& val) {
  this->ptr = val;
}

void DnsQueryResult::__set_txt(const std::string& val) {
  this->txt = val;
}

void DnsQueryResult::__set_dname(const std::string& val) {
  this->dname = val;
}

void DnsQueryResult::__set_srv(const DnsQueryResultSRV& val) {
  this->srv = val;
}

void DnsQueryResult::__set_naptr(const DnsQueryResultNAPTR& val) {
  this->naptr = val;
}

void DnsQueryResult::__set_mx(const DnsQueryResultMX& val) {
  this->mx = val;
}

uint32_t DnsQueryResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->aaaa);
          this->__isset.aaaa = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cname);
          this->__isset.cname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ptr);
          this->__isset.ptr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->txt);
          this->__isset.txt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dname);
          this->__isset.dname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->srv.read(iprot);
          this->__isset.srv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->naptr.read(iprot);
          this->__isset.naptr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->mx.read(iprot);
          this->__isset.mx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DnsQueryResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DnsQueryResult");

  xfer += oprot->writeFieldBegin("a", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->a);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aaaa", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->aaaa);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->ns);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cname", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->cname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ptr", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->ptr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("txt", ::apache::thrift::protocol::T_STRING, 6);
  xfer += oprot->writeString(this->txt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dname", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->dname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("srv", ::apache::thrift::protocol::T_STRUCT, 8);
  xfer += this->srv.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("naptr", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->naptr.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mx", ::apache::thrift::protocol::T_STRUCT, 10);
  xfer += this->mx.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DnsQueryResult &a, DnsQueryResult &b) {
  using ::std::swap;
  swap(a.a, b.a);
  swap(a.aaaa, b.aaaa);
  swap(a.ns, b.ns);
  swap(a.cname, b.cname);
  swap(a.ptr, b.ptr);
  swap(a.txt, b.txt);
  swap(a.dname, b.dname);
  swap(a.srv, b.srv);
  swap(a.naptr, b.naptr);
  swap(a.mx, b.mx);
  swap(a.__isset, b.__isset);
}

DnsQueryResult::DnsQueryResult(const DnsQueryResult& other38) {
  a = other38.a;
  aaaa = other38.aaaa;
  ns = other38.ns;
  cname = other38.cname;
  ptr = other38.ptr;
  txt = other38.txt;
  dname = other38.dname;
  srv = other38.srv;
  naptr = other38.naptr;
  mx = other38.mx;
  __isset = other38.__isset;
}
DnsQueryResult& DnsQueryResult::operator=(const DnsQueryResult& other39) {
  a = other39.a;
  aaaa = other39.aaaa;
  ns = other39.ns;
  cname = other39.cname;
  ptr = other39.ptr;
  txt = other39.txt;
  dname = other39.dname;
  srv = other39.srv;
  naptr = other39.naptr;
  mx = other39.mx;
  __isset = other39.__isset;
  return *this;
}
void DnsQueryResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DnsQueryResult(";
  out << "a=" << to_string(a);
  out << ", " << "aaaa=" << to_string(aaaa);
  out << ", " << "ns=" << to_string(ns);
  out << ", " << "cname=" << to_string(cname);
  out << ", " << "ptr=" << to_string(ptr);
  out << ", " << "txt=" << to_string(txt);
  out << ", " << "dname=" << to_string(dname);
  out << ", " << "srv=" << to_string(srv);
  out << ", " << "naptr=" << to_string(naptr);
  out << ", " << "mx=" << to_string(mx);
  out << ")";
}


RecordInfo::~RecordInfo() throw() {
}


void RecordInfo::__set_name(const std::string& val) {
  this->name = val;
}

void RecordInfo::__set_viewName(const std::string& val) {
  this->viewName = val;
}

void RecordInfo::__set_zoneName(const std::string& val) {
  this->zoneName = val;
}

void RecordInfo::__set_typ(const int32_t val) {
  this->typ = val;
}

void RecordInfo::__set_result(const DnsQueryResult& val) {
  this->result = val;
}

void RecordInfo::__set_ttl(const int32_t val) {
  this->ttl = val;
__isset.ttl = true;
}

void RecordInfo::__set_weight(const int32_t val) {
  this->weight = val;
__isset.weight = true;
}

void RecordInfo::__set_status(const Status::type val) {
  this->status = val;
__isset.status = true;
}

void RecordInfo::__set_recordId(const std::string& val) {
  this->recordId = val;
}

void RecordInfo::__set_dispatchStatus(const int32_t val) {
  this->dispatchStatus = val;
}

uint32_t RecordInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewName);
          this->__isset.viewName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->zoneName);
          this->__isset.zoneName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->typ);
          this->__isset.typ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->result.read(iprot);
          this->__isset.result = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ttl);
          this->__isset.ttl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->weight);
          this->__isset.weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast40;
          xfer += iprot->readI32(ecast40);
          this->status = (Status::type)ecast40;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->recordId);
          this->__isset.recordId = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->dispatchStatus);
          this->__isset.dispatchStatus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RecordInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RecordInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->viewName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("zoneName", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->zoneName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typ", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->typ);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("result", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->result.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.ttl) {
    xfer += oprot->writeFieldBegin("ttl", ::apache::thrift::protocol::T_I32, 6);
    xfer += oprot->writeI32(this->ttl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.weight) {
    xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_I32, 7);
    xfer += oprot->writeI32(this->weight);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 8);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("recordId", ::apache::thrift::protocol::T_STRING, 9);
  xfer += oprot->writeString(this->recordId);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dispatchStatus", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->dispatchStatus);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RecordInfo &a, RecordInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.viewName, b.viewName);
  swap(a.zoneName, b.zoneName);
  swap(a.typ, b.typ);
  swap(a.result, b.result);
  swap(a.ttl, b.ttl);
  swap(a.weight, b.weight);
  swap(a.status, b.status);
  swap(a.recordId, b.recordId);
  swap(a.dispatchStatus, b.dispatchStatus);
  swap(a.__isset, b.__isset);
}

RecordInfo::RecordInfo(const RecordInfo& other41) {
  name = other41.name;
  viewName = other41.viewName;
  zoneName = other41.zoneName;
  typ = other41.typ;
  result = other41.result;
  ttl = other41.ttl;
  weight = other41.weight;
  status = other41.status;
  recordId = other41.recordId;
  dispatchStatus = other41.dispatchStatus;
  __isset = other41.__isset;
}
RecordInfo& RecordInfo::operator=(const RecordInfo& other42) {
  name = other42.name;
  viewName = other42.viewName;
  zoneName = other42.zoneName;
  typ = other42.typ;
  result = other42.result;
  ttl = other42.ttl;
  weight = other42.weight;
  status = other42.status;
  recordId = other42.recordId;
  dispatchStatus = other42.dispatchStatus;
  __isset = other42.__isset;
  return *this;
}
void RecordInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RecordInfo(";
  out << "name=" << to_string(name);
  out << ", " << "viewName=" << to_string(viewName);
  out << ", " << "zoneName=" << to_string(zoneName);
  out << ", " << "typ=" << to_string(typ);
  out << ", " << "result=" << to_string(result);
  out << ", " << "ttl="; (__isset.ttl ? (out << to_string(ttl)) : (out << "<null>"));
  out << ", " << "weight="; (__isset.weight ? (out << to_string(weight)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ", " << "recordId=" << to_string(recordId);
  out << ", " << "dispatchStatus=" << to_string(dispatchStatus);
  out << ")";
}


ProxyServer::~ProxyServer() throw() {
}


void ProxyServer::__set_ip(const IpAddr& val) {
  this->ip = val;
}

void ProxyServer::__set_weight(const int32_t val) {
  this->weight = val;
}

void ProxyServer::__set_status(const Status::type val) {
  this->status = val;
}

uint32_t ProxyServer::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ip.read(iprot);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->weight);
          this->__isset.weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast43;
          xfer += iprot->readI32(ecast43);
          this->status = (Status::type)ecast43;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ProxyServer::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ProxyServer");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->ip.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->weight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ProxyServer &a, ProxyServer &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.weight, b.weight);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

ProxyServer::ProxyServer(const ProxyServer& other44) {
  ip = other44.ip;
  weight = other44.weight;
  status = other44.status;
  __isset = other44.__isset;
}
ProxyServer& ProxyServer::operator=(const ProxyServer& other45) {
  ip = other45.ip;
  weight = other45.weight;
  status = other45.status;
  __isset = other45.__isset;
  return *this;
}
void ProxyServer::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ProxyServer(";
  out << "ip=" << to_string(ip);
  out << ", " << "weight=" << to_string(weight);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


RecurForwardPolicyInfo::~RecurForwardPolicyInfo() throw() {
}


void RecurForwardPolicyInfo::__set_viewName(const std::string& val) {
  this->viewName = val;
}

void RecurForwardPolicyInfo::__set_domain(const DomainInfo& val) {
  this->domain = val;
}

void RecurForwardPolicyInfo::__set_serverGroupName(const std::string& val) {
  this->serverGroupName = val;
__isset.serverGroupName = true;
}

void RecurForwardPolicyInfo::__set_type(const int32_t val) {
  this->type = val;
}

void RecurForwardPolicyInfo::__set_esc_zone(const int32_t val) {
  this->esc_zone = val;
}

uint32_t RecurForwardPolicyInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewName);
          this->__isset.viewName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->domain.read(iprot);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serverGroupName);
          this->__isset.serverGroupName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->esc_zone);
          this->__isset.esc_zone = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RecurForwardPolicyInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RecurForwardPolicyInfo");

  xfer += oprot->writeFieldBegin("viewName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->viewName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->domain.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.serverGroupName) {
    xfer += oprot->writeFieldBegin("serverGroupName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->serverGroupName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("esc_zone", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->esc_zone);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RecurForwardPolicyInfo &a, RecurForwardPolicyInfo &b) {
  using ::std::swap;
  swap(a.viewName, b.viewName);
  swap(a.domain, b.domain);
  swap(a.serverGroupName, b.serverGroupName);
  swap(a.type, b.type);
  swap(a.esc_zone, b.esc_zone);
  swap(a.__isset, b.__isset);
}

RecurForwardPolicyInfo::RecurForwardPolicyInfo(const RecurForwardPolicyInfo& other46) {
  viewName = other46.viewName;
  domain = other46.domain;
  serverGroupName = other46.serverGroupName;
  type = other46.type;
  esc_zone = other46.esc_zone;
  __isset = other46.__isset;
}
RecurForwardPolicyInfo& RecurForwardPolicyInfo::operator=(const RecurForwardPolicyInfo& other47) {
  viewName = other47.viewName;
  domain = other47.domain;
  serverGroupName = other47.serverGroupName;
  type = other47.type;
  esc_zone = other47.esc_zone;
  __isset = other47.__isset;
  return *this;
}
void RecurForwardPolicyInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RecurForwardPolicyInfo(";
  out << "viewName=" << to_string(viewName);
  out << ", " << "domain=" << to_string(domain);
  out << ", " << "serverGroupName="; (__isset.serverGroupName ? (out << to_string(serverGroupName)) : (out << "<null>"));
  out << ", " << "type=" << to_string(type);
  out << ", " << "esc_zone=" << to_string(esc_zone);
  out << ")";
}


ProxyPolicyInfo::~ProxyPolicyInfo() throw() {
}


void ProxyPolicyInfo::__set_viewName(const std::string& val) {
  this->viewName = val;
}

void ProxyPolicyInfo::__set_domain(const DomainInfo& val) {
  this->domain = val;
}

void ProxyPolicyInfo::__set_serverGroupName(const std::string& val) {
  this->serverGroupName = val;
__isset.serverGroupName = true;
}

uint32_t ProxyPolicyInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewName);
          this->__isset.viewName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->domain.read(iprot);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serverGroupName);
          this->__isset.serverGroupName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ProxyPolicyInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ProxyPolicyInfo");

  xfer += oprot->writeFieldBegin("viewName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->viewName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->domain.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.serverGroupName) {
    xfer += oprot->writeFieldBegin("serverGroupName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->serverGroupName);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ProxyPolicyInfo &a, ProxyPolicyInfo &b) {
  using ::std::swap;
  swap(a.viewName, b.viewName);
  swap(a.domain, b.domain);
  swap(a.serverGroupName, b.serverGroupName);
  swap(a.__isset, b.__isset);
}

ProxyPolicyInfo::ProxyPolicyInfo(const ProxyPolicyInfo& other48) {
  viewName = other48.viewName;
  domain = other48.domain;
  serverGroupName = other48.serverGroupName;
  __isset = other48.__isset;
}
ProxyPolicyInfo& ProxyPolicyInfo::operator=(const ProxyPolicyInfo& other49) {
  viewName = other49.viewName;
  domain = other49.domain;
  serverGroupName = other49.serverGroupName;
  __isset = other49.__isset;
  return *this;
}
void ProxyPolicyInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ProxyPolicyInfo(";
  out << "viewName=" << to_string(viewName);
  out << ", " << "domain=" << to_string(domain);
  out << ", " << "serverGroupName="; (__isset.serverGroupName ? (out << to_string(serverGroupName)) : (out << "<null>"));
  out << ")";
}


TtlPolicyInfo::~TtlPolicyInfo() throw() {
}


void TtlPolicyInfo::__set_domain(const DomainInfo& val) {
  this->domain = val;
}

void TtlPolicyInfo::__set_minTtl(const int32_t val) {
  this->minTtl = val;
__isset.minTtl = true;
}

void TtlPolicyInfo::__set_maxTtl(const int32_t val) {
  this->maxTtl = val;
__isset.maxTtl = true;
}

uint32_t TtlPolicyInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->domain.read(iprot);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->minTtl);
          this->__isset.minTtl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->maxTtl);
          this->__isset.maxTtl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TtlPolicyInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TtlPolicyInfo");

  xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->domain.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.minTtl) {
    xfer += oprot->writeFieldBegin("minTtl", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32(this->minTtl);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.maxTtl) {
    xfer += oprot->writeFieldBegin("maxTtl", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->maxTtl);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TtlPolicyInfo &a, TtlPolicyInfo &b) {
  using ::std::swap;
  swap(a.domain, b.domain);
  swap(a.minTtl, b.minTtl);
  swap(a.maxTtl, b.maxTtl);
  swap(a.__isset, b.__isset);
}

TtlPolicyInfo::TtlPolicyInfo(const TtlPolicyInfo& other50) {
  domain = other50.domain;
  minTtl = other50.minTtl;
  maxTtl = other50.maxTtl;
  __isset = other50.__isset;
}
TtlPolicyInfo& TtlPolicyInfo::operator=(const TtlPolicyInfo& other51) {
  domain = other51.domain;
  minTtl = other51.minTtl;
  maxTtl = other51.maxTtl;
  __isset = other51.__isset;
  return *this;
}
void TtlPolicyInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TtlPolicyInfo(";
  out << "domain=" << to_string(domain);
  out << ", " << "minTtl="; (__isset.minTtl ? (out << to_string(minTtl)) : (out << "<null>"));
  out << ", " << "maxTtl="; (__isset.maxTtl ? (out << to_string(maxTtl)) : (out << "<null>"));
  out << ")";
}


ForwardPolicyInfo::~ForwardPolicyInfo() throw() {
}


void ForwardPolicyInfo::__set_ip(const IpAddr& val) {
  this->ip = val;
}

void ForwardPolicyInfo::__set_port(const int16_t val) {
  this->port = val;
}

void ForwardPolicyInfo::__set_weight(const int32_t val) {
  this->weight = val;
__isset.weight = true;
}

void ForwardPolicyInfo::__set_status(const Status::type val) {
  this->status = val;
__isset.status = true;
}

uint32_t ForwardPolicyInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ip.read(iprot);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->weight);
          this->__isset.weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast52;
          xfer += iprot->readI32(ecast52);
          this->status = (Status::type)ecast52;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ForwardPolicyInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ForwardPolicyInfo");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->ip.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I16, 2);
  xfer += oprot->writeI16(this->port);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.weight) {
    xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->weight);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ForwardPolicyInfo &a, ForwardPolicyInfo &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.port, b.port);
  swap(a.weight, b.weight);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

ForwardPolicyInfo::ForwardPolicyInfo(const ForwardPolicyInfo& other53) {
  ip = other53.ip;
  port = other53.port;
  weight = other53.weight;
  status = other53.status;
  __isset = other53.__isset;
}
ForwardPolicyInfo& ForwardPolicyInfo::operator=(const ForwardPolicyInfo& other54) {
  ip = other54.ip;
  port = other54.port;
  weight = other54.weight;
  status = other54.status;
  __isset = other54.__isset;
  return *this;
}
void ForwardPolicyInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ForwardPolicyInfo(";
  out << "ip=" << to_string(ip);
  out << ", " << "port=" << to_string(port);
  out << ", " << "weight="; (__isset.weight ? (out << to_string(weight)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ")";
}


DialRecord::~DialRecord() throw() {
}


void DialRecord::__set_rid(const ObjectId& val) {
  this->rid = val;
}

void DialRecord::__set_ip(const IpAddr& val) {
  this->ip = val;
}

void DialRecord::__set_ttl(const int32_t val) {
  this->ttl = val;
}

void DialRecord::__set_priority(const int32_t val) {
  this->priority = val;
}

void DialRecord::__set_enabled(const bool val) {
  this->enabled = val;
}

uint32_t DialRecord::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->rid);
          this->__isset.rid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ip.read(iprot);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ttl);
          this->__isset.ttl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->priority);
          this->__isset.priority = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enabled);
          this->__isset.enabled = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DialRecord::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DialRecord");

  xfer += oprot->writeFieldBegin("rid", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->rid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->ip.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ttl", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->ttl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("priority", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->priority);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("enabled", ::apache::thrift::protocol::T_BOOL, 5);
  xfer += oprot->writeBool(this->enabled);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DialRecord &a, DialRecord &b) {
  using ::std::swap;
  swap(a.rid, b.rid);
  swap(a.ip, b.ip);
  swap(a.ttl, b.ttl);
  swap(a.priority, b.priority);
  swap(a.enabled, b.enabled);
  swap(a.__isset, b.__isset);
}

DialRecord::DialRecord(const DialRecord& other55) {
  rid = other55.rid;
  ip = other55.ip;
  ttl = other55.ttl;
  priority = other55.priority;
  enabled = other55.enabled;
  __isset = other55.__isset;
}
DialRecord& DialRecord::operator=(const DialRecord& other56) {
  rid = other56.rid;
  ip = other56.ip;
  ttl = other56.ttl;
  priority = other56.priority;
  enabled = other56.enabled;
  __isset = other56.__isset;
  return *this;
}
void DialRecord::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DialRecord(";
  out << "rid=" << to_string(rid);
  out << ", " << "ip=" << to_string(ip);
  out << ", " << "ttl=" << to_string(ttl);
  out << ", " << "priority=" << to_string(priority);
  out << ", " << "enabled=" << to_string(enabled);
  out << ")";
}


HealthGroupInfo::~HealthGroupInfo() throw() {
}


void HealthGroupInfo::__set_zoneName(const std::string& val) {
  this->zoneName = val;
}

void HealthGroupInfo::__set_viewName(const std::string& val) {
  this->viewName = val;
}

void HealthGroupInfo::__set_name(const std::string& val) {
  this->name = val;
}

uint32_t HealthGroupInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->zoneName);
          this->__isset.zoneName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewName);
          this->__isset.viewName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HealthGroupInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HealthGroupInfo");

  xfer += oprot->writeFieldBegin("zoneName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->zoneName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->viewName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HealthGroupInfo &a, HealthGroupInfo &b) {
  using ::std::swap;
  swap(a.zoneName, b.zoneName);
  swap(a.viewName, b.viewName);
  swap(a.name, b.name);
  swap(a.__isset, b.__isset);
}

HealthGroupInfo::HealthGroupInfo(const HealthGroupInfo& other57) {
  zoneName = other57.zoneName;
  viewName = other57.viewName;
  name = other57.name;
  __isset = other57.__isset;
}
HealthGroupInfo& HealthGroupInfo::operator=(const HealthGroupInfo& other58) {
  zoneName = other58.zoneName;
  viewName = other58.viewName;
  name = other58.name;
  __isset = other58.__isset;
  return *this;
}
void HealthGroupInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HealthGroupInfo(";
  out << "zoneName=" << to_string(zoneName);
  out << ", " << "viewName=" << to_string(viewName);
  out << ", " << "name=" << to_string(name);
  out << ")";
}


DialOption::~DialOption() throw() {
}


void DialOption::__set_destUrl(const std::string& val) {
  this->destUrl = val;
}

void DialOption::__set_testMethod(const std::string& val) {
  this->testMethod = val;
}

void DialOption::__set_expectCode(const std::vector<int32_t> & val) {
  this->expectCode = val;
}

void DialOption::__set_expectMatch(const std::string& val) {
  this->expectMatch = val;
}

uint32_t DialOption::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->destUrl);
          this->__isset.destUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->testMethod);
          this->__isset.testMethod = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->expectCode.clear();
            uint32_t _size59;
            ::apache::thrift::protocol::TType _etype62;
            xfer += iprot->readListBegin(_etype62, _size59);
            this->expectCode.resize(_size59);
            uint32_t _i63;
            for (_i63 = 0; _i63 < _size59; ++_i63)
            {
              xfer += iprot->readI32(this->expectCode[_i63]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.expectCode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->expectMatch);
          this->__isset.expectMatch = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DialOption::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DialOption");

  xfer += oprot->writeFieldBegin("destUrl", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->destUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("testMethod", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->testMethod);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expectCode", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_I32, static_cast<uint32_t>(this->expectCode.size()));
    std::vector<int32_t> ::const_iterator _iter64;
    for (_iter64 = this->expectCode.begin(); _iter64 != this->expectCode.end(); ++_iter64)
    {
      xfer += oprot->writeI32((*_iter64));
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("expectMatch", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->expectMatch);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DialOption &a, DialOption &b) {
  using ::std::swap;
  swap(a.destUrl, b.destUrl);
  swap(a.testMethod, b.testMethod);
  swap(a.expectCode, b.expectCode);
  swap(a.expectMatch, b.expectMatch);
  swap(a.__isset, b.__isset);
}

DialOption::DialOption(const DialOption& other65) {
  destUrl = other65.destUrl;
  testMethod = other65.testMethod;
  expectCode = other65.expectCode;
  expectMatch = other65.expectMatch;
  __isset = other65.__isset;
}
DialOption& DialOption::operator=(const DialOption& other66) {
  destUrl = other66.destUrl;
  testMethod = other66.testMethod;
  expectCode = other66.expectCode;
  expectMatch = other66.expectMatch;
  __isset = other66.__isset;
  return *this;
}
void DialOption::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DialOption(";
  out << "destUrl=" << to_string(destUrl);
  out << ", " << "testMethod=" << to_string(testMethod);
  out << ", " << "expectCode=" << to_string(expectCode);
  out << ", " << "expectMatch=" << to_string(expectMatch);
  out << ")";
}


HealthPolicyInfo::~HealthPolicyInfo() throw() {
}


void HealthPolicyInfo::__set_name(const std::string& val) {
  this->name = val;
}

void HealthPolicyInfo::__set_method(const DialMethod::type val) {
  this->method = val;
}

void HealthPolicyInfo::__set_port(const int16_t val) {
  this->port = val;
__isset.port = true;
}

void HealthPolicyInfo::__set_freq(const int32_t val) {
  this->freq = val;
}

void HealthPolicyInfo::__set_times(const int32_t val) {
  this->times = val;
}

void HealthPolicyInfo::__set_passed(const int32_t val) {
  this->passed = val;
}

void HealthPolicyInfo::__set_option(const DialOption& val) {
  this->option = val;
}

uint32_t HealthPolicyInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast67;
          xfer += iprot->readI32(ecast67);
          this->method = (DialMethod::type)ecast67;
          this->__isset.method = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->freq);
          this->__isset.freq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->times);
          this->__isset.times = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->passed);
          this->__isset.passed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->option.read(iprot);
          this->__isset.option = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HealthPolicyInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HealthPolicyInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("method", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->method);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.port) {
    xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I16, 3);
    xfer += oprot->writeI16(this->port);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldBegin("freq", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->freq);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("times", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->times);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("passed", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->passed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("option", ::apache::thrift::protocol::T_STRUCT, 7);
  xfer += this->option.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HealthPolicyInfo &a, HealthPolicyInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.method, b.method);
  swap(a.port, b.port);
  swap(a.freq, b.freq);
  swap(a.times, b.times);
  swap(a.passed, b.passed);
  swap(a.option, b.option);
  swap(a.__isset, b.__isset);
}

HealthPolicyInfo::HealthPolicyInfo(const HealthPolicyInfo& other68) {
  name = other68.name;
  method = other68.method;
  port = other68.port;
  freq = other68.freq;
  times = other68.times;
  passed = other68.passed;
  option = other68.option;
  __isset = other68.__isset;
}
HealthPolicyInfo& HealthPolicyInfo::operator=(const HealthPolicyInfo& other69) {
  name = other69.name;
  method = other69.method;
  port = other69.port;
  freq = other69.freq;
  times = other69.times;
  passed = other69.passed;
  option = other69.option;
  __isset = other69.__isset;
  return *this;
}
void HealthPolicyInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HealthPolicyInfo(";
  out << "name=" << to_string(name);
  out << ", " << "method=" << to_string(method);
  out << ", " << "port="; (__isset.port ? (out << to_string(port)) : (out << "<null>"));
  out << ", " << "freq=" << to_string(freq);
  out << ", " << "times=" << to_string(times);
  out << ", " << "passed=" << to_string(passed);
  out << ", " << "option=" << to_string(option);
  out << ")";
}


FilterReportInfo::~FilterReportInfo() throw() {
}


void FilterReportInfo::__set_total(const int32_t val) {
  this->total = val;
}

void FilterReportInfo::__set_exceptIpLimit(const int32_t val) {
  this->exceptIpLimit = val;
}

void FilterReportInfo::__set_exceptUdpLimit(const int32_t val) {
  this->exceptUdpLimit = val;
}

void FilterReportInfo::__set_exceptDnsLimit(const int32_t val) {
  this->exceptDnsLimit = val;
}

void FilterReportInfo::__set_ipLimit(const int32_t val) {
  this->ipLimit = val;
}

void FilterReportInfo::__set_domainLimit(const int32_t val) {
  this->domainLimit = val;
}

void FilterReportInfo::__set_aclLimit(const int32_t val) {
  this->aclLimit = val;
}

void FilterReportInfo::__set_userWhiteLimit(const int32_t val) {
  this->userWhiteLimit = val;
}

void FilterReportInfo::__set_userBlackLimit(const int32_t val) {
  this->userBlackLimit = val;
}

void FilterReportInfo::__set_domainBlackLimit(const int32_t val) {
  this->domainBlackLimit = val;
}

uint32_t FilterReportInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exceptIpLimit);
          this->__isset.exceptIpLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exceptUdpLimit);
          this->__isset.exceptUdpLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->exceptDnsLimit);
          this->__isset.exceptDnsLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ipLimit);
          this->__isset.ipLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->domainLimit);
          this->__isset.domainLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->aclLimit);
          this->__isset.aclLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userWhiteLimit);
          this->__isset.userWhiteLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->userBlackLimit);
          this->__isset.userBlackLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->domainBlackLimit);
          this->__isset.domainBlackLimit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t FilterReportInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FilterReportInfo");

  xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exceptIpLimit", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->exceptIpLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exceptUdpLimit", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->exceptUdpLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("exceptDnsLimit", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->exceptDnsLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ipLimit", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->ipLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("domainLimit", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->domainLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aclLimit", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->aclLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userWhiteLimit", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->userWhiteLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("userBlackLimit", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->userBlackLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("domainBlackLimit", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->domainBlackLimit);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FilterReportInfo &a, FilterReportInfo &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.exceptIpLimit, b.exceptIpLimit);
  swap(a.exceptUdpLimit, b.exceptUdpLimit);
  swap(a.exceptDnsLimit, b.exceptDnsLimit);
  swap(a.ipLimit, b.ipLimit);
  swap(a.domainLimit, b.domainLimit);
  swap(a.aclLimit, b.aclLimit);
  swap(a.userWhiteLimit, b.userWhiteLimit);
  swap(a.userBlackLimit, b.userBlackLimit);
  swap(a.domainBlackLimit, b.domainBlackLimit);
  swap(a.__isset, b.__isset);
}

FilterReportInfo::FilterReportInfo(const FilterReportInfo& other70) {
  total = other70.total;
  exceptIpLimit = other70.exceptIpLimit;
  exceptUdpLimit = other70.exceptUdpLimit;
  exceptDnsLimit = other70.exceptDnsLimit;
  ipLimit = other70.ipLimit;
  domainLimit = other70.domainLimit;
  aclLimit = other70.aclLimit;
  userWhiteLimit = other70.userWhiteLimit;
  userBlackLimit = other70.userBlackLimit;
  domainBlackLimit = other70.domainBlackLimit;
  __isset = other70.__isset;
}
FilterReportInfo& FilterReportInfo::operator=(const FilterReportInfo& other71) {
  total = other71.total;
  exceptIpLimit = other71.exceptIpLimit;
  exceptUdpLimit = other71.exceptUdpLimit;
  exceptDnsLimit = other71.exceptDnsLimit;
  ipLimit = other71.ipLimit;
  domainLimit = other71.domainLimit;
  aclLimit = other71.aclLimit;
  userWhiteLimit = other71.userWhiteLimit;
  userBlackLimit = other71.userBlackLimit;
  domainBlackLimit = other71.domainBlackLimit;
  __isset = other71.__isset;
  return *this;
}
void FilterReportInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FilterReportInfo(";
  out << "total=" << to_string(total);
  out << ", " << "exceptIpLimit=" << to_string(exceptIpLimit);
  out << ", " << "exceptUdpLimit=" << to_string(exceptUdpLimit);
  out << ", " << "exceptDnsLimit=" << to_string(exceptDnsLimit);
  out << ", " << "ipLimit=" << to_string(ipLimit);
  out << ", " << "domainLimit=" << to_string(domainLimit);
  out << ", " << "aclLimit=" << to_string(aclLimit);
  out << ", " << "userWhiteLimit=" << to_string(userWhiteLimit);
  out << ", " << "userBlackLimit=" << to_string(userBlackLimit);
  out << ", " << "domainBlackLimit=" << to_string(domainBlackLimit);
  out << ")";
}


RequestReportInfo::~RequestReportInfo() throw() {
}


void RequestReportInfo::__set_total(const int32_t val) {
  this->total = val;
}

void RequestReportInfo::__set_a(const int32_t val) {
  this->a = val;
}

void RequestReportInfo::__set_aaaa(const int32_t val) {
  this->aaaa = val;
}

void RequestReportInfo::__set_cname(const int32_t val) {
  this->cname = val;
}

void RequestReportInfo::__set_ptr(const int32_t val) {
  this->ptr = val;
}

void RequestReportInfo::__set_txt(const int32_t val) {
  this->txt = val;
}

void RequestReportInfo::__set_srv(const int32_t val) {
  this->srv = val;
}

void RequestReportInfo::__set_naptr(const int32_t val) {
  this->naptr = val;
}

void RequestReportInfo::__set_mx(const int32_t val) {
  this->mx = val;
}

void RequestReportInfo::__set_soa(const int32_t val) {
  this->soa = val;
}

void RequestReportInfo::__set_ns(const int32_t val) {
  this->ns = val;
}

void RequestReportInfo::__set_any(const int32_t val) {
  this->any = val;
}

uint32_t RequestReportInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->a);
          this->__isset.a = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->aaaa);
          this->__isset.aaaa = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cname);
          this->__isset.cname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ptr);
          this->__isset.ptr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->txt);
          this->__isset.txt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->srv);
          this->__isset.srv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->naptr);
          this->__isset.naptr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mx);
          this->__isset.mx = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 10:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->soa);
          this->__isset.soa = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 11:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ns);
          this->__isset.ns = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 12:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->any);
          this->__isset.any = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RequestReportInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RequestReportInfo");

  xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("a", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->a);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("aaaa", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->aaaa);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cname", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->cname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ptr", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->ptr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("txt", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->txt);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("srv", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->srv);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("naptr", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->naptr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mx", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->mx);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("soa", ::apache::thrift::protocol::T_I32, 10);
  xfer += oprot->writeI32(this->soa);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ns", ::apache::thrift::protocol::T_I32, 11);
  xfer += oprot->writeI32(this->ns);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("any", ::apache::thrift::protocol::T_I32, 12);
  xfer += oprot->writeI32(this->any);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RequestReportInfo &a, RequestReportInfo &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.a, b.a);
  swap(a.aaaa, b.aaaa);
  swap(a.cname, b.cname);
  swap(a.ptr, b.ptr);
  swap(a.txt, b.txt);
  swap(a.srv, b.srv);
  swap(a.naptr, b.naptr);
  swap(a.mx, b.mx);
  swap(a.soa, b.soa);
  swap(a.ns, b.ns);
  swap(a.any, b.any);
  swap(a.__isset, b.__isset);
}

RequestReportInfo::RequestReportInfo(const RequestReportInfo& other72) {
  total = other72.total;
  a = other72.a;
  aaaa = other72.aaaa;
  cname = other72.cname;
  ptr = other72.ptr;
  txt = other72.txt;
  srv = other72.srv;
  naptr = other72.naptr;
  mx = other72.mx;
  soa = other72.soa;
  ns = other72.ns;
  any = other72.any;
  __isset = other72.__isset;
}
RequestReportInfo& RequestReportInfo::operator=(const RequestReportInfo& other73) {
  total = other73.total;
  a = other73.a;
  aaaa = other73.aaaa;
  cname = other73.cname;
  ptr = other73.ptr;
  txt = other73.txt;
  srv = other73.srv;
  naptr = other73.naptr;
  mx = other73.mx;
  soa = other73.soa;
  ns = other73.ns;
  any = other73.any;
  __isset = other73.__isset;
  return *this;
}
void RequestReportInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RequestReportInfo(";
  out << "total=" << to_string(total);
  out << ", " << "a=" << to_string(a);
  out << ", " << "aaaa=" << to_string(aaaa);
  out << ", " << "cname=" << to_string(cname);
  out << ", " << "ptr=" << to_string(ptr);
  out << ", " << "txt=" << to_string(txt);
  out << ", " << "srv=" << to_string(srv);
  out << ", " << "naptr=" << to_string(naptr);
  out << ", " << "mx=" << to_string(mx);
  out << ", " << "soa=" << to_string(soa);
  out << ", " << "ns=" << to_string(ns);
  out << ", " << "any=" << to_string(any);
  out << ")";
}


GeneralReportInfo::~GeneralReportInfo() throw() {
}


void GeneralReportInfo::__set_total(const int32_t val) {
  this->total = val;
}

void GeneralReportInfo::__set_noerr(const int32_t val) {
  this->noerr = val;
}

void GeneralReportInfo::__set_servfail(const int32_t val) {
  this->servfail = val;
}

void GeneralReportInfo::__set_nxdomain(const int32_t val) {
  this->nxdomain = val;
}

void GeneralReportInfo::__set_refuse(const int32_t val) {
  this->refuse = val;
}

void GeneralReportInfo::__set_formerr(const int32_t val) {
  this->formerr = val;
}

uint32_t GeneralReportInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->noerr);
          this->__isset.noerr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->servfail);
          this->__isset.servfail = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nxdomain);
          this->__isset.nxdomain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->refuse);
          this->__isset.refuse = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->formerr);
          this->__isset.formerr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t GeneralReportInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("GeneralReportInfo");

  xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("noerr", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->noerr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("servfail", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->servfail);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nxdomain", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->nxdomain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("refuse", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->refuse);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("formerr", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->formerr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(GeneralReportInfo &a, GeneralReportInfo &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.noerr, b.noerr);
  swap(a.servfail, b.servfail);
  swap(a.nxdomain, b.nxdomain);
  swap(a.refuse, b.refuse);
  swap(a.formerr, b.formerr);
  swap(a.__isset, b.__isset);
}

GeneralReportInfo::GeneralReportInfo(const GeneralReportInfo& other74) {
  total = other74.total;
  noerr = other74.noerr;
  servfail = other74.servfail;
  nxdomain = other74.nxdomain;
  refuse = other74.refuse;
  formerr = other74.formerr;
  __isset = other74.__isset;
}
GeneralReportInfo& GeneralReportInfo::operator=(const GeneralReportInfo& other75) {
  total = other75.total;
  noerr = other75.noerr;
  servfail = other75.servfail;
  nxdomain = other75.nxdomain;
  refuse = other75.refuse;
  formerr = other75.formerr;
  __isset = other75.__isset;
  return *this;
}
void GeneralReportInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "GeneralReportInfo(";
  out << "total=" << to_string(total);
  out << ", " << "noerr=" << to_string(noerr);
  out << ", " << "servfail=" << to_string(servfail);
  out << ", " << "nxdomain=" << to_string(nxdomain);
  out << ", " << "refuse=" << to_string(refuse);
  out << ", " << "formerr=" << to_string(formerr);
  out << ")";
}


DNameAccessInfo::~DNameAccessInfo() throw() {
}


void DNameAccessInfo::__set_zoneName(const std::string& val) {
  this->zoneName = val;
}

void DNameAccessInfo::__set_viewName(const std::string& val) {
  this->viewName = val;
}

void DNameAccessInfo::__set_domain(const std::string& val) {
  this->domain = val;
}

void DNameAccessInfo::__set_access(const int32_t val) {
  this->access = val;
}

void DNameAccessInfo::__set_rcode(const GeneralReportInfo& val) {
  this->rcode = val;
}

void DNameAccessInfo::__set_qtype(const RequestReportInfo& val) {
  this->qtype = val;
}

uint32_t DNameAccessInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->zoneName);
          this->__isset.zoneName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewName);
          this->__isset.viewName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->access);
          this->__isset.access = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->rcode.read(iprot);
          this->__isset.rcode = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->qtype.read(iprot);
          this->__isset.qtype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DNameAccessInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DNameAccessInfo");

  xfer += oprot->writeFieldBegin("zoneName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->zoneName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->viewName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->domain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("access", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->access);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("rcode", ::apache::thrift::protocol::T_STRUCT, 5);
  xfer += this->rcode.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qtype", ::apache::thrift::protocol::T_STRUCT, 6);
  xfer += this->qtype.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DNameAccessInfo &a, DNameAccessInfo &b) {
  using ::std::swap;
  swap(a.zoneName, b.zoneName);
  swap(a.viewName, b.viewName);
  swap(a.domain, b.domain);
  swap(a.access, b.access);
  swap(a.rcode, b.rcode);
  swap(a.qtype, b.qtype);
  swap(a.__isset, b.__isset);
}

DNameAccessInfo::DNameAccessInfo(const DNameAccessInfo& other76) {
  zoneName = other76.zoneName;
  viewName = other76.viewName;
  domain = other76.domain;
  access = other76.access;
  rcode = other76.rcode;
  qtype = other76.qtype;
  __isset = other76.__isset;
}
DNameAccessInfo& DNameAccessInfo::operator=(const DNameAccessInfo& other77) {
  zoneName = other77.zoneName;
  viewName = other77.viewName;
  domain = other77.domain;
  access = other77.access;
  rcode = other77.rcode;
  qtype = other77.qtype;
  __isset = other77.__isset;
  return *this;
}
void DNameAccessInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DNameAccessInfo(";
  out << "zoneName=" << to_string(zoneName);
  out << ", " << "viewName=" << to_string(viewName);
  out << ", " << "domain=" << to_string(domain);
  out << ", " << "access=" << to_string(access);
  out << ", " << "rcode=" << to_string(rcode);
  out << ", " << "qtype=" << to_string(qtype);
  out << ")";
}


XProxyReportInfo::~XProxyReportInfo() throw() {
}


void XProxyReportInfo::__set_total(const int32_t val) {
  this->total = val;
}

void XProxyReportInfo::__set_proxyRequest(const int32_t val) {
  this->proxyRequest = val;
}

void XProxyReportInfo::__set_proxyAnswer(const int32_t val) {
  this->proxyAnswer = val;
}

void XProxyReportInfo::__set_proxyForwardRequest(const int32_t val) {
  this->proxyForwardRequest = val;
}

void XProxyReportInfo::__set_proxyForwardAnswer(const int32_t val) {
  this->proxyForwardAnswer = val;
}

uint32_t XProxyReportInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->proxyRequest);
          this->__isset.proxyRequest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->proxyAnswer);
          this->__isset.proxyAnswer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->proxyForwardRequest);
          this->__isset.proxyForwardRequest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->proxyForwardAnswer);
          this->__isset.proxyForwardAnswer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t XProxyReportInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("XProxyReportInfo");

  xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("proxyRequest", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->proxyRequest);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("proxyAnswer", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->proxyAnswer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("proxyForwardRequest", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->proxyForwardRequest);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("proxyForwardAnswer", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->proxyForwardAnswer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(XProxyReportInfo &a, XProxyReportInfo &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.proxyRequest, b.proxyRequest);
  swap(a.proxyAnswer, b.proxyAnswer);
  swap(a.proxyForwardRequest, b.proxyForwardRequest);
  swap(a.proxyForwardAnswer, b.proxyForwardAnswer);
  swap(a.__isset, b.__isset);
}

XProxyReportInfo::XProxyReportInfo(const XProxyReportInfo& other78) {
  total = other78.total;
  proxyRequest = other78.proxyRequest;
  proxyAnswer = other78.proxyAnswer;
  proxyForwardRequest = other78.proxyForwardRequest;
  proxyForwardAnswer = other78.proxyForwardAnswer;
  __isset = other78.__isset;
}
XProxyReportInfo& XProxyReportInfo::operator=(const XProxyReportInfo& other79) {
  total = other79.total;
  proxyRequest = other79.proxyRequest;
  proxyAnswer = other79.proxyAnswer;
  proxyForwardRequest = other79.proxyForwardRequest;
  proxyForwardAnswer = other79.proxyForwardAnswer;
  __isset = other79.__isset;
  return *this;
}
void XProxyReportInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "XProxyReportInfo(";
  out << "total=" << to_string(total);
  out << ", " << "proxyRequest=" << to_string(proxyRequest);
  out << ", " << "proxyAnswer=" << to_string(proxyAnswer);
  out << ", " << "proxyForwardRequest=" << to_string(proxyForwardRequest);
  out << ", " << "proxyForwardAnswer=" << to_string(proxyForwardAnswer);
  out << ")";
}


XForwardReportInfo::~XForwardReportInfo() throw() {
}


void XForwardReportInfo::__set_total(const int32_t val) {
  this->total = val;
}

void XForwardReportInfo::__set_xforwardRequest(const int32_t val) {
  this->xforwardRequest = val;
}

void XForwardReportInfo::__set_xforwardAnswer(const int32_t val) {
  this->xforwardAnswer = val;
}

uint32_t XForwardReportInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->xforwardRequest);
          this->__isset.xforwardRequest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->xforwardAnswer);
          this->__isset.xforwardAnswer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t XForwardReportInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("XForwardReportInfo");

  xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xforwardRequest", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->xforwardRequest);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("xforwardAnswer", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->xforwardAnswer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(XForwardReportInfo &a, XForwardReportInfo &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.xforwardRequest, b.xforwardRequest);
  swap(a.xforwardAnswer, b.xforwardAnswer);
  swap(a.__isset, b.__isset);
}

XForwardReportInfo::XForwardReportInfo(const XForwardReportInfo& other80) {
  total = other80.total;
  xforwardRequest = other80.xforwardRequest;
  xforwardAnswer = other80.xforwardAnswer;
  __isset = other80.__isset;
}
XForwardReportInfo& XForwardReportInfo::operator=(const XForwardReportInfo& other81) {
  total = other81.total;
  xforwardRequest = other81.xforwardRequest;
  xforwardAnswer = other81.xforwardAnswer;
  __isset = other81.__isset;
  return *this;
}
void XForwardReportInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "XForwardReportInfo(";
  out << "total=" << to_string(total);
  out << ", " << "xforwardRequest=" << to_string(xforwardRequest);
  out << ", " << "xforwardAnswer=" << to_string(xforwardAnswer);
  out << ")";
}


RecursiveReportInfo::~RecursiveReportInfo() throw() {
}


void RecursiveReportInfo::__set_total(const int32_t val) {
  this->total = val;
}

void RecursiveReportInfo::__set_recursiveRequest(const int32_t val) {
  this->recursiveRequest = val;
}

void RecursiveReportInfo::__set_recursiveAnswer(const int32_t val) {
  this->recursiveAnswer = val;
}

uint32_t RecursiveReportInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->recursiveRequest);
          this->__isset.recursiveRequest = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->recursiveAnswer);
          this->__isset.recursiveAnswer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RecursiveReportInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RecursiveReportInfo");

  xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("recursiveRequest", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->recursiveRequest);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("recursiveAnswer", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->recursiveAnswer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RecursiveReportInfo &a, RecursiveReportInfo &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.recursiveRequest, b.recursiveRequest);
  swap(a.recursiveAnswer, b.recursiveAnswer);
  swap(a.__isset, b.__isset);
}

RecursiveReportInfo::RecursiveReportInfo(const RecursiveReportInfo& other82) {
  total = other82.total;
  recursiveRequest = other82.recursiveRequest;
  recursiveAnswer = other82.recursiveAnswer;
  __isset = other82.__isset;
}
RecursiveReportInfo& RecursiveReportInfo::operator=(const RecursiveReportInfo& other83) {
  total = other83.total;
  recursiveRequest = other83.recursiveRequest;
  recursiveAnswer = other83.recursiveAnswer;
  __isset = other83.__isset;
  return *this;
}
void RecursiveReportInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RecursiveReportInfo(";
  out << "total=" << to_string(total);
  out << ", " << "recursiveRequest=" << to_string(recursiveRequest);
  out << ", " << "recursiveAnswer=" << to_string(recursiveAnswer);
  out << ")";
}


BackGroundReportInfo::~BackGroundReportInfo() throw() {
}


void BackGroundReportInfo::__set_total(const int32_t val) {
  this->total = val;
}

void BackGroundReportInfo::__set_smartUpdate(const int32_t val) {
  this->smartUpdate = val;
}

void BackGroundReportInfo::__set_cacheUpdate(const int32_t val) {
  this->cacheUpdate = val;
}

void BackGroundReportInfo::__set_limitDrop(const int32_t val) {
  this->limitDrop = val;
}

void BackGroundReportInfo::__set_ttlExpire(const int32_t val) {
  this->ttlExpire = val;
}

uint32_t BackGroundReportInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->total);
          this->__isset.total = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->smartUpdate);
          this->__isset.smartUpdate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cacheUpdate);
          this->__isset.cacheUpdate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->limitDrop);
          this->__isset.limitDrop = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ttlExpire);
          this->__isset.ttlExpire = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t BackGroundReportInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("BackGroundReportInfo");

  xfer += oprot->writeFieldBegin("total", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->total);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("smartUpdate", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->smartUpdate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cacheUpdate", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->cacheUpdate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("limitDrop", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->limitDrop);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ttlExpire", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->ttlExpire);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(BackGroundReportInfo &a, BackGroundReportInfo &b) {
  using ::std::swap;
  swap(a.total, b.total);
  swap(a.smartUpdate, b.smartUpdate);
  swap(a.cacheUpdate, b.cacheUpdate);
  swap(a.limitDrop, b.limitDrop);
  swap(a.ttlExpire, b.ttlExpire);
  swap(a.__isset, b.__isset);
}

BackGroundReportInfo::BackGroundReportInfo(const BackGroundReportInfo& other84) {
  total = other84.total;
  smartUpdate = other84.smartUpdate;
  cacheUpdate = other84.cacheUpdate;
  limitDrop = other84.limitDrop;
  ttlExpire = other84.ttlExpire;
  __isset = other84.__isset;
}
BackGroundReportInfo& BackGroundReportInfo::operator=(const BackGroundReportInfo& other85) {
  total = other85.total;
  smartUpdate = other85.smartUpdate;
  cacheUpdate = other85.cacheUpdate;
  limitDrop = other85.limitDrop;
  ttlExpire = other85.ttlExpire;
  __isset = other85.__isset;
  return *this;
}
void BackGroundReportInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "BackGroundReportInfo(";
  out << "total=" << to_string(total);
  out << ", " << "smartUpdate=" << to_string(smartUpdate);
  out << ", " << "cacheUpdate=" << to_string(cacheUpdate);
  out << ", " << "limitDrop=" << to_string(limitDrop);
  out << ", " << "ttlExpire=" << to_string(ttlExpire);
  out << ")";
}


TopnIpInfo::~TopnIpInfo() throw() {
}


void TopnIpInfo::__set_ip(const std::string& val) {
  this->ip = val;
}

void TopnIpInfo::__set_access(const int32_t val) {
  this->access = val;
}

uint32_t TopnIpInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->access);
          this->__isset.access = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TopnIpInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TopnIpInfo");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("access", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->access);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TopnIpInfo &a, TopnIpInfo &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.access, b.access);
  swap(a.__isset, b.__isset);
}

TopnIpInfo::TopnIpInfo(const TopnIpInfo& other86) {
  ip = other86.ip;
  access = other86.access;
  __isset = other86.__isset;
}
TopnIpInfo& TopnIpInfo::operator=(const TopnIpInfo& other87) {
  ip = other87.ip;
  access = other87.access;
  __isset = other87.__isset;
  return *this;
}
void TopnIpInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TopnIpInfo(";
  out << "ip=" << to_string(ip);
  out << ", " << "access=" << to_string(access);
  out << ")";
}


TopnDomainInfo::~TopnDomainInfo() throw() {
}


void TopnDomainInfo::__set_domain(const std::string& val) {
  this->domain = val;
}

void TopnDomainInfo::__set_access(const int32_t val) {
  this->access = val;
}

uint32_t TopnDomainInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->access);
          this->__isset.access = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TopnDomainInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TopnDomainInfo");

  xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->domain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("access", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->access);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TopnDomainInfo &a, TopnDomainInfo &b) {
  using ::std::swap;
  swap(a.domain, b.domain);
  swap(a.access, b.access);
  swap(a.__isset, b.__isset);
}

TopnDomainInfo::TopnDomainInfo(const TopnDomainInfo& other88) {
  domain = other88.domain;
  access = other88.access;
  __isset = other88.__isset;
}
TopnDomainInfo& TopnDomainInfo::operator=(const TopnDomainInfo& other89) {
  domain = other89.domain;
  access = other89.access;
  __isset = other89.__isset;
  return *this;
}
void TopnDomainInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TopnDomainInfo(";
  out << "domain=" << to_string(domain);
  out << ", " << "access=" << to_string(access);
  out << ")";
}


TopnDnameInfo::~TopnDnameInfo() throw() {
}


void TopnDnameInfo::__set_dname(const std::string& val) {
  this->dname = val;
}

void TopnDnameInfo::__set_access(const int32_t val) {
  this->access = val;
}

uint32_t TopnDnameInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dname);
          this->__isset.dname = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->access);
          this->__isset.access = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t TopnDnameInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("TopnDnameInfo");

  xfer += oprot->writeFieldBegin("dname", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->dname);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("access", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->access);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(TopnDnameInfo &a, TopnDnameInfo &b) {
  using ::std::swap;
  swap(a.dname, b.dname);
  swap(a.access, b.access);
  swap(a.__isset, b.__isset);
}

TopnDnameInfo::TopnDnameInfo(const TopnDnameInfo& other90) {
  dname = other90.dname;
  access = other90.access;
  __isset = other90.__isset;
}
TopnDnameInfo& TopnDnameInfo::operator=(const TopnDnameInfo& other91) {
  dname = other91.dname;
  access = other91.access;
  __isset = other91.__isset;
  return *this;
}
void TopnDnameInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "TopnDnameInfo(";
  out << "dname=" << to_string(dname);
  out << ", " << "access=" << to_string(access);
  out << ")";
}


DDosInfo::~DDosInfo() throw() {
}


void DDosInfo::__set_ip(const std::string& val) {
  this->ip = val;
}

void DDosInfo::__set_domain(const std::string& val) {
  this->domain = val;
}

void DDosInfo::__set_access(const int32_t val) {
  this->access = val;
}

uint32_t DDosInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ip);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->access);
          this->__isset.access = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DDosInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DDosInfo");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->ip);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->domain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("access", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->access);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DDosInfo &a, DDosInfo &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.domain, b.domain);
  swap(a.access, b.access);
  swap(a.__isset, b.__isset);
}

DDosInfo::DDosInfo(const DDosInfo& other92) {
  ip = other92.ip;
  domain = other92.domain;
  access = other92.access;
  __isset = other92.__isset;
}
DDosInfo& DDosInfo::operator=(const DDosInfo& other93) {
  ip = other93.ip;
  domain = other93.domain;
  access = other93.access;
  __isset = other93.__isset;
  return *this;
}
void DDosInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DDosInfo(";
  out << "ip=" << to_string(ip);
  out << ", " << "domain=" << to_string(domain);
  out << ", " << "access=" << to_string(access);
  out << ")";
}


HostInfo::~HostInfo() throw() {
}


void HostInfo::__set_cpu(const int32_t val) {
  this->cpu = val;
}

void HostInfo::__set_memory(const int32_t val) {
  this->memory = val;
}

void HostInfo::__set_nicin(const int32_t val) {
  this->nicin = val;
}

void HostInfo::__set_nicout(const int32_t val) {
  this->nicout = val;
}

uint32_t HostInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cpu);
          this->__isset.cpu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->memory);
          this->__isset.memory = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nicin);
          this->__isset.nicin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->nicout);
          this->__isset.nicout = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HostInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HostInfo");

  xfer += oprot->writeFieldBegin("cpu", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cpu);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("memory", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->memory);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nicin", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->nicin);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nicout", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->nicout);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HostInfo &a, HostInfo &b) {
  using ::std::swap;
  swap(a.cpu, b.cpu);
  swap(a.memory, b.memory);
  swap(a.nicin, b.nicin);
  swap(a.nicout, b.nicout);
  swap(a.__isset, b.__isset);
}

HostInfo::HostInfo(const HostInfo& other94) {
  cpu = other94.cpu;
  memory = other94.memory;
  nicin = other94.nicin;
  nicout = other94.nicout;
  __isset = other94.__isset;
}
HostInfo& HostInfo::operator=(const HostInfo& other95) {
  cpu = other95.cpu;
  memory = other95.memory;
  nicin = other95.nicin;
  nicout = other95.nicout;
  __isset = other95.__isset;
  return *this;
}
void HostInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HostInfo(";
  out << "cpu=" << to_string(cpu);
  out << ", " << "memory=" << to_string(memory);
  out << ", " << "nicin=" << to_string(nicin);
  out << ", " << "nicout=" << to_string(nicout);
  out << ")";
}


HeartBeatState::~HeartBeatState() throw() {
}


void HeartBeatState::__set_mState(const ModuleState::type val) {
  this->mState = val;
}

void HeartBeatState::__set_serverState(const bool val) {
  this->serverState = val;
}

uint32_t HeartBeatState::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast96;
          xfer += iprot->readI32(ecast96);
          this->mState = (ModuleState::type)ecast96;
          this->__isset.mState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->serverState);
          this->__isset.serverState = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t HeartBeatState::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("HeartBeatState");

  xfer += oprot->writeFieldBegin("mState", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32((int32_t)this->mState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("serverState", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->serverState);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(HeartBeatState &a, HeartBeatState &b) {
  using ::std::swap;
  swap(a.mState, b.mState);
  swap(a.serverState, b.serverState);
  swap(a.__isset, b.__isset);
}

HeartBeatState::HeartBeatState(const HeartBeatState& other97) {
  mState = other97.mState;
  serverState = other97.serverState;
  __isset = other97.__isset;
}
HeartBeatState& HeartBeatState::operator=(const HeartBeatState& other98) {
  mState = other98.mState;
  serverState = other98.serverState;
  __isset = other98.__isset;
  return *this;
}
void HeartBeatState::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "HeartBeatState(";
  out << "mState=" << to_string(mState);
  out << ", " << "serverState=" << to_string(serverState);
  out << ")";
}


IpOverAlarm::~IpOverAlarm() throw() {
}


void IpOverAlarm::__set_ip(const IpAddr& val) {
  this->ip = val;
}

void IpOverAlarm::__set_qps(const int32_t val) {
  this->qps = val;
}

void IpOverAlarm::__set_status(const AlarmStatus::type val) {
  this->status = val;
}

uint32_t IpOverAlarm::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ip.read(iprot);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qps);
          this->__isset.qps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast99;
          xfer += iprot->readI32(ecast99);
          this->status = (AlarmStatus::type)ecast99;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IpOverAlarm::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IpOverAlarm");

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->ip.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qps", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IpOverAlarm &a, IpOverAlarm &b) {
  using ::std::swap;
  swap(a.ip, b.ip);
  swap(a.qps, b.qps);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

IpOverAlarm::IpOverAlarm(const IpOverAlarm& other100) {
  ip = other100.ip;
  qps = other100.qps;
  status = other100.status;
  __isset = other100.__isset;
}
IpOverAlarm& IpOverAlarm::operator=(const IpOverAlarm& other101) {
  ip = other101.ip;
  qps = other101.qps;
  status = other101.status;
  __isset = other101.__isset;
  return *this;
}
void IpOverAlarm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IpOverAlarm(";
  out << "ip=" << to_string(ip);
  out << ", " << "qps=" << to_string(qps);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


DomainOverAlarm::~DomainOverAlarm() throw() {
}


void DomainOverAlarm::__set_domain(const std::string& val) {
  this->domain = val;
}

void DomainOverAlarm::__set_qps(const int32_t val) {
  this->qps = val;
}

void DomainOverAlarm::__set_status(const AlarmStatus::type val) {
  this->status = val;
}

uint32_t DomainOverAlarm::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->domain);
          this->__isset.domain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->qps);
          this->__isset.qps = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast102;
          xfer += iprot->readI32(ecast102);
          this->status = (AlarmStatus::type)ecast102;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DomainOverAlarm::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DomainOverAlarm");

  xfer += oprot->writeFieldBegin("domain", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->domain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qps", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->qps);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DomainOverAlarm &a, DomainOverAlarm &b) {
  using ::std::swap;
  swap(a.domain, b.domain);
  swap(a.qps, b.qps);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

DomainOverAlarm::DomainOverAlarm(const DomainOverAlarm& other103) {
  domain = other103.domain;
  qps = other103.qps;
  status = other103.status;
  __isset = other103.__isset;
}
DomainOverAlarm& DomainOverAlarm::operator=(const DomainOverAlarm& other104) {
  domain = other104.domain;
  qps = other104.qps;
  status = other104.status;
  __isset = other104.__isset;
  return *this;
}
void DomainOverAlarm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DomainOverAlarm(";
  out << "domain=" << to_string(domain);
  out << ", " << "qps=" << to_string(qps);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


NginxServerAlarm::~NginxServerAlarm() throw() {
}


void NginxServerAlarm::__set_serverName(const std::string& val) {
  this->serverName = val;
}

void NginxServerAlarm::__set_localUrl(const std::string& val) {
  this->localUrl = val;
}

void NginxServerAlarm::__set_status(const AlarmStatus::type val) {
  this->status = val;
}

uint32_t NginxServerAlarm::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->serverName);
          this->__isset.serverName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->localUrl);
          this->__isset.localUrl = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast105;
          xfer += iprot->readI32(ecast105);
          this->status = (AlarmStatus::type)ecast105;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NginxServerAlarm::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NginxServerAlarm");

  xfer += oprot->writeFieldBegin("serverName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->serverName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("localUrl", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->localUrl);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32((int32_t)this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NginxServerAlarm &a, NginxServerAlarm &b) {
  using ::std::swap;
  swap(a.serverName, b.serverName);
  swap(a.localUrl, b.localUrl);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

NginxServerAlarm::NginxServerAlarm(const NginxServerAlarm& other106) {
  serverName = other106.serverName;
  localUrl = other106.localUrl;
  status = other106.status;
  __isset = other106.__isset;
}
NginxServerAlarm& NginxServerAlarm::operator=(const NginxServerAlarm& other107) {
  serverName = other107.serverName;
  localUrl = other107.localUrl;
  status = other107.status;
  __isset = other107.__isset;
  return *this;
}
void NginxServerAlarm::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NginxServerAlarm(";
  out << "serverName=" << to_string(serverName);
  out << ", " << "localUrl=" << to_string(localUrl);
  out << ", " << "status=" << to_string(status);
  out << ")";
}


ZoneRequestReport::~ZoneRequestReport() throw() {
}


void ZoneRequestReport::__set_zoneName(const std::string& val) {
  this->zoneName = val;
}

void ZoneRequestReport::__set_viewName(const std::string& val) {
  this->viewName = val;
}

void ZoneRequestReport::__set_data(const RequestReportInfo& val) {
  this->data = val;
}

uint32_t ZoneRequestReport::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->zoneName);
          this->__isset.zoneName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewName);
          this->__isset.viewName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ZoneRequestReport::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ZoneRequestReport");

  xfer += oprot->writeFieldBegin("zoneName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->zoneName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->viewName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ZoneRequestReport &a, ZoneRequestReport &b) {
  using ::std::swap;
  swap(a.zoneName, b.zoneName);
  swap(a.viewName, b.viewName);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

ZoneRequestReport::ZoneRequestReport(const ZoneRequestReport& other108) {
  zoneName = other108.zoneName;
  viewName = other108.viewName;
  data = other108.data;
  __isset = other108.__isset;
}
ZoneRequestReport& ZoneRequestReport::operator=(const ZoneRequestReport& other109) {
  zoneName = other109.zoneName;
  viewName = other109.viewName;
  data = other109.data;
  __isset = other109.__isset;
  return *this;
}
void ZoneRequestReport::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ZoneRequestReport(";
  out << "zoneName=" << to_string(zoneName);
  out << ", " << "viewName=" << to_string(viewName);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


ZoneAnswerReport::~ZoneAnswerReport() throw() {
}


void ZoneAnswerReport::__set_zoneName(const std::string& val) {
  this->zoneName = val;
}

void ZoneAnswerReport::__set_viewName(const std::string& val) {
  this->viewName = val;
}

void ZoneAnswerReport::__set_data(const GeneralReportInfo& val) {
  this->data = val;
}

void ZoneAnswerReport::__set_qtype(const RequestReportInfo& val) {
  this->qtype = val;
}

uint32_t ZoneAnswerReport::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->zoneName);
          this->__isset.zoneName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewName);
          this->__isset.viewName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->qtype.read(iprot);
          this->__isset.qtype = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ZoneAnswerReport::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ZoneAnswerReport");

  xfer += oprot->writeFieldBegin("zoneName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->zoneName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("viewName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->viewName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("qtype", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->qtype.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ZoneAnswerReport &a, ZoneAnswerReport &b) {
  using ::std::swap;
  swap(a.zoneName, b.zoneName);
  swap(a.viewName, b.viewName);
  swap(a.data, b.data);
  swap(a.qtype, b.qtype);
  swap(a.__isset, b.__isset);
}

ZoneAnswerReport::ZoneAnswerReport(const ZoneAnswerReport& other110) {
  zoneName = other110.zoneName;
  viewName = other110.viewName;
  data = other110.data;
  qtype = other110.qtype;
  __isset = other110.__isset;
}
ZoneAnswerReport& ZoneAnswerReport::operator=(const ZoneAnswerReport& other111) {
  zoneName = other111.zoneName;
  viewName = other111.viewName;
  data = other111.data;
  qtype = other111.qtype;
  __isset = other111.__isset;
  return *this;
}
void ZoneAnswerReport::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ZoneAnswerReport(";
  out << "zoneName=" << to_string(zoneName);
  out << ", " << "viewName=" << to_string(viewName);
  out << ", " << "data=" << to_string(data);
  out << ", " << "qtype=" << to_string(qtype);
  out << ")";
}


XproxyReport::~XproxyReport() throw() {
}


void XproxyReport::__set_xproxy(const std::string& val) {
  this->xproxy = val;
}

void XproxyReport::__set_data(const XProxyReportInfo& val) {
  this->data = val;
}

uint32_t XproxyReport::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->xproxy);
          this->__isset.xproxy = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t XproxyReport::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("XproxyReport");

  xfer += oprot->writeFieldBegin("xproxy", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->xproxy);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(XproxyReport &a, XproxyReport &b) {
  using ::std::swap;
  swap(a.xproxy, b.xproxy);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

XproxyReport::XproxyReport(const XproxyReport& other112) {
  xproxy = other112.xproxy;
  data = other112.data;
  __isset = other112.__isset;
}
XproxyReport& XproxyReport::operator=(const XproxyReport& other113) {
  xproxy = other113.xproxy;
  data = other113.data;
  __isset = other113.__isset;
  return *this;
}
void XproxyReport::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "XproxyReport(";
  out << "xproxy=" << to_string(xproxy);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


XforwardReport::~XforwardReport() throw() {
}


void XforwardReport::__set_xforward(const std::string& val) {
  this->xforward = val;
}

void XforwardReport::__set_data(const XForwardReportInfo& val) {
  this->data = val;
}

uint32_t XforwardReport::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->xforward);
          this->__isset.xforward = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->data.read(iprot);
          this->__isset.data = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t XforwardReport::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("XforwardReport");

  xfer += oprot->writeFieldBegin("xforward", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->xforward);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("data", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->data.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(XforwardReport &a, XforwardReport &b) {
  using ::std::swap;
  swap(a.xforward, b.xforward);
  swap(a.data, b.data);
  swap(a.__isset, b.__isset);
}

XforwardReport::XforwardReport(const XforwardReport& other114) {
  xforward = other114.xforward;
  data = other114.data;
  __isset = other114.__isset;
}
XforwardReport& XforwardReport::operator=(const XforwardReport& other115) {
  xforward = other115.xforward;
  data = other115.data;
  __isset = other115.__isset;
  return *this;
}
void XforwardReport::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "XforwardReport(";
  out << "xforward=" << to_string(xforward);
  out << ", " << "data=" << to_string(data);
  out << ")";
}


RedirectServerInfo::~RedirectServerInfo() throw() {
}


void RedirectServerInfo::__set_viewName(const std::string& val) {
  this->viewName = val;
}

void RedirectServerInfo::__set_ip(const IpAddr& val) {
  this->ip = val;
}

void RedirectServerInfo::__set_weight(const int32_t val) {
  this->weight = val;
__isset.weight = true;
}

void RedirectServerInfo::__set_status(const Status::type val) {
  this->status = val;
__isset.status = true;
}

uint32_t RedirectServerInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->viewName);
          this->__isset.viewName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ip.read(iprot);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->weight);
          this->__isset.weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast116;
          xfer += iprot->readI32(ecast116);
          this->status = (Status::type)ecast116;
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RedirectServerInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RedirectServerInfo");

  xfer += oprot->writeFieldBegin("viewName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->viewName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->ip.write(oprot);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.weight) {
    xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32(this->weight);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.status) {
    xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32((int32_t)this->status);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RedirectServerInfo &a, RedirectServerInfo &b) {
  using ::std::swap;
  swap(a.viewName, b.viewName);
  swap(a.ip, b.ip);
  swap(a.weight, b.weight);
  swap(a.status, b.status);
  swap(a.__isset, b.__isset);
}

RedirectServerInfo::RedirectServerInfo(const RedirectServerInfo& other117) {
  viewName = other117.viewName;
  ip = other117.ip;
  weight = other117.weight;
  status = other117.status;
  __isset = other117.__isset;
}
RedirectServerInfo& RedirectServerInfo::operator=(const RedirectServerInfo& other118) {
  viewName = other118.viewName;
  ip = other118.ip;
  weight = other118.weight;
  status = other118.status;
  __isset = other118.__isset;
  return *this;
}
void RedirectServerInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RedirectServerInfo(";
  out << "viewName=" << to_string(viewName);
  out << ", " << "ip=" << to_string(ip);
  out << ", " << "weight="; (__isset.weight ? (out << to_string(weight)) : (out << "<null>"));
  out << ", " << "status="; (__isset.status ? (out << to_string(status)) : (out << "<null>"));
  out << ")";
}


NginxProxyInfo::~NginxProxyInfo() throw() {
}


void NginxProxyInfo::__set_proxyDomain(const std::string& val) {
  this->proxyDomain = val;
}

void NginxProxyInfo::__set_proxyPort(const int32_t val) {
  this->proxyPort = val;
}

void NginxProxyInfo::__set_targetIpAddr(const std::string& val) {
  this->targetIpAddr = val;
}

void NginxProxyInfo::__set_targetURL(const std::string& val) {
  this->targetURL = val;
}

void NginxProxyInfo::__set_protocol(const std::string& val) {
  this->protocol = val;
}

uint32_t NginxProxyInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->proxyDomain);
          this->__isset.proxyDomain = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->proxyPort);
          this->__isset.proxyPort = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->targetIpAddr);
          this->__isset.targetIpAddr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->targetURL);
          this->__isset.targetURL = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->protocol);
          this->__isset.protocol = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t NginxProxyInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("NginxProxyInfo");

  xfer += oprot->writeFieldBegin("proxyDomain", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->proxyDomain);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("proxyPort", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->proxyPort);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetIpAddr", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->targetIpAddr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("targetURL", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->targetURL);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("protocol", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->protocol);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(NginxProxyInfo &a, NginxProxyInfo &b) {
  using ::std::swap;
  swap(a.proxyDomain, b.proxyDomain);
  swap(a.proxyPort, b.proxyPort);
  swap(a.targetIpAddr, b.targetIpAddr);
  swap(a.targetURL, b.targetURL);
  swap(a.protocol, b.protocol);
  swap(a.__isset, b.__isset);
}

NginxProxyInfo::NginxProxyInfo(const NginxProxyInfo& other119) {
  proxyDomain = other119.proxyDomain;
  proxyPort = other119.proxyPort;
  targetIpAddr = other119.targetIpAddr;
  targetURL = other119.targetURL;
  protocol = other119.protocol;
  __isset = other119.__isset;
}
NginxProxyInfo& NginxProxyInfo::operator=(const NginxProxyInfo& other120) {
  proxyDomain = other120.proxyDomain;
  proxyPort = other120.proxyPort;
  targetIpAddr = other120.targetIpAddr;
  targetURL = other120.targetURL;
  protocol = other120.protocol;
  __isset = other120.__isset;
  return *this;
}
void NginxProxyInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "NginxProxyInfo(";
  out << "proxyDomain=" << to_string(proxyDomain);
  out << ", " << "proxyPort=" << to_string(proxyPort);
  out << ", " << "targetIpAddr=" << to_string(targetIpAddr);
  out << ", " << "targetURL=" << to_string(targetURL);
  out << ", " << "protocol=" << to_string(protocol);
  out << ")";
}


CateWeight::~CateWeight() throw() {
}


void CateWeight::__set_cate(const int32_t val) {
  this->cate = val;
}

void CateWeight::__set_weight(const int32_t val) {
  this->weight = val;
}

uint32_t CateWeight::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cate);
          this->__isset.cate = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->weight);
          this->__isset.weight = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t CateWeight::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("CateWeight");

  xfer += oprot->writeFieldBegin("cate", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->cate);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("weight", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->weight);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(CateWeight &a, CateWeight &b) {
  using ::std::swap;
  swap(a.cate, b.cate);
  swap(a.weight, b.weight);
  swap(a.__isset, b.__isset);
}

CateWeight::CateWeight(const CateWeight& other121) {
  cate = other121.cate;
  weight = other121.weight;
  __isset = other121.__isset;
}
CateWeight& CateWeight::operator=(const CateWeight& other122) {
  cate = other122.cate;
  weight = other122.weight;
  __isset = other122.__isset;
  return *this;
}
void CateWeight::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "CateWeight(";
  out << "cate=" << to_string(cate);
  out << ", " << "weight=" << to_string(weight);
  out << ")";
}


DialHealthResult::~DialHealthResult() throw() {
}


void DialHealthResult::__set_groupName(const std::string& val) {
  this->groupName = val;
}

void DialHealthResult::__set_policyName(const std::string& val) {
  this->policyName = val;
}

void DialHealthResult::__set_statusList(const std::vector<DialRecordStatus> & val) {
  this->statusList = val;
}

uint32_t DialHealthResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupName);
          this->__isset.groupName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policyName);
          this->__isset.policyName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->statusList.clear();
            uint32_t _size123;
            ::apache::thrift::protocol::TType _etype126;
            xfer += iprot->readListBegin(_etype126, _size123);
            this->statusList.resize(_size123);
            uint32_t _i127;
            for (_i127 = 0; _i127 < _size123; ++_i127)
            {
              xfer += this->statusList[_i127].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.statusList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DialHealthResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DialHealthResult");

  xfer += oprot->writeFieldBegin("groupName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->groupName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policyName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->policyName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statusList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->statusList.size()));
    std::vector<DialRecordStatus> ::const_iterator _iter128;
    for (_iter128 = this->statusList.begin(); _iter128 != this->statusList.end(); ++_iter128)
    {
      xfer += (*_iter128).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DialHealthResult &a, DialHealthResult &b) {
  using ::std::swap;
  swap(a.groupName, b.groupName);
  swap(a.policyName, b.policyName);
  swap(a.statusList, b.statusList);
  swap(a.__isset, b.__isset);
}

DialHealthResult::DialHealthResult(const DialHealthResult& other129) {
  groupName = other129.groupName;
  policyName = other129.policyName;
  statusList = other129.statusList;
  __isset = other129.__isset;
}
DialHealthResult& DialHealthResult::operator=(const DialHealthResult& other130) {
  groupName = other130.groupName;
  policyName = other130.policyName;
  statusList = other130.statusList;
  __isset = other130.__isset;
  return *this;
}
void DialHealthResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DialHealthResult(";
  out << "groupName=" << to_string(groupName);
  out << ", " << "policyName=" << to_string(policyName);
  out << ", " << "statusList=" << to_string(statusList);
  out << ")";
}


DialServerResult::~DialServerResult() throw() {
}


void DialServerResult::__set_status(const DialServerStatus& val) {
  this->status = val;
}

void DialServerResult::__set_typ(const DialServerType::type val) {
  this->typ = val;
}

uint32_t DialServerResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->status.read(iprot);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast131;
          xfer += iprot->readI32(ecast131);
          this->typ = (DialServerType::type)ecast131;
          this->__isset.typ = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DialServerResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DialServerResult");

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->status.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("typ", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->typ);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DialServerResult &a, DialServerResult &b) {
  using ::std::swap;
  swap(a.status, b.status);
  swap(a.typ, b.typ);
  swap(a.__isset, b.__isset);
}

DialServerResult::DialServerResult(const DialServerResult& other132) {
  status = other132.status;
  typ = other132.typ;
  __isset = other132.__isset;
}
DialServerResult& DialServerResult::operator=(const DialServerResult& other133) {
  status = other133.status;
  typ = other133.typ;
  __isset = other133.__isset;
  return *this;
}
void DialServerResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DialServerResult(";
  out << "status=" << to_string(status);
  out << ", " << "typ=" << to_string(typ);
  out << ")";
}


DialNginxResult::~DialNginxResult() throw() {
}


void DialNginxResult::__set_groupName(const std::string& val) {
  this->groupName = val;
}

void DialNginxResult::__set_policyName(const std::string& val) {
  this->policyName = val;
}

void DialNginxResult::__set_statusList(const std::vector<DialNginxStatus> & val) {
  this->statusList = val;
}

uint32_t DialNginxResult::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->groupName);
          this->__isset.groupName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->policyName);
          this->__isset.policyName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->statusList.clear();
            uint32_t _size134;
            ::apache::thrift::protocol::TType _etype137;
            xfer += iprot->readListBegin(_etype137, _size134);
            this->statusList.resize(_size134);
            uint32_t _i138;
            for (_i138 = 0; _i138 < _size134; ++_i138)
            {
              xfer += this->statusList[_i138].read(iprot);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.statusList = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DialNginxResult::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DialNginxResult");

  xfer += oprot->writeFieldBegin("groupName", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->groupName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("policyName", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->policyName);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("statusList", ::apache::thrift::protocol::T_LIST, 3);
  {
    xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRUCT, static_cast<uint32_t>(this->statusList.size()));
    std::vector<DialNginxStatus> ::const_iterator _iter139;
    for (_iter139 = this->statusList.begin(); _iter139 != this->statusList.end(); ++_iter139)
    {
      xfer += (*_iter139).write(oprot);
    }
    xfer += oprot->writeListEnd();
  }
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DialNginxResult &a, DialNginxResult &b) {
  using ::std::swap;
  swap(a.groupName, b.groupName);
  swap(a.policyName, b.policyName);
  swap(a.statusList, b.statusList);
  swap(a.__isset, b.__isset);
}

DialNginxResult::DialNginxResult(const DialNginxResult& other140) {
  groupName = other140.groupName;
  policyName = other140.policyName;
  statusList = other140.statusList;
  __isset = other140.__isset;
}
DialNginxResult& DialNginxResult::operator=(const DialNginxResult& other141) {
  groupName = other141.groupName;
  policyName = other141.policyName;
  statusList = other141.statusList;
  __isset = other141.__isset;
  return *this;
}
void DialNginxResult::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DialNginxResult(";
  out << "groupName=" << to_string(groupName);
  out << ", " << "policyName=" << to_string(policyName);
  out << ", " << "statusList=" << to_string(statusList);
  out << ")";
}


SnmpGroupInfo::~SnmpGroupInfo() throw() {
}


void SnmpGroupInfo::__set_enable(const bool val) {
  this->enable = val;
}

void SnmpGroupInfo::__set_name(const std::string& val) {
  this->name = val;
}

void SnmpGroupInfo::__set_community(const std::string& val) {
  this->community = val;
}

void SnmpGroupInfo::__set_user(const std::string& val) {
  this->user = val;
}

void SnmpGroupInfo::__set_passwd(const std::string& val) {
  this->passwd = val;
}

void SnmpGroupInfo::__set_version(const int32_t val) {
  this->version = val;
}

void SnmpGroupInfo::__set_interval(const int32_t val) {
  this->interval = val;
}

void SnmpGroupInfo::__set_port(const int32_t val) {
  this->port = val;
}

void SnmpGroupInfo::__set_ip(const IpAddr& val) {
  this->ip = val;
}

uint32_t SnmpGroupInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->enable);
          this->__isset.enable = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->community);
          this->__isset.community = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->user);
          this->__isset.user = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->passwd);
          this->__isset.passwd = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->version);
          this->__isset.version = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->interval);
          this->__isset.interval = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->port);
          this->__isset.port = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ip.read(iprot);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SnmpGroupInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SnmpGroupInfo");

  xfer += oprot->writeFieldBegin("enable", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->enable);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("community", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->community);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("user", ::apache::thrift::protocol::T_STRING, 4);
  xfer += oprot->writeString(this->user);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("passwd", ::apache::thrift::protocol::T_STRING, 5);
  xfer += oprot->writeString(this->passwd);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("version", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->version);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("interval", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->interval);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("port", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->port);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRUCT, 9);
  xfer += this->ip.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SnmpGroupInfo &a, SnmpGroupInfo &b) {
  using ::std::swap;
  swap(a.enable, b.enable);
  swap(a.name, b.name);
  swap(a.community, b.community);
  swap(a.user, b.user);
  swap(a.passwd, b.passwd);
  swap(a.version, b.version);
  swap(a.interval, b.interval);
  swap(a.port, b.port);
  swap(a.ip, b.ip);
  swap(a.__isset, b.__isset);
}

SnmpGroupInfo::SnmpGroupInfo(const SnmpGroupInfo& other142) {
  enable = other142.enable;
  name = other142.name;
  community = other142.community;
  user = other142.user;
  passwd = other142.passwd;
  version = other142.version;
  interval = other142.interval;
  port = other142.port;
  ip = other142.ip;
  __isset = other142.__isset;
}
SnmpGroupInfo& SnmpGroupInfo::operator=(const SnmpGroupInfo& other143) {
  enable = other143.enable;
  name = other143.name;
  community = other143.community;
  user = other143.user;
  passwd = other143.passwd;
  version = other143.version;
  interval = other143.interval;
  port = other143.port;
  ip = other143.ip;
  __isset = other143.__isset;
  return *this;
}
void SnmpGroupInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SnmpGroupInfo(";
  out << "enable=" << to_string(enable);
  out << ", " << "name=" << to_string(name);
  out << ", " << "community=" << to_string(community);
  out << ", " << "user=" << to_string(user);
  out << ", " << "passwd=" << to_string(passwd);
  out << ", " << "version=" << to_string(version);
  out << ", " << "interval=" << to_string(interval);
  out << ", " << "port=" << to_string(port);
  out << ", " << "ip=" << to_string(ip);
  out << ")";
}


InterfaceTraffic::~InterfaceTraffic() throw() {
}


void InterfaceTraffic::__set_index(const int32_t val) {
  this->index = val;
}

void InterfaceTraffic::__set_inoctets(const int64_t val) {
  this->inoctets = val;
}

void InterfaceTraffic::__set_outoctets(const int64_t val) {
  this->outoctets = val;
}

uint32_t InterfaceTraffic::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->inoctets);
          this->__isset.inoctets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->outoctets);
          this->__isset.outoctets = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InterfaceTraffic::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InterfaceTraffic");

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("inoctets", ::apache::thrift::protocol::T_I64, 2);
  xfer += oprot->writeI64(this->inoctets);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("outoctets", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->outoctets);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InterfaceTraffic &a, InterfaceTraffic &b) {
  using ::std::swap;
  swap(a.index, b.index);
  swap(a.inoctets, b.inoctets);
  swap(a.outoctets, b.outoctets);
  swap(a.__isset, b.__isset);
}

InterfaceTraffic::InterfaceTraffic(const InterfaceTraffic& other144) {
  index = other144.index;
  inoctets = other144.inoctets;
  outoctets = other144.outoctets;
  __isset = other144.__isset;
}
InterfaceTraffic& InterfaceTraffic::operator=(const InterfaceTraffic& other145) {
  index = other145.index;
  inoctets = other145.inoctets;
  outoctets = other145.outoctets;
  __isset = other145.__isset;
  return *this;
}
void InterfaceTraffic::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InterfaceTraffic(";
  out << "index=" << to_string(index);
  out << ", " << "inoctets=" << to_string(inoctets);
  out << ", " << "outoctets=" << to_string(outoctets);
  out << ")";
}


IpMac::~IpMac() throw() {
}


void IpMac::__set_index(const int32_t val) {
  this->index = val;
}

void IpMac::__set_ip(const IpAddr& val) {
  this->ip = val;
}

void IpMac::__set_physaddress(const std::string& val) {
  this->physaddress = val;
}

uint32_t IpMac::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->ip.read(iprot);
          this->__isset.ip = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->physaddress);
          this->__isset.physaddress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t IpMac::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("IpMac");

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("ip", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->ip.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("physaddress", ::apache::thrift::protocol::T_STRING, 3);
  xfer += oprot->writeString(this->physaddress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(IpMac &a, IpMac &b) {
  using ::std::swap;
  swap(a.index, b.index);
  swap(a.ip, b.ip);
  swap(a.physaddress, b.physaddress);
  swap(a.__isset, b.__isset);
}

IpMac::IpMac(const IpMac& other146) {
  index = other146.index;
  ip = other146.ip;
  physaddress = other146.physaddress;
  __isset = other146.__isset;
}
IpMac& IpMac::operator=(const IpMac& other147) {
  index = other147.index;
  ip = other147.ip;
  physaddress = other147.physaddress;
  __isset = other147.__isset;
  return *this;
}
void IpMac::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "IpMac(";
  out << "index=" << to_string(index);
  out << ", " << "ip=" << to_string(ip);
  out << ", " << "physaddress=" << to_string(physaddress);
  out << ")";
}


InterfaceInfo::~InterfaceInfo() throw() {
}


void InterfaceInfo::__set_index(const int32_t val) {
  this->index = val;
}

void InterfaceInfo::__set_descr(const std::string& val) {
  this->descr = val;
}

void InterfaceInfo::__set_type(const int32_t val) {
  this->type = val;
}

void InterfaceInfo::__set_status(const int32_t val) {
  this->status = val;
}

void InterfaceInfo::__set_speed(const int64_t val) {
  this->speed = val;
}

void InterfaceInfo::__set_mtu(const int32_t val) {
  this->mtu = val;
}

void InterfaceInfo::__set_physaddress(const std::string& val) {
  this->physaddress = val;
}

uint32_t InterfaceInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->index);
          this->__isset.index = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->descr);
          this->__isset.descr = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->status);
          this->__isset.status = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->speed);
          this->__isset.speed = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->mtu);
          this->__isset.mtu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->physaddress);
          this->__isset.physaddress = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t InterfaceInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("InterfaceInfo");

  xfer += oprot->writeFieldBegin("index", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->index);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("descr", ::apache::thrift::protocol::T_STRING, 2);
  xfer += oprot->writeString(this->descr);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("status", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->status);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("speed", ::apache::thrift::protocol::T_I64, 5);
  xfer += oprot->writeI64(this->speed);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("mtu", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->mtu);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("physaddress", ::apache::thrift::protocol::T_STRING, 7);
  xfer += oprot->writeString(this->physaddress);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(InterfaceInfo &a, InterfaceInfo &b) {
  using ::std::swap;
  swap(a.index, b.index);
  swap(a.descr, b.descr);
  swap(a.type, b.type);
  swap(a.status, b.status);
  swap(a.speed, b.speed);
  swap(a.mtu, b.mtu);
  swap(a.physaddress, b.physaddress);
  swap(a.__isset, b.__isset);
}

InterfaceInfo::InterfaceInfo(const InterfaceInfo& other148) {
  index = other148.index;
  descr = other148.descr;
  type = other148.type;
  status = other148.status;
  speed = other148.speed;
  mtu = other148.mtu;
  physaddress = other148.physaddress;
  __isset = other148.__isset;
}
InterfaceInfo& InterfaceInfo::operator=(const InterfaceInfo& other149) {
  index = other149.index;
  descr = other149.descr;
  type = other149.type;
  status = other149.status;
  speed = other149.speed;
  mtu = other149.mtu;
  physaddress = other149.physaddress;
  __isset = other149.__isset;
  return *this;
}
void InterfaceInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "InterfaceInfo(";
  out << "index=" << to_string(index);
  out << ", " << "descr=" << to_string(descr);
  out << ", " << "type=" << to_string(type);
  out << ", " << "status=" << to_string(status);
  out << ", " << "speed=" << to_string(speed);
  out << ", " << "mtu=" << to_string(mtu);
  out << ", " << "physaddress=" << to_string(physaddress);
  out << ")";
}


RouteInfo::~RouteInfo() throw() {
}


void RouteInfo::__set_ifindex(const int32_t val) {
  this->ifindex = val;
}

void RouteInfo::__set_destination(const IpAddr& val) {
  this->destination = val;
}

void RouteInfo::__set_gateway(const IpAddr& val) {
  this->gateway = val;
}

void RouteInfo::__set_genmask(const IpAddr& val) {
  this->genmask = val;
}

void RouteInfo::__set_type(const int32_t val) {
  this->type = val;
}

void RouteInfo::__set_proto(const int32_t val) {
  this->proto = val;
}

uint32_t RouteInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->ifindex);
          this->__isset.ifindex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->destination.read(iprot);
          this->__isset.destination = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->gateway.read(iprot);
          this->__isset.gateway = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->genmask.read(iprot);
          this->__isset.genmask = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->proto);
          this->__isset.proto = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t RouteInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("RouteInfo");

  xfer += oprot->writeFieldBegin("ifindex", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->ifindex);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("destination", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->destination.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("gateway", ::apache::thrift::protocol::T_STRUCT, 3);
  xfer += this->gateway.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("genmask", ::apache::thrift::protocol::T_STRUCT, 4);
  xfer += this->genmask.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->type);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("proto", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->proto);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(RouteInfo &a, RouteInfo &b) {
  using ::std::swap;
  swap(a.ifindex, b.ifindex);
  swap(a.destination, b.destination);
  swap(a.gateway, b.gateway);
  swap(a.genmask, b.genmask);
  swap(a.type, b.type);
  swap(a.proto, b.proto);
  swap(a.__isset, b.__isset);
}

RouteInfo::RouteInfo(const RouteInfo& other150) {
  ifindex = other150.ifindex;
  destination = other150.destination;
  gateway = other150.gateway;
  genmask = other150.genmask;
  type = other150.type;
  proto = other150.proto;
  __isset = other150.__isset;
}
RouteInfo& RouteInfo::operator=(const RouteInfo& other151) {
  ifindex = other151.ifindex;
  destination = other151.destination;
  gateway = other151.gateway;
  genmask = other151.genmask;
  type = other151.type;
  proto = other151.proto;
  __isset = other151.__isset;
  return *this;
}
void RouteInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "RouteInfo(";
  out << "ifindex=" << to_string(ifindex);
  out << ", " << "destination=" << to_string(destination);
  out << ", " << "gateway=" << to_string(gateway);
  out << ", " << "genmask=" << to_string(genmask);
  out << ", " << "type=" << to_string(type);
  out << ", " << "proto=" << to_string(proto);
  out << ")";
}


SysInfo::~SysInfo() throw() {
}


void SysInfo::__set_load(const int32_t val) {
  this->load = val;
}

void SysInfo::__set_usercpu(const int32_t val) {
  this->usercpu = val;
}

void SysInfo::__set_syscpu(const int32_t val) {
  this->syscpu = val;
}

void SysInfo::__set_idlecpu(const int32_t val) {
  this->idlecpu = val;
}

void SysInfo::__set_totalmem(const int32_t val) {
  this->totalmem = val;
}

void SysInfo::__set_freemem(const int32_t val) {
  this->freemem = val;
}

void SysInfo::__set_buffer(const int32_t val) {
  this->buffer = val;
}

void SysInfo::__set_cache(const int32_t val) {
  this->cache = val;
}

void SysInfo::__set_availmem(const int32_t val) {
  this->availmem = val;
}

uint32_t SysInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->load);
          this->__isset.load = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->usercpu);
          this->__isset.usercpu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->syscpu);
          this->__isset.syscpu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->idlecpu);
          this->__isset.idlecpu = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->totalmem);
          this->__isset.totalmem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->freemem);
          this->__isset.freemem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->buffer);
          this->__isset.buffer = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cache);
          this->__isset.cache = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 9:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->availmem);
          this->__isset.availmem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t SysInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("SysInfo");

  xfer += oprot->writeFieldBegin("load", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->load);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usercpu", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32(this->usercpu);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("syscpu", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->syscpu);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("idlecpu", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->idlecpu);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("totalmem", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->totalmem);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("freemem", ::apache::thrift::protocol::T_I32, 6);
  xfer += oprot->writeI32(this->freemem);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("buffer", ::apache::thrift::protocol::T_I32, 7);
  xfer += oprot->writeI32(this->buffer);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cache", ::apache::thrift::protocol::T_I32, 8);
  xfer += oprot->writeI32(this->cache);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("availmem", ::apache::thrift::protocol::T_I32, 9);
  xfer += oprot->writeI32(this->availmem);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(SysInfo &a, SysInfo &b) {
  using ::std::swap;
  swap(a.load, b.load);
  swap(a.usercpu, b.usercpu);
  swap(a.syscpu, b.syscpu);
  swap(a.idlecpu, b.idlecpu);
  swap(a.totalmem, b.totalmem);
  swap(a.freemem, b.freemem);
  swap(a.buffer, b.buffer);
  swap(a.cache, b.cache);
  swap(a.availmem, b.availmem);
  swap(a.__isset, b.__isset);
}

SysInfo::SysInfo(const SysInfo& other152) {
  load = other152.load;
  usercpu = other152.usercpu;
  syscpu = other152.syscpu;
  idlecpu = other152.idlecpu;
  totalmem = other152.totalmem;
  freemem = other152.freemem;
  buffer = other152.buffer;
  cache = other152.cache;
  availmem = other152.availmem;
  __isset = other152.__isset;
}
SysInfo& SysInfo::operator=(const SysInfo& other153) {
  load = other153.load;
  usercpu = other153.usercpu;
  syscpu = other153.syscpu;
  idlecpu = other153.idlecpu;
  totalmem = other153.totalmem;
  freemem = other153.freemem;
  buffer = other153.buffer;
  cache = other153.cache;
  availmem = other153.availmem;
  __isset = other153.__isset;
  return *this;
}
void SysInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "SysInfo(";
  out << "load=" << to_string(load);
  out << ", " << "usercpu=" << to_string(usercpu);
  out << ", " << "syscpu=" << to_string(syscpu);
  out << ", " << "idlecpu=" << to_string(idlecpu);
  out << ", " << "totalmem=" << to_string(totalmem);
  out << ", " << "freemem=" << to_string(freemem);
  out << ", " << "buffer=" << to_string(buffer);
  out << ", " << "cache=" << to_string(cache);
  out << ", " << "availmem=" << to_string(availmem);
  out << ")";
}


ProcessInfo::~ProcessInfo() throw() {
}


void ProcessInfo::__set_name(const std::string& val) {
  this->name = val;
}

void ProcessInfo::__set_existflag(const bool val) {
  this->existflag = val;
}

void ProcessInfo::__set_pid(const int32_t val) {
  this->pid = val;
}

void ProcessInfo::__set_cputime(const int32_t val) {
  this->cputime = val;
}

void ProcessInfo::__set_usedmem(const int32_t val) {
  this->usedmem = val;
}

uint32_t ProcessInfo::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->name);
          this->__isset.name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->existflag);
          this->__isset.existflag = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->pid);
          this->__isset.pid = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->cputime);
          this->__isset.cputime = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->usedmem);
          this->__isset.usedmem = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t ProcessInfo::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("ProcessInfo");

  xfer += oprot->writeFieldBegin("name", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->name);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("existflag", ::apache::thrift::protocol::T_BOOL, 2);
  xfer += oprot->writeBool(this->existflag);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("pid", ::apache::thrift::protocol::T_I32, 3);
  xfer += oprot->writeI32(this->pid);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("cputime", ::apache::thrift::protocol::T_I32, 4);
  xfer += oprot->writeI32(this->cputime);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("usedmem", ::apache::thrift::protocol::T_I32, 5);
  xfer += oprot->writeI32(this->usedmem);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(ProcessInfo &a, ProcessInfo &b) {
  using ::std::swap;
  swap(a.name, b.name);
  swap(a.existflag, b.existflag);
  swap(a.pid, b.pid);
  swap(a.cputime, b.cputime);
  swap(a.usedmem, b.usedmem);
  swap(a.__isset, b.__isset);
}

ProcessInfo::ProcessInfo(const ProcessInfo& other154) {
  name = other154.name;
  existflag = other154.existflag;
  pid = other154.pid;
  cputime = other154.cputime;
  usedmem = other154.usedmem;
  __isset = other154.__isset;
}
ProcessInfo& ProcessInfo::operator=(const ProcessInfo& other155) {
  name = other155.name;
  existflag = other155.existflag;
  pid = other155.pid;
  cputime = other155.cputime;
  usedmem = other155.usedmem;
  __isset = other155.__isset;
  return *this;
}
void ProcessInfo::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "ProcessInfo(";
  out << "name=" << to_string(name);
  out << ", " << "existflag=" << to_string(existflag);
  out << ", " << "pid=" << to_string(pid);
  out << ", " << "cputime=" << to_string(cputime);
  out << ", " << "usedmem=" << to_string(usedmem);
  out << ")";
}

}}} // namespace
