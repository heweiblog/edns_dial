// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "Dial.h"
#include "thrift/protocol/TBinaryProtocol.h"
#include "thrift/protocol/TProtocol.h"
#include "thrift/server/TSimpleServer.h"
#include "thrift/transport/TServerSocket.h"
#include "thrift/transport/TBufferTransports.h"
#include "thrift/transport/TSocket.h"
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <fcntl.h>
#include <errno.h>
#include <sys/time.h>
#include <vector>
#include <map>
#include <arpa/nameser.h>
#include <resolv.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <sys/resource.h>
#include <sys/epoll.h>
#include <signal.h>
#include <errno.h>
#include <openssl/crypto.h>
#include <openssl/bio.h>
#include <openssl/ssl.h>
#include <openssl/err.h>


#include "Agent.h"
#include "Dial_list.h"
#include "Dial_server.h"
#include "Dial_hash.h"
#include "Dial_mode.h"
#include "Dial_thread_pool.h"
#include "Dial_queue.h"
#include "Dial_icmp.h"
#include "Dial_common.h"
#include "Dial_dns.h"
#include "Dial_ssl.h"
#include "version.h"
#include "Dial_snmp.h"
#include "Dial_ipsec.h"
#include "Dial_ftp.h"
#include "Dial_smtp.h"
#include <clib/daemon.h>


using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

#define MONITOR_THREAD_NUM 10
#define	HASH_POLICY_NUM	0x7FFF
#define	HASH_NGINX_NUM	0x7FFF
#define	HASH_GROUP_NUM	0x7FFFF
#define	THREAD_POOL_NUM	50
#define HTTPGET_PORT 	80
#define NETBIOS_PORT 	445
#define	CONFIG_FILE		"/etc/dial_config"

hash_info_t 		hs_health_policy;
hash_info_t 		hs_health_group;
hash_info_t 		hs_nginx_group;
DIAL_LIST_HEAD 		list_dial_srv;
queue_info_t		queue_info;
queue_info_t		https_queue;
threadpool_t 		tp;
int 				primary_flag;	
int 				https_epfd;	
pthread_mutex_t		client_lock;
bool				client_connecting_flag = false;
bool				registered_flag = false;
dial_cfg_t 			g_cfg;
bool 				s_debug_switch;
pthread_mutex_t 	g_log_lock;
bool 				thread_exit_flag;

map<string,snmp_node_t> snmp_map;
map<string,ipsec_node_t> ipsec_map;
pthread_rwlock_t 	ipsec_map_lock;
pthread_rwlock_t 	snmp_map_lock;

pthread_mutex_t 	health_results_lock;
pthread_mutex_t 	nginx_results_lock;
pthread_mutex_t 	server_results_lock;
pthread_mutex_t 	dc_results_lock;

vector<DialHealthResult> health_results;
vector<DialNginxResult> nginx_results;
vector<DialServerResult> server_results;
vector<DialDcResult> dc_results;

boost::shared_ptr<TTransport> transport_client;  
boost::shared_ptr<TProtocol> protocol_client; 


healthpolicy_info_t *find_healthpolicy_node_by_name(const char *policyname)
{
		DIAL_LIST_NODE *cur = NULL;
		healthpolicy_info_t *hp_node = NULL;

		cur = hs_health_policy.hash_search(&hs_health_policy,policyname);
		hp_node = (healthpolicy_info_t *)cur;

		return hp_node;
}


healthgroup_info_t *find_healthgroup_node(healthgroup_info_t *search_node,hash_info_t *hs)
{
		healthgroup_info_t *hg = NULL;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;	
		int key = 0;

		key = hs->hash_key(search_node->name,hs->num);

		head = &hs->tab[key].head;
		head_node = &hs->tab[key];

		pthread_mutex_lock(&head_node->lock);

		list_for_each(cur, head) 
		{
				hg = (healthgroup_info_t *)cur;
				if(!strcmp(hg->name,search_node->name)) 
				{
						break;
				}
		}

		pthread_mutex_unlock(&head_node->lock);

		if(cur != head)
		{
				return hg;
		}		
		else
		{
				return NULL;
		}		
}


nginxgroup_info_t *find_nginxgroup_node(nginxgroup_info_t *search_node,hash_info_t *hs)
{
		nginxgroup_info_t *ng = NULL;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;   
		int key = 0;

		key = hs->hash_key(search_node->name,hs->num);

		head = &hs->tab[key].head;
		head_node = &hs->tab[key];

		pthread_mutex_lock(&head_node->lock);

		list_for_each(cur, head) 
		{
				ng = (nginxgroup_info_t *)cur;
				if(!strcmp(ng->name,search_node->name)) 
				{
						break;
				}
		}

		pthread_mutex_unlock(&head_node->lock);

		if(cur != head)
		{
				return ng;
		}		
		else
		{
				return NULL;
		}		
}



RetCode::type DialHandler::systemCommand(const SysCommand::type cmdType) 
{
		return RetCode::OK; 
}


void DialHandler::heartBeat(HeartBeatState& _return) 
{
		static int index_sec = 0;

		if(registered_flag)
		{
				_return.__set_mState(ModuleState::REGISTERED);
		}	
		else
		{
				_return.__set_mState(ModuleState::STARTUP);
		}

		_return.__set_serverState(primary_flag);

		if(index_sec % 60 == 0)
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"heartBeat:receive heart beat register_flag=%d,ServerState=%d!!\n",registered_flag,primary_flag);
				index_sec = 0;
		}

		index_sec++;
}


RetCode::type DialHandler::setServerState(const bool enable) 
{
		primary_flag = enable;

		cfg_debug_printf(LOG_LEVEL_BASIC,"setServerState:set Server State = %d\n",primary_flag);

		return RetCode::OK;
}


RetCode::type DialHandler:: addHealthGroup(const std::string& groupName, const std::string& policyName) 
{

		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		healthgroup_info_t *hg = NULL;
		healthgroup_info_t *hg_node = NULL;
		healthgroup_info_t hg_tmp;
		pPolicy_node_t *pPolicy_node = NULL;
		healthpolicy_info_t *policy = NULL;
		int key = 0;

		policy = find_healthpolicy_node_by_name((const char *)policyName.c_str());
		if(NULL == policy) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:find_healthpolicy_node_by_name failed,no policy node<%s>!!!\n",policyName.c_str());
				return RetCode::FAIL;
		}

		pPolicy_node = (pPolicy_node_t *)calloc(1,sizeof(pPolicy_node_t));
		if(NULL == pPolicy_node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:malloc pPolicy_node failed!!!\n");
				return RetCode::FAIL;
		}

		pPolicy_node->pPolicy = policy;
		gettimeofday(&pPolicy_node->t_insert,NULL);
		pPolicy_node->t_insert.tv_sec += pPolicy_node->pPolicy->freq;

		memset(&hg_tmp,0,sizeof(healthgroup_info_t));
		strcpy(hg_tmp.name,groupName.c_str());

		key = hs_health_group.hash_key(hg_tmp.name,hs_health_group.num);
		head = &hs_health_group.tab[key].head;
		head_node = &hs_health_group.tab[key];

		list_for_each_safe(cur,tmp,head) 
		{
				hg = (healthgroup_info_t *)cur;

				if(!strcmp(hg->name,hg_tmp.name)) 
				{
						break;
				}
		}

		if(cur != head) 
		{
				list_add(&hg->pPolicy_head,&pPolicy_node->node);
				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:attach a policy=%s to group=%s!!!\n",policyName.c_str(),groupName.c_str());
		} 
		else 
		{
				hg_node = (healthgroup_info_t *)calloc(1,sizeof(healthgroup_info_t));
				if(NULL == hg_node) 
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:malloc hg_node failed!!!\n");
						free(pPolicy_node);
						return RetCode::FAIL;
				}

				strcpy(hg_node->name,groupName.c_str());
				list_head_init(&hg_node->record_head);
				list_head_init(&hg_node->pPolicy_head);

				list_add(&hg_node->pPolicy_head,&pPolicy_node->node);
				hs_health_group.hash_add(&hs_health_group,hg_node->name,&hg_node->node);

				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthGroup:add a new group=%s,policy=%s!!!\n",groupName.c_str(),policyName.c_str());
		}


		return RetCode::OK;
}


RetCode::type DialHandler:: delHealthGroup(const std::string& groupName, const std::string& policyName) 
{
		healthgroup_info_t hg_node;
		int key = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_NODE *node = NULL;
		DIAL_LIST_NODE *record_head_node = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		DIAL_LIST_HEAD *record_head = NULL;
		healthgroup_info_t *hg = NULL;
		record_info_t* record_node = NULL;
		pPolicy_node_t *pPolicy_node = NULL;
		RetCode::type ret = RetCode::OK;

		memset(&hg_node,0,sizeof(healthgroup_info_t));
		
		strcpy(hg_node.name,groupName.c_str());

		key = hs_health_group.hash_key(hg_node.name,hs_health_group.num);
		node = hs_health_group.hash_search(&hs_health_group,hg_node.name);
		if(NULL == node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:failed,can not find health group node group=%s!!!\n",groupName.c_str());
				return RetCode::FAIL;
		}

		head_node = &hs_health_group.tab[key];
		hg = (healthgroup_info_t *)node;
		head = &hg->pPolicy_head.head;

		list_for_each_safe(cur,tmp,head) 
		{
				pPolicy_node = (pPolicy_node_t *)cur;
				if(!strcmp(pPolicy_node->pPolicy->policyname,policyName.c_str()))
				{
						break;
				}	
		}

		if(cur != head) 
		{
				list_del(&hg->pPolicy_head,&pPolicy_node->node);
				free(pPolicy_node);
				cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:del policy=%s from healthgroup=%s\n",policyName.c_str(),groupName.c_str());
					
				if(hg->pPolicy_head.num < 1)
				{
						record_head = &hg->record_head;
						record_head_node = &(record_head->head);
							
						list_for_each_safe(cur,tmp,record_head_node)
						{
								list_del(record_head,cur);
								record_node = (record_info_t *)cur;
								cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:del record ip=%s from healthgroup=%s\n",(record_node->ip).addr,hg->name);
								free(record_node);
								record_node = NULL;
						}

						list_del(head_node,&hg->node);
						free(hg);
						hg = NULL;

						cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:del all policy and record success!!! healthgroup = %s\n",groupName.c_str());
				}
				

		}
		else
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthGroup:can not find target policynode=%s from group=%s!!!\n",policyName.c_str(),groupName.c_str());
				return RetCode::FAIL;
		}


		return RetCode::OK;
}



RetCode::type DialHandler:: addHealthRecord(const std::string& groupName, const std::vector<DialRecord> & records) 
{
		int size = 0,i = 0;
		healthgroup_info_t hg_node;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		healthgroup_info_t *hg = NULL;
		record_info_t* record = NULL;

		memset(&hg_node,0,sizeof(healthgroup_info_t));
		strcpy(hg_node.name,groupName.c_str());

		cur = hs_health_group.hash_search(&hs_health_group,hg_node.name);
		if(NULL == cur) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord:failed,can not find health group node!!!,group=%s\n",groupName.c_str());
				return RetCode::FAIL;
		}


		hg = (healthgroup_info_t *)cur;

		head_node = &hg->record_head;
		head = &head_node->head;
		
		size = records.size();

		for(i = 0 ; i < size ; i++)
		{
				list_for_each_safe(cur,tmp,head)
				{
						record = (record_info_t*)cur;			
						if(!strcmp(record->rid,records[i].rid.c_str()))
						{
								break;
						}
				}

				if(cur != head)
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord already exist!!!:healthgroup=%s,ip=%s\n",groupName.c_str(),records[i].ip.addr.c_str());
						continue;
				}
				else
				{
						record_info_t *r_node = (record_info_t *)calloc(1,sizeof(record_info_t));
						if(NULL == r_node) 
						{
								cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord:calloc record_info_t failed!!!\n");
								return RetCode::FAIL;
						}

						strcpy(r_node->rid,records[i].rid.c_str());
						r_node->ip.version = records[i].ip.version;
						strcpy(r_node->ip.addr,records[i].ip.addr.c_str());

						list_add(head_node,&r_node->node);

						cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthRecord success!!!:healthgroup=%s,ip=%s\n",groupName.c_str(),records[i].ip.addr.c_str());
				}
		}

		return RetCode::OK;
}


RetCode::type DialHandler:: delHealthRecord(const std::string& groupName, const std::vector<DialRecord> & records) 
{
		int size = 0,i = 0;
		healthgroup_info_t hg_node;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_NODE *node = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		healthgroup_info_t *hg = NULL;
		record_info_t* record = NULL;

		memset(&hg_node,0,sizeof(healthgroup_info_t));
		strcpy(hg_node.name,groupName.c_str());

		node = hs_health_group.hash_search(&hs_health_group,hg_node.name);
		if(NULL == node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthRecord:failed,can not find health group node!!!groupname=%s\n",groupName.c_str());
				return RetCode::FAIL;
		}

		hg = (healthgroup_info_t *)node;

		head_node = &hg->record_head;
		head = &head_node->head;

		size = records.size();


		for(i = 0 ; i < size ; i++)
		{
				list_for_each_safe(cur,tmp,head)
				{
						record = (record_info_t*)cur;			
						if(!strcmp(record->rid,records[i].rid.c_str()))
						{
								break;
						}
				}
				if(cur != head)
				{
						list_del(head_node,cur);
						cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthRecord:del record success,ip=%s,healthgroup=%s\n",(record->ip).addr,hg->name);
						free(record);
						record = NULL;
				}
				else
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthRecord:del record fialed,ip=%s,healthgroup=%s\n",records[i].ip.addr.c_str(),hg->name);
						pthread_mutex_unlock(&head_node->lock); 
						return RetCode::FAIL; 
				}
		}


		return RetCode::OK;

}


void change_str_content(char*content,char* buf,short policy_method) 
{
		char* p = NULL;
		char* content_start = content;
		const char* s = "\\r\\n";
		const char* br = "\\r\\n\\r\\n";
		const char* enter = "\r\n";
		do   
		{           
				p = strstr(content,s);
				if(p)
				{           
						strncat(buf,content,p-content);
						strcat(buf,enter);
						content = p+4;
				}    
		}        
		while(p);
		strcat(buf,content);

		if(policy_method == DIAL_HTTPCOMMON && !strstr(content_start,br))
		{
				strcat(buf,enter);
				strcat(buf,enter);
		}
}


void init_dial_option(healthpolicy_info_t *policy,const DialOption &option)
{
		dial_option_t *dialoption = &policy->dial_option;
		unsigned int i = 0;
		match_code_t *mcode = NULL;
		
		dialoption->tag = option.tag;
		strcpy(dialoption->dest_url,option.destUrl.c_str());	
		strcpy(dialoption->expect_match,option.expectMatch.c_str());	
		strcpy(dialoption->content_type,option.contentType.c_str());

		if(policy->method == DIAL_HTTPCOMMON || policy->method == DIAL_EXTTCPPORT)
		{		
				char tmp_buf[1024] = {'\0'};
				char buf[1024] = {'\0'};
				strcpy(tmp_buf,option.testMethod.c_str());	
				change_str_content(tmp_buf,buf,policy->method);
				strcpy(dialoption->test_method,buf);	
		}
		else
		{
				strcpy(dialoption->test_method,option.testMethod.c_str());	
		}

		list_head_init(&dialoption->code_head);

		for(i= 0;i < option.expectCode.size();i++) 
		{
				mcode = (match_code_t *)calloc(1,sizeof(match_code_t));
				mcode->code = option.expectCode[i];
				list_add(&dialoption->code_head,&mcode->node);	
				cfg_debug_printf(LOG_LEVEL_BASIC,"init_dial_option:match_code=%d\n",mcode->code);
		}
		
		cfg_debug_printf(LOG_LEVEL_BASIC,"init_dial_option:\ndest_url=\n%s\ntest_method=\n%s\nexpect_match=\n%s\ncontent_type=\n%s\nmatchcode_num=%d\n",dialoption->dest_url,dialoption->test_method,dialoption->expect_match,dialoption->content_type,option.expectCode.size());

}


void modify_dial_option(healthpolicy_info_t *policy, const DialOption &option)
{
		dial_option_t *dialoption = &policy->dial_option;
		unsigned int i = 0;
		match_code_t *mcode = NULL;
		DIAL_LIST_NODE *cur,*tmp,*head;

		memset(dialoption->dest_url,0,sizeof(dialoption->dest_url));
		memset(dialoption->test_method,0,sizeof(dialoption->test_method));
		memset(dialoption->expect_match,0,sizeof(dialoption->expect_match));

		dialoption->tag = option.tag;
		strcpy(dialoption->dest_url,option.destUrl.c_str());	
		strcpy(dialoption->expect_match,option.expectMatch.c_str());	
		strcpy(dialoption->content_type,option.contentType.c_str());

		if(policy->method == DIAL_HTTPCOMMON || policy->method == DIAL_EXTTCPPORT)
		{		
				char tmp_buf[1024] = {'\0'};
				char buf[1024] = {'\0'};
				strcpy(tmp_buf,option.testMethod.c_str());	
				change_str_content(tmp_buf,buf,policy->method);
				strcpy(dialoption->test_method,buf);	
		}
		else
		{
				strcpy(dialoption->test_method,option.testMethod.c_str());	
		}


		head = &dialoption->code_head.head;

		list_for_each_safe(cur,tmp,head) 
		{
				list_del(&dialoption->code_head,cur);
				mcode = (match_code_t *)cur;
				free(mcode);
		}

		for(i= 0;i < option.expectCode.size();i++) 
		{
				mcode = (match_code_t *)calloc(1,sizeof(match_code_t));
				mcode->code = option.expectCode[i];
				list_add(&dialoption->code_head,&mcode->node);	
		}
}


void del_dial_option(dial_option_t *dialoption)
{
		int i = 0;
		match_code_t *mcode = NULL;
		DIAL_LIST_NODE *cur,*tmp,*head;


		head = &dialoption->code_head.head;

		list_for_each_safe(cur,tmp,head) 
		{
				list_del(&dialoption->code_head,cur);
				mcode = (match_code_t *)cur;
				free(mcode);
		}
}


RetCode::type DialHandler:: addHealthPolicy(const HealthPolicyInfo& policy) 
{

		healthpolicy_info_t *hp_node = (healthpolicy_info_t *)malloc(sizeof(healthpolicy_info_t));
		if(NULL == hp_node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthPolicy:malloc failed!!!\n");
				return RetCode::FAIL;
		}

		memset(hp_node,0,sizeof(healthpolicy_info_t));

		strcpy(hp_node->policyname,policy.name.c_str());
		hp_node->method = policy.method;
		hp_node->port = (uint16_t)policy.port;
		hp_node->freq = policy.freq;
		hp_node->times = policy.times;
		hp_node->passed = policy.passed;

		init_dial_option(hp_node,policy.option);

		hs_health_policy.hash_add(&hs_health_policy,hp_node->policyname,&hp_node->node);

		cfg_debug_printf(LOG_LEVEL_BASIC,"addHealthPolicy:success!!!,policyname=%s,method=%hd,port=%hu,frep=%d,times=%d,passed=%d\n",policy.name.c_str(),hp_node->method,policy.port,policy.freq,policy.times,policy.passed);

		return RetCode::OK;
}


RetCode::type DialHandler:: modHealthPolicy(const HealthPolicyInfo& policy) 
{
		int key = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		healthpolicy_info_t *hp_node = NULL;
		RetCode::type ret = RetCode::OK;

		key = hs_health_policy.hash_key((const char *)policy.name.c_str(),hs_health_policy.num);

		head = &hs_health_policy.tab[key].head;
		head_node = &hs_health_policy.tab[key];

		pthread_mutex_lock(&head_node->lock);

		list_for_each(cur, head) 
		{
				hp_node = (healthpolicy_info_t *)cur;
				if(!strcmp(policy.name.c_str(),hp_node->policyname)) 
				{
						break;
				}
		}

		if(NULL != head) 
		{
				hp_node->method = policy.method;
				hp_node->port = policy.port;
				hp_node->freq = policy.freq;
				hp_node->times = policy.times;
				hp_node->passed = policy.passed;
				modify_dial_option(hp_node,policy.option);
				cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthPolicy:success!!!,policyname=%s\n",policy.name.c_str());

		}
		else 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"modHealthPolicy:can not find the target node!!!name=%s\n",policy.name.c_str());
				ret = RetCode::FAIL;
		}
		pthread_mutex_unlock(&head_node->lock);


		return ret;
}


RetCode::type DialHandler:: delHealthPolicy(const HealthPolicyInfo& policy) 
{
		int key = 0;
		DIAL_LIST_NODE *cur = NULL;
		healthpolicy_info_t *hp_node = NULL;
		RetCode::type ret = RetCode::OK;

		cur = hs_health_policy.hash_search(&hs_health_policy,(const char *)policy.name.c_str());
		key = hs_health_policy.hash_key((const char*)policy.name.c_str(),hs_health_policy.num);

		if(NULL != cur) 
		{
				hp_node = (healthpolicy_info_t *)cur;
				list_del(&hs_health_policy.tab[key],cur);
				del_dial_option(&hp_node->dial_option);
				free(hp_node);
				cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthPolicy:success!!!,policyname=%s\n",policy.name.c_str());
		}
		else 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delHealthPolicy:can not find the target node!!!name=%s\n",policy.name.c_str());
				ret = RetCode::FAIL;
		}

		return ret;
}


RetCode::type DialHandler::addDcInfo(const DcInfo& dc)
{
		pPolicy_node_t *pPolicy_node = NULL;
		healthpolicy_info_t *policy = NULL;
		int i = 0,size = dc.PolicyList.size();

		dial_srv_node_t *srv_node = (dial_srv_node_t *)calloc(1,sizeof(dial_srv_node_t));
		if(NULL == srv_node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addDcinfo:ip=%s,malloc failed!!!\n",dc.ip.addr.c_str());
				return RetCode::FAIL;
		}

		strcpy(srv_node->srv_id,dc.id.c_str());
		strcpy(srv_node->ip.addr,dc.ip.addr.c_str());
		srv_node->ip.version = dc.ip.version;
		srv_node->srv_tpye =  DialServerType::DATACENTER;

		list_head_init(&srv_node->pPolicy_head);

		for(i = 0 ; i < size ; i++)
		{
				policy = find_healthpolicy_node_by_name((const char *)dc.PolicyList[i].c_str());
				if(NULL == policy) 
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"addDcinfo:ip=%s,find policy=%s failed!!!\n",dc.ip.addr.c_str(),dc.PolicyList[i].c_str());
						return RetCode::FAIL;
				}

				pPolicy_node = (pPolicy_node_t *)calloc(1,sizeof(pPolicy_node_t));
				if(NULL == pPolicy_node) 
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"addDcinfo:ip=%s,malloc failed!!!\n",dc.ip.addr.c_str());
						return RetCode::FAIL;
				}

				pPolicy_node->pPolicy = policy;
				gettimeofday(&pPolicy_node->t_insert,NULL);
				pPolicy_node->t_insert.tv_sec += pPolicy_node->pPolicy->freq;

				list_add(&srv_node->pPolicy_head,&pPolicy_node->node);
				cfg_debug_printf(LOG_LEVEL_BASIC,"addDcinfo:ip=%s,policy=%s!!!\n",dc.ip.addr.c_str(),dc.PolicyList[i].c_str());
		}

		list_add(&list_dial_srv,&srv_node->node);

		cfg_debug_printf(LOG_LEVEL_BASIC,"addDcinfo:ip=%s,id=%s,policy_num=%d,add success!!!\n",dc.ip.addr.c_str(),dc.id.c_str(),size);

		return RetCode::OK;
}

RetCode::type DialHandler::delDcInfo(const std::string& id)
{
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = &list_dial_srv.head;
		dial_srv_node_t *srv_node  = NULL;
		pPolicy_node_t *pPolicy_node = NULL;

		list_for_each_safe(cur, tmp, head) 
		{
				srv_node = (dial_srv_node_t *)cur;

				if(!strcmp(srv_node->srv_id,id.c_str()))
				{
						break;
				}
		}

		if(cur == head) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delDcinfo failed!!!:can not find id=%s\n",id.c_str());
				return RetCode::FAIL;
		}
		else
		{
				list_del(&list_dial_srv,cur);

				head = &srv_node->pPolicy_head.head;

				list_for_each_safe(cur,tmp,head) 
				{
						pPolicy_node = (pPolicy_node_t *)cur;
						cfg_debug_printf(LOG_LEVEL_BASIC,"delDcinfo:policy=%s,id=%s!!!\n",pPolicy_node->pPolicy->policyname,id.c_str());
						free(pPolicy_node);
				}

				free(srv_node);
				cfg_debug_printf(LOG_LEVEL_BASIC,"delDcinfo:success!!!,id=%s\n",id.c_str());
				return RetCode::OK;
		}
}


RetCode::type DialHandler::addDialServer(const ObjectId& rid, const IpAddr& ip, const DialServerType::type typ) 
{
		dial_srv_node_t *srv_node = (dial_srv_node_t *)calloc(1,sizeof(dial_srv_node_t));
		if(NULL == srv_node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addDialServer:malloc failed!!!\n");
				return RetCode::FAIL;
		}

		strcpy(srv_node->ip.addr,ip.addr.c_str());
		srv_node->ip.version = ip.version;
		srv_node->srv_tpye = typ;
		strcpy(srv_node->srv_id,rid.c_str());
		gettimeofday(&srv_node->t_insert,NULL);
		srv_node->t_insert.tv_sec += g_cfg.srv_cfg.interval;

		list_add(&list_dial_srv,&srv_node->node);

		cfg_debug_printf(LOG_LEVEL_BASIC,"addDialServer:success!!!,ip=%s,type=%d,srv_id=%s\n",ip.addr.c_str(),typ,rid.c_str());

		return RetCode::OK;
}


RetCode::type DialHandler::delDialServer(const ObjectId& rid) 
{
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = &list_dial_srv.head;
		dial_srv_node_t *srv_node  = NULL;

		list_for_each_safe(cur, tmp, head) 
		{
				srv_node = (dial_srv_node_t *)cur;

				if(!strcmp(srv_node->srv_id,rid.c_str()))
				{
						break;
				}
		}
		if(cur == head) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delDialServer failed!!!:srv_id=%s\n",rid.c_str());
				return RetCode::FAIL;
		}
		else
		{
				list_del(&list_dial_srv,cur);
				free(srv_node);
				cfg_debug_printf(LOG_LEVEL_BASIC,"delDialServer:success!!!,srv_id=%s\n",rid.c_str());
				return RetCode::OK;
		}

}


RetCode::type DialHandler::addIpSec(const SysIpSec& ipsec,const int32_t interval)
{
		ipsec_node_t ipsec_node;
		ipsec_node.work_flag = false;
		ipsec_node.tid = 0;
		ipsec_node.ipsec = ipsec;
		ipsec_node.interval = interval;
		pthread_rwlock_wrlock(&ipsec_map_lock);
		ipsec_map[ipsec.recordId] = ipsec_node;
		pthread_rwlock_unlock(&ipsec_map_lock);
		cfg_debug_printf(LOG_LEVEL_BASIC,"addIpSec:success!!!,ipsec=%s,ipsecid=%s\n",ipsec.ipsec.ip.addr.c_str(),ipsec.recordId.c_str());
		return RetCode::OK;
}


RetCode::type DialHandler::delIpSec(const std::string& ipsecid)
{
		int size = 0,res = 0;
		map<string,ipsec_node_t>::iterator iter;

		iter = ipsec_map.find(ipsecid);

		if(iter == ipsec_map.end())
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delIpSec:failed!!!,can not find ipsec_id=%s\n",ipsecid.c_str());
				return RetCode::FAIL;
		}
		
		if(iter->second.work_flag)
		{
				iter->second.work_flag = false;
				res = pthread_join(iter->second.tid,NULL);
				if(0 != res)
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"delIpSec:pthread_join failed!!!,ipsec_id=%s\n",ipsecid.c_str());	
				}
		}

		pthread_rwlock_wrlock(&ipsec_map_lock);
		size = ipsec_map.erase(ipsecid);
		pthread_rwlock_unlock(&ipsec_map_lock);

		if(size > 0)
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delIpSec:success!!!,ipsec_id=%s\n",ipsecid.c_str());
				return RetCode::OK;
		}		
		else
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delIpSec:failed!!!,ipsec_id=%s\n",ipsecid.c_str());
				return RetCode::FAIL;
		}
}


RetCode::type DialHandler::addSnmpGroupInfo(const SnmpGroupInfo& snmp)
{
		snmp_node_t snmp_node;
		snmp_node.tid = 0;
		snmp_node.work_flag = false;
		snmp_node.snmp = snmp;
		pthread_rwlock_wrlock(&snmp_map_lock);
		snmp_map[snmp.name] = snmp_node;
		pthread_rwlock_unlock(&snmp_map_lock);
		cfg_debug_printf(LOG_LEVEL_BASIC,"addSnmp:success!!!,ip=%s,id=%s\n",snmp.ip.addr.c_str(),snmp.name.c_str());
		return RetCode::OK;
}


RetCode::type DialHandler::delSnmpGroupInfo(const std::string& snmp)
{
		int size = 0,res = 0;
		map<string,snmp_node_t>::iterator iter;
		
		iter = snmp_map.find(snmp);
		if(iter == snmp_map.end())
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delSnmp:failed!!!,can not fand snmp_node id=%s\n",snmp.c_str());
				return RetCode::FAIL;
		}

		if(iter->second.work_flag)
		{
				res = pthread_cancel(iter->second.tid);
				if(0 != res)
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"delSnmp:pthread_cancel failed!!!,snmp_node id=%si,tid=%u\n",snmp.c_str(),iter->second.tid);	
				}
		}		

		pthread_rwlock_wrlock(&snmp_map_lock);
		iter->second.process.clear();
		size = snmp_map.erase(snmp);
		pthread_rwlock_unlock(&snmp_map_lock);

		if(size > 0)
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delSnmp:success!!!,id=%s\n",snmp.c_str());
				return RetCode::OK;
		}
		else
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delSnmp:failed!!!,id=%s\n",snmp.c_str());
				return RetCode::FAIL;
		}
}


RetCode::type DialHandler::addSnmpProcessInfo(const std::string& snmp, const std::string& processname)
{
		ProcessInfo process;	
		map<string,snmp_node_t>::iterator iter;
		
		iter = snmp_map.find(snmp);
		if(iter == snmp_map.end())
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addprocess:failed!!!,snmp node not exist snmp_id=%s,process=%s,id=%s\n",snmp.c_str(),processname.c_str(),snmp.c_str());
				return RetCode::FAIL;
		}

		process.name = processname;
		snmp_map[snmp].process.push_back(process);
		cfg_debug_printf(LOG_LEVEL_BASIC,"addprocess:success!!!,snmp_id=%s,process=%s,id=%s\n",snmp.c_str(),processname.c_str(),snmp.c_str());

		return RetCode::OK;
}


RetCode::type DialHandler::delSnmpProcessInfo(const std::string& snmp, const std::string& processname)
{
		map<string,snmp_node_t>::iterator iter;
		vector<ProcessInfo>::iterator piter;
		
		iter = snmp_map.find(snmp);
		if(iter == snmp_map.end())
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delprocess:failed!!!,can not fand snmp_node id=%s\n",snmp.c_str());
				return RetCode::FAIL;
		}

		for(piter = iter->second.process.begin() ; piter != iter->second.process.end() ; piter++)
		{
				if(piter->name == processname)
				{
						iter->second.process.erase(piter);
						cfg_debug_printf(LOG_LEVEL_BASIC,"delprocess:success!!!,process=%s,id=%s\n",processname.c_str(),snmp.c_str());
						return RetCode::OK;
				}
		}
		
		cfg_debug_printf(LOG_LEVEL_BASIC,"delprocess:failed!!!,can not find process=%s,id=%s\n",processname.c_str(),snmp.c_str());
		return RetCode::FAIL;
}


RetCode::type DialHandler::addNginxGroup(const std::string& groupName, const std::string& policyName) 
{
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		nginxgroup_info_t *ng = NULL;
		nginxgroup_info_t ng_node;
		nginxgroup_info_t *nginx_node = NULL;
		pPolicy_node_t *pPolicy_node = NULL;
		healthpolicy_info_t *policy = NULL;
		int key = 0;

		policy = find_healthpolicy_node_by_name((const char *)policyName.c_str());
		if(NULL == policy) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:can not find policy node<%s>!!!\n",policyName.c_str());
				return RetCode::FAIL;
		}

		pPolicy_node = (pPolicy_node_t *)calloc(1,sizeof(pPolicy_node_t));
		if(NULL == pPolicy_node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:malloc pPolicy_node failed!!!\n");
				return RetCode::FAIL;
		}

		pPolicy_node->pPolicy = policy;
		gettimeofday(&pPolicy_node->t_insert,NULL);
		pPolicy_node->t_insert.tv_sec += pPolicy_node->pPolicy->freq;


		memset(&ng_node,0,sizeof(nginxgroup_info_t));
		strcpy(ng_node.name,groupName.c_str());

		key = hs_nginx_group.hash_key(ng_node.name,hs_nginx_group.num);

		head = &hs_nginx_group.tab[key].head;
		head_node = &hs_nginx_group.tab[key];


		list_for_each_safe(cur,tmp,head) 
		{
				ng = (nginxgroup_info_t *)cur;
				if(!strcmp(ng->name,ng_node.name)) 
				{
						break;
				}
		}


		if(cur != head) 
		{
				list_add(&ng->pPolicy_head,&pPolicy_node->node);	
				cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:attach a policy=%s to nginxgroup=%s!!!\n",policyName.c_str(),groupName.c_str());		
		}
		else 
		{
				nginx_node = (nginxgroup_info_t *)calloc(1,sizeof(nginxgroup_info_t));
				if(NULL == nginx_node) 
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:malloc nginx_node failed!!!\n");
						free(pPolicy_node);
						return RetCode::FAIL;
				}		

				strcpy(nginx_node->name,groupName.c_str());
				list_head_init(&nginx_node->srv_head);
				list_head_init(&nginx_node->pPolicy_head);

				list_add(&nginx_node->pPolicy_head,&pPolicy_node->node);
				hs_nginx_group.hash_add(&hs_nginx_group,nginx_node->name,&nginx_node->node);

				cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxGroup:add a new nginxgroup=%s,policy=%s\n",groupName.c_str(),policyName.c_str());
		}


		return RetCode::OK;

}


RetCode::type DialHandler::delNginxGroup(const std::string& groupName, const std::string& policyName) 
{
		nginxgroup_info_t ng_node;
		int key = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *node = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_NODE *srv_head_node = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		DIAL_LIST_HEAD *srv_head = NULL;
		nginxgroup_info_t *ng = NULL;
		pPolicy_node_t *pPolicy_node = NULL;
		nginx_srv_t* srv_node = NULL;

		memset(&ng_node,0,sizeof(nginxgroup_info_t));
		strcpy(ng_node.name,groupName.c_str());

		key = hs_nginx_group.hash_key(ng_node.name,hs_nginx_group.num);
		node = hs_nginx_group.hash_search(&hs_nginx_group,(char *)ng_node.name);

		if(NULL == node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxGroup:failed,can not find nginx groupnode=%s!!!\n",groupName.c_str());
				return RetCode::FAIL;
		}

		head_node = &hs_nginx_group.tab[key];
		ng = (nginxgroup_info_t *)node;
		head = &ng->pPolicy_head.head;


		list_for_each_safe(cur,tmp,head) 
		{
				pPolicy_node = (pPolicy_node_t *)cur;
				if(!strcmp(pPolicy_node->pPolicy->policyname,policyName.c_str()))
				{
						break;
				}	
		}


		if(cur != head) 
		{
				list_del(&ng->pPolicy_head,&pPolicy_node->node);
				free(pPolicy_node);
				cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxGroup:del policy = %s from nginxgroup = %s\n",policyName.c_str(),groupName.c_str());

				if(ng->pPolicy_head.num < 1)
				{
								
						srv_head = &(ng->srv_head);
						srv_head_node = &(srv_head->head);

						list_for_each_safe(cur,tmp,srv_head_node) 
						{
								list_del(srv_head,cur);
								srv_node = (nginx_srv_t *)cur;
								cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxGroup:del nginx_srv=%s from nginxgroupname=%s\n",srv_node->url,groupName.c_str());
								free(srv_node);
						}
					
						list_del(head_node,&ng->node);
						free(ng);
						cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxGroup:success!!!,del all nginx_srv and policy!!!,nginxgroupname=%s\n",groupName.c_str());
				}
				
				
		}
		else
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxGroup:can not find target policynode=%s from nginxgroup=%s!!!\n",policyName.c_str(),groupName.c_str());

				return RetCode::FAIL;
		}

		return RetCode::OK;

}


RetCode::type DialHandler::addNginxServer(const std::string& groupName, const std::vector<DialNginxServer>&servers) 
{
		int size = 0, i = 0;
		nginxgroup_info_t ng_node;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		nginxgroup_info_t *ng = NULL;
		nginx_srv_t *nginx_srv = NULL;

		memset(&ng_node,0,sizeof(nginxgroup_info_t));
		strcpy(ng_node.name,groupName.c_str());

		cur = hs_nginx_group.hash_search(&hs_nginx_group,ng_node.name);
		if(NULL == cur) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:failed,can not find nginx group node!!!,name=%s\n",ng_node.name);
				return RetCode::FAIL;
		}

		ng = (nginxgroup_info_t *)cur;
		head_node = &ng->srv_head;
		head = &head_node->head;

		size = servers.size();

		for(i = 0 ; i < size ; i++)
		{

				list_for_each_safe(cur,tmp,head)
				{
						nginx_srv = (nginx_srv_t*)cur;			
						if(!strcmp(nginx_srv->url,servers[i].localURL.c_str()))
						{
								break;
						}
				}

				if(cur != head)
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:already exist!!!nginxgroup=%s,url=%s\n",groupName.c_str(),servers[i].localURL.c_str());
						continue;
				}
				else
				{
						nginx_srv_t *srv_node = (nginx_srv_t *)calloc(1,sizeof(nginx_srv_t));
						if(NULL == srv_node) 
						{
								cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:malloc failed!!!\n");
								return RetCode::FAIL;
						}
						srv_node->priority = servers[i].priority;
						strcpy(srv_node->url,servers[i].localURL.c_str());
						list_add(head_node,&srv_node->node);
						cfg_debug_printf(LOG_LEVEL_BASIC,"addNginxServer:success!!!nginxgroup=%s,url=%s\n",groupName.c_str(),servers[i].localURL.c_str());
				}
		}

		return RetCode::OK;
}


RetCode::type DialHandler::delNginxServer(const std::string& groupName, const std::vector<DialNginxServer>&servers) 
{
		int size = 0,i = 0;
		nginxgroup_info_t ng_node;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *node = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *head_node = NULL;
		nginxgroup_info_t *ng = NULL;
		nginx_srv_t *nginx_srv = NULL;

		memset(&ng_node,0,sizeof(nginxgroup_info_t));
		strcpy(ng_node.name,groupName.c_str());

		node = hs_nginx_group.hash_search(&hs_nginx_group,(const char *)ng_node.name);
		if(NULL == node) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxServer:failed,can not find nginx group node!!!groupName=%s\n",groupName.c_str());
				return RetCode::FAIL;
		}

		ng = (nginxgroup_info_t *)node;
		head_node = &ng->srv_head;
		head = &head_node->head;

		size = servers.size();


		for(i = 0 ; i < size ; i++)
		{
				list_for_each_safe(cur,tmp,head)
				{
						nginx_srv = (nginx_srv_t*)cur;			
						if(!strcmp(nginx_srv->url,servers[i].localURL.c_str()))
						{
								break;
						}
				}

				if(cur != head)
				{
						list_del(head_node,cur);
						cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxServer:del nginx_srv=%s from nginxgroupname=%s\n",nginx_srv->url,groupName.c_str());
						free(nginx_srv);
						nginx_srv = NULL;
				}
				else
				{
						cfg_debug_printf(LOG_LEVEL_BASIC,"delNginxServer:failed del nginx_srv=%s from nginxgroupname=%s\n",servers[i].localURL.c_str(),groupName.c_str());
						pthread_mutex_unlock(&head_node->lock);
						return RetCode::FAIL;
				}
		}
		

		return RetCode::OK;

}


int create_client_udp_fd()
{
		int rtn = 0;
		int fd = 0;
		int flag = 0;
		int fdbuflen;
		struct sockaddr_in cliaddr;
		struct timeval timeout;

		fd = socket(AF_INET,SOCK_DGRAM,0);
		if(fd < 0) 
		{
				debug_printf(LOG_LEVEL_ERROR,"create_client_udp_fd failed\n");
				return ERROR;
		}

		timeout.tv_sec=0;
		timeout.tv_usec=(g_cfg.srv_cfg.timeout + 1)*1000;
		rtn = setsockopt(fd,SOL_SOCKET,SO_RCVTIMEO,(char *)&timeout,sizeof(struct timeval));
		if(rtn < 0)
		{
				debug_printf(LOG_LEVEL_ERROR,"create_client_udp_fd:setsockopt SO_RCVTIMEO failed \n");
				return ERROR;
		}

		return fd;
}


RetCode::type send_update_dc_status(const std::vector<DialDcResult> & results)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateDcStatus(results);
				debug_printf(LOG_LEVEL_DEBUG,"send_update_dc_status: update num=%d,rtn=%d\n",results.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"send_update_dc_status:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"send_update_dc_status:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;

}


RetCode::type send_update_health_status(const std::vector<DialHealthResult> & results)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateHealthStatus(results);
				debug_printf(LOG_LEVEL_DEBUG,"send_update_health_status: update num=%d,rtn=%d\n",results.size(),rtn);

		}
		catch(std::exception &e) 
		{
				debug_printf(LOG_LEVEL_TEST,"send_update_health_status:catch an exception!--->%s\n",e.what());
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"send_update_health_status:pthread_create failed!rtn = %d\n",rtn);
				}	
		}

		pthread_mutex_unlock(&client_lock);

		return rtn;

}


RetCode::type send_update_server_status(const std::vector<DialServerResult> & results)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateServerStatus(results);
				debug_printf(LOG_LEVEL_DEBUG,"send_update_server_status:update num=%d,rtn=%d\n",results.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"send_update_server_status:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"send_update_server_status:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}


RetCode::type send_update_nginx_status(const std::vector<DialNginxResult> & results)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateNginxStatus(results);
				debug_printf(LOG_LEVEL_DEBUG,"send_update_nginx_status:update num=%d,rtn=%d\n",results.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"send_update_nginx_status:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"send_update_nginx_status:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}


RetCode::type update_ipsec_online_ip(const std::string& ipsecid, const std::vector<IpAddr> & iplist)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateIpSecOnlineIp(ipsecid,iplist);
				debug_printf(LOG_LEVEL_DEBUG,"update_ipsec_online_ip:ipsecid=%s,iplist_szie=%d,rtn=%d\n",ipsecid.c_str(),iplist.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_ipsec_online_ip:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_ipsec_online_ip:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}


RetCode::type update_interface_info(const std::string& snmp, const std::vector<InterfaceInfo> & interfaces)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateInterfaceInfo(snmp,interfaces);
				debug_printf(LOG_LEVEL_DEBUG,"update_interface_info:interface szie=%d,rtn=%d\n",interfaces.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_interface_info:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_interface_info:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}


RetCode::type update_interface_traffic(const std::string& snmp, const std::vector<InterfaceTraffic> & traffic)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateInterfaceTraffic(snmp,traffic);
				debug_printf(LOG_LEVEL_DEBUG,"update_interface_traffic:rtn=%d\n",rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_interface_traffic:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_interface_traffic:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}


RetCode::type update_interface_ipmac(const std::string& snmp, const std::vector<IpMac> & ipmac) 
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateInterfaceIpMac(snmp,ipmac);
				debug_printf(LOG_LEVEL_DEBUG,"update_interface_ipmac:ipmac size=%d,rtn=%d\n",ipmac.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_interface_ipmac:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_interface_ipmac:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}


RetCode::type update_mac_table(const std::string& snmp, const std::vector<MacTable> & mactable)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateMacTable(snmp,mactable);
				debug_printf(LOG_LEVEL_DEBUG,"update_mac_table:size=%d,rtn=%d\n",mactable.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_mac_table:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_mac_table:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}


RetCode::type update_route_info(const std::string& snmp, const std::vector<RouteInfo> & routeinfo)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateRouteInfo(snmp,routeinfo);
				debug_printf(LOG_LEVEL_DEBUG,"update_route_info:route szie=%d,rtn=%d\n",routeinfo.size(),rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_route_info:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_route_info:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}



RetCode::type update_sys_info(const std::string& snmp, const SysInfo& sysinfo)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateSysInfo(snmp,sysinfo);
				debug_printf(LOG_LEVEL_DEBUG,"update_sys_info:route rtn=%d\n",rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_sys_info:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_sys_info:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}



RetCode::type update_process_info(const std::string& snmp, const ProcessInfo& processinfo)
{
		RetCode::type rtn = RetCode::OK;
		pthread_t td_connecting;

		pthread_mutex_lock(&client_lock);

		if(!client_connecting_flag)
		{
				pthread_mutex_unlock(&client_lock);
				return RetCode::FAIL;
		}

		try
		{
				AgentClient client(protocol_client);

				rtn = client.updateProcessInfo(snmp,processinfo);
				debug_printf(LOG_LEVEL_DEBUG,"update_process_info:route rtn=%d\n",rtn);

		}
		catch(std::exception &e) 
		{
				client_connecting_flag = false;
				transport_client->close(); 
				if (0 != pthread_create(&td_connecting,NULL,client_reconnect_thread,NULL)) 
				{
						debug_printf(LOG_LEVEL_ERROR,"update_process_info:pthread_create failed!rtn = %d\n",rtn);
				}	
				debug_printf(LOG_LEVEL_ERROR,"update_process_info:catch an exception!--->%s\n",e.what());

		}

		pthread_mutex_unlock(&client_lock);

		return rtn;
}



int handle_dial_by_policy(healthpolicy_info_t *policy,char *ip,int port,int * delay)
{
		int ret = 0;

		switch(policy->method) 
		{
				case DIAL_TCPPORT:
				{
						ret = handle_tcp_and_port_dialing(ip,policy->port,delay);
						break;
				}		
				case DIAL_IMCP:
				{
						ret = handle_icmp_dialing(ip,delay);
						break;
				}		
				case DIAL_HTTPGET:
				{
						if(0 == port)
						{
								ret = handle_httpget_dialing(ip,HTTPGET_PORT,(char *)"/",ip,delay);
						}
						else
						{
								ret = handle_httpget_dialing(ip,port,(char *)"/",ip,delay);
						}
						break;
				}		
				case DIAL_DATABASE:
				{
						ret = handle_db_dialing(ip,policy->dial_option.dest_url,policy->dial_option.test_method,delay);
						break;	
				}		
				case DIAL_EXTHTTPGET:
				{
						ret = handle_exthttpget_dialing(ip,ip,&policy->dial_option,delay);
						break;
				}		
				case DIAL_EXTTCPPORT:
				{
						ret = handle_ext_tcp_and_port_dialing(ip,policy,delay);
						break;
				}		
				case DIAL_UDPPORT:
				{
						ret = handle_udp_and_port_dialing(ip,policy->port,delay);
						break;
				}		
				case DIAL_FTP:
				{
						ret = handle_ftp_dialing(ip,policy->dial_option.dest_url,policy->dial_option.test_method,port,delay);
						break;
				}		
				case DIAL_SMTP:
				{
						//ret = handle_smtp_dialing(ip,policy->dial_option.dest_url,policy->dial_option.test_method,port,delay);
						ret = handle_smtp_dialing(ip,port,delay);
						break;
				}		
				case DIAL_SNMP:
				{
						ret = handle_snmp_dialing(ip,policy->dial_option.dest_url,policy->dial_option.test_method,
						policy->dial_option.content_type,policy->dial_option.expect_match,policy->dial_option.tag,port,delay);
						break;
				}		
				case DIAL_NETBIOS:
				{
						ret = handle_netbios_dialing(ip,NETBIOS_PORT,delay);
						break;
				}		
				default:
				{
						ret = ERROR;
						debug_printf(LOG_LEVEL_ERROR,"handle_dial_by_policy:error dial method type=%d\n",policy->method);
						break;
				}		
		}


		return ret;		
}


int get_parameters_from_url(char *src,char *resource,char *ip,int *port,bool *https_flag)
{
		char *pstart = NULL;
		char pport[10] = {0};
		int i = 0;

		if(NULL == src) 
		{
				debug_printf(LOG_LEVEL_ERROR,"get_parameters_from_url:invalid parameter,src is NULL\n");	
				return ERROR;
		}

		pstart = strstr(src,"http://");
		if(NULL == pstart) 
		{
				pstart = strstr(src,"https://");
				if(NULL == pstart) 
				{
						debug_printf(LOG_LEVEL_ERROR,"get_parameters_from_url:invalid parameter,src format error\n");
						return ERROR;
				}
				else 
				{
						pstart += strlen("https://");
						*https_flag = true;
				}

		}
		else 
		{
				pstart += strlen("http://");
				*https_flag = false;
		}


		//get ip
		while(*pstart != '\0') 
		{
				if(':' == *pstart || '/' == *pstart) 
				{
						//pstart++;
						break;
				}
				else 
				{
						*ip++ = *pstart++;
				}
		}

		if('\0' == *pstart || '/' == *pstart) 
		{
				if(false == *https_flag)
				{
						*port = 80;
				}	
				else
				{
						*port = 443;
				}

				if('\0' == *pstart)
				{
						strcpy(resource,"/");
				}	
				else
				{
						strcpy(resource,pstart);
				}	

				return NO_ERROR;
		}

		pstart++;
		//get port
		while(*pstart != '\0') 
		{
				if('/' == *pstart)
				{
						break;
				}	
				else
				{
						pport[i++] = *pstart++;
				}
		}	

		if('\0' == *pstart) 
		{
				*port = atoi(pport);
				strcpy(resource,"/");
		}
		else
		{
				*port = atoi(pport);
				strcpy(resource,pstart);
		}

		return NO_ERROR;
}


void do_a_dial_healthgroup(healthgroup_info_t * hg,healthpolicy_info_t * policy)
{
		int ret = 0,i = 0,j = 0,delay = 0,timeout = 0;
		int success = 0,success_times = 0,failed_times = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = &hg->record_head.head;
		DIAL_LIST_HEAD *phead = &hg->record_head;
		record_info_t *rec = NULL;
		DialHealthResult result;
		std::vector<DialRecordStatus> rr(phead->num);

		list_for_each(cur, head) 
		{
				rec = (record_info_t *)cur;
				success = 0;
				timeout = 0;
				rr[j].rid.assign(rec->rid);

				for(i = 0 ; i < policy->times ; i++) 
				{
						delay = 0;
						ret = handle_dial_by_policy(policy,rec->ip.addr,policy->port,&delay);
						if(NO_ERROR == ret)
						{
								timeout += delay;
								success++;
						}	
						usleep(50);
				}


				if(success > 0)
				{
						rr[j].delay = timeout/success;
				}
				else
				{
						rr[j].delay = 0;
				}

				if(success < policy->passed) 
				{
						rr[j].status = DialStatus::FAIL;
						failed_times++;
				}
				else 
				{
						rr[j].status = DialStatus::OK;
						success_times++;
				}

				debug_printf(LOG_LEVEL_DEBUG,"record:ip=%s,timeout=%d,delay=%lld\n",rec->ip.addr,timeout,rr[j].delay);

				j++;
		}

		debug_printf(LOG_LEVEL_DEBUG,"do_a_dial_healthgroup:group=%s,policy=%s,record_num=%d,success_record=%d,failed_record=%d\n",hg->name,policy->policyname,phead->num,success_times,failed_times);

		if(j > 0) 
		{
				result.groupName.assign(hg->name);
				result.policyName.assign(policy->policyname);
				result.statusList = rr;
				
				pthread_mutex_lock(&health_results_lock);
				health_results.push_back(result);
				pthread_mutex_unlock(&health_results_lock);

		}

}


int generate_dns_package(char *snd_msg,char *domain,int id)
{
		int msglen = 0;

		msglen = dns_fill_query((struct dnshdr_s *)snd_msg,domain,id, __cpu_to_be16(NS_FLAG_RD), __cpu_to_be16(NS_CLASS_IN),__cpu_to_be16(NS_TYPE_A));

		return msglen;
}


int do_dns_dial(char *msg,int msg_len,struct sockaddr_in *servaddr,int fd)
{
		int rtn;
		int anslen;
		union 
		{
				HEADER hdr;
				u_char buf[NS_PACKETSZ];
		} answer;
		struct timeval t_start;
		struct timeval t_end;

		rtn = sendto(fd,msg,msg_len,0,(struct sockaddr *)servaddr, sizeof(struct sockaddr_in));
		if(rtn < 0) 
		{
				debug_printf(LOG_LEVEL_ERROR,"do_dns_dial:sendto failed,rtn = %d\n",rtn);
				return g_cfg.srv_cfg.timeout;
		}

		gettimeofday(&t_start,NULL);

		anslen = recvfrom(fd,&answer,sizeof(answer),0,NULL,NULL);

		if(anslen < 0) 
		{
				debug_printf(LOG_LEVEL_ERROR,"do_dns_dial:recvfrom failed,fd=%d,anslen = %d\n",fd,anslen);
		}

		gettimeofday(&t_end,NULL);

		return ((t_end.tv_sec * 1000*1000 + t_end.tv_usec) - (t_start.tv_sec * 1000*1000 + t_start.tv_usec));

}


void server_dial_by_httpget(dial_srv_node_t *srv)
{
		int i = 0,rtn = 0,delay = 0;
		DialServerStatus server_status;
		RetCode::type rslt = RetCode::OK;
		DialServerResult result;

		for(i = 0;i < g_cfg.srv_cfg.count;i++) 
		{	
				delay = 0;		
				rtn = handle_httpget_dialing(srv->ip.addr,HTTPGET_PORT,(char *)"/",srv->ip.addr,&delay);
				if(NO_ERROR == rtn)
				{
						break;			
				}	
		}

		server_status.rid.assign(srv->srv_id);
		server_status.ip.addr.assign(srv->ip.addr);
		server_status.ip.version = srv->ip.version;
		server_status.delay = delay;


		if(rtn == NO_ERROR && i < g_cfg.srv_cfg.count) 
		{
				server_status.status = DialStatus::OK;
				debug_printf(LOG_LEVEL_DEBUG,"do_a_dial_server:success!!!ip=%s,type=%d,delay=%lld\n",srv->ip.addr,srv->srv_tpye,server_status.delay);
		}	
		else
		{
				server_status.status = DialStatus::FAIL;
				debug_printf(LOG_LEVEL_DEBUG,"do_a_dial_server:failed!!!ip=%s,type=%d,delay=%lld\n",srv->ip.addr,srv->srv_tpye,server_status.delay);
		}

		result.status = server_status;
		result.typ = srv->srv_tpye;
		pthread_mutex_lock(&server_results_lock);
		server_results.push_back(result);
		pthread_mutex_unlock(&server_results_lock);

}

void do_a_dial_dc(dial_srv_node_t *srv,healthpolicy_info_t *policy)
{
		int delay = 0,rtn = 0;
		DialDcResult result;
		result.id.assign(srv->srv_id);
		result.policy.assign(policy->policyname);

		rtn = handle_dial_by_policy(policy,srv->ip.addr,policy->port,&delay);
		if(rtn == NO_ERROR)
		{
				result.status = DialStatus::OK;
				debug_printf(LOG_LEVEL_DEBUG,"do_dc_dial:success!!!ip=%s,delay=%d,policy=%s\n",srv->ip.addr,delay,policy->policyname);
		}
		else
		{
				result.status = DialStatus::FAIL;
				debug_printf(LOG_LEVEL_DEBUG,"do_dc_dial:failed!!!ip=%s,delay=%d,policy=%s\n",srv->ip.addr,delay,policy->policyname);
		}

		result.delay = delay;

		pthread_mutex_lock(&dc_results_lock);
		dc_results.push_back(result);
		pthread_mutex_unlock(&dc_results_lock);
}

int do_a_dial_server(dial_srv_node_t *srv)
{
		int fd = 0;
		int i = 0;
		int rtn = 0;
		char msg[512] = {0};
		struct sockaddr_in servaddr;
		int msg_len = 0;
		int success = 0;
		int timeout = 0;
		int health_value = 0;
		DialServerStatus server_status;
		DialServerResult result;

		if(DialServerType::REDIRECT == srv->srv_tpye)
		{
				server_dial_by_httpget(srv);
				return 0;
		}

		fd = create_client_udp_fd();
		if(ERROR == fd) 
		{
				debug_printf(LOG_LEVEL_ERROR,"do_a_dial_server:creat socket failed!!!ip=%s,type=%d\n",srv->ip.addr,srv->srv_tpye);
				return ERROR;
		}

		memset(&servaddr, 0, sizeof(servaddr));	
		servaddr.sin_family = AF_INET;	
		servaddr.sin_port = htons(53);	
		inet_pton(AF_INET, srv->ip.addr, &servaddr.sin_addr);

		msg_len = generate_dns_package(msg,g_cfg.srv_cfg.dname,(pthread_self() + 1)%0xffff);

		for(i = 0;i < g_cfg.srv_cfg.count;i++) 
		{
				rtn = do_dns_dial(msg,msg_len,&servaddr,fd);
				if(rtn < g_cfg.srv_cfg.timeout*1000) 
				{
						success++;
						timeout += rtn;
				}
		}

		close(fd);

		if(success > 0)
		{
				server_status.delay = timeout/success;
				health_value = (timeout/1000/success*g_cfg.srv_cfg.delay_weight) + (g_cfg.srv_cfg.count - success)*g_cfg.srv_cfg.lost_weight;
		}
		else
		{
				server_status.delay = 0;
		}

		server_status.rid.assign(srv->srv_id);
		server_status.ip.addr.assign(srv->ip.addr);
		server_status.ip.version = srv->ip.version;

		if(success > 0 && health_value < g_cfg.srv_cfg.health) 
		{	
				server_status.status = DialStatus::OK;
				debug_printf(LOG_LEVEL_DEBUG,"do_a_dial_server:success!!!ip=%s,type=%d,health_value=%d,dial_success_times=%d,total_timeout=%d,delay=%lld\n",srv->ip.addr,srv->srv_tpye,health_value,success,timeout,server_status.delay);
		}	
		else
		{
				server_status.status = DialStatus::FAIL;
				debug_printf(LOG_LEVEL_DEBUG,"do_a_dial_server:failed!!!ip=%s,type=%d,health_value=%d,dial_success_times=%d,total_timeout=%d,delay=%lld\n",srv->ip.addr,srv->srv_tpye,health_value,success,timeout,server_status.delay);
		}	

		result.status = server_status;
		result.typ = srv->srv_tpye;

		pthread_mutex_lock(&server_results_lock);
		server_results.push_back(result);
		pthread_mutex_unlock(&server_results_lock);

}


void do_a_dial_nginxgroup(nginxgroup_info_t *ng,healthpolicy_info_t *policy)
{
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = &ng->srv_head.head;
		DIAL_LIST_HEAD *phead = &ng->srv_head;
		nginx_srv_t *srv = NULL;
		int ret = 0,i = 0,j = 0,port = 0,delay = 0,timeout = 0;
		int success = 0,success_times = 0,failed_times = 0;
		char resource[1024];
		char ip[26];
		bool httpsflag;

		DialNginxResult result;
		std::vector<DialNginxStatus> sr(phead->num);
		
		list_for_each(cur, head) 
		{
				srv = (nginx_srv_t *)cur;
				success = 0;
				timeout = 0;
				sr[j].server.localURL.assign(srv->url);
				sr[j].server.priority = srv->priority;

				port = 0;
				httpsflag = false;
				memset(resource,0,sizeof(resource));
				memset(ip,0,sizeof(ip));

				ret = get_parameters_from_url(srv->url,resource,ip,&port,&httpsflag);
				if(ret < 0) 
				{
						goto NEXT_STEP;
				}

				for(i = 0 ; i < policy->times ; i++) 
				{
						delay = 0;
						ret = handle_dial_by_policy(policy,ip,port,&delay);
						if(NO_ERROR == ret)
						{
								timeout += delay;
								success++;
						}	
						usleep(50);
				}

NEXT_STEP:

				if(success > 0)
				{
						sr[j].delay = timeout/success;
				}
				else
				{
						sr[j].delay = 0;
				}


				if(success < policy->passed) 
				{
						sr[j].status = DialStatus::FAIL;
						failed_times++;
				}
				else 
				{
						sr[j].status = DialStatus::OK;
						success_times++;
				}

				j++;
		}

		debug_printf(LOG_LEVEL_DEBUG,"do_a_dial_nginxgroup:group=%s,policy=%s,srv_num=%d,success_srv=%d,failed_srv=%d\n",ng->name,policy->policyname,phead->num,success_times,failed_times);

		if(j > 0) 
		{
				result.groupName.assign(ng->name);
				result.policyName.assign(policy->policyname);
				result.statusList = sr;

				pthread_mutex_lock(&nginx_results_lock);
				nginx_results.push_back(result);
				pthread_mutex_unlock(&nginx_results_lock);
		}

}



int dial_config_check(dial_cfg_t *config)
{
		if(config->srv_cfg.count <= 0)
				config->srv_cfg.count = 1;
		if(config->srv_cfg.health  <= 0)
				config->srv_cfg.count = 5000;
		if(config->srv_cfg.delay_weight  <= 0)
				config->srv_cfg.delay_weight = 10;
		if(config->srv_cfg.lost_weight  <= 0)
				config->srv_cfg.lost_weight = 10;
		if(config->srv_cfg.timeout<= 0)
				config->srv_cfg.timeout = 50;
		if(config->srv_cfg.interval<= 0)
				config->srv_cfg.interval = 5;

		if(strlen(config->srv_cfg.dname) <= 0) 
		{
				memset(config->srv_cfg.dname,0,sizeof(config->srv_cfg.dname));
				strcpy(config->srv_cfg.dname,"www.sina.com");
		}

		if(strlen(config->log_path) <= 0) 
		{
				strcpy(config->log_path,"/var/log/");
		}

		if(config->log_level <= 0) 
		{
				config->log_level = 1;
		}

		cfg_debug_printf(LOG_LEVEL_BASIC,"dial_config_check:dial_config===>health=%d,delay_weight=%d,lost_weight=%d,count=%d,timeout=%d,interval=%d,dname=%s\n",
		config->srv_cfg.health,config->srv_cfg.delay_weight,config->srv_cfg.lost_weight,config->srv_cfg.count,config->srv_cfg.timeout,config->srv_cfg.interval,config->srv_cfg.dname);

}


int load_sys_config(dial_cfg_t *cfg,char *filename)
{
		FILE *fp = NULL;
		char tmp[500] = {0};

		fp = fopen(filename,"r");
		if(NULL == fp) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"load_sys_config:open the file %s failed\n",filename);
				return ERROR;
		}


		while(!feof(fp)) 
		{

				memset(tmp,0,sizeof(tmp));
				fgets(tmp,sizeof(tmp),fp);

				//debug_printf("get tmp is %s",tmp);		
				if(NULL != strstr(tmp,"#dial process port")) 
				{

						fscanf(fp,"port=%d",&cfg->dial_port);

				}
				else if(NULL != strstr(tmp,"#Agent info")) 
				{
						fscanf(fp,"port=%d",&cfg->agent_port);
						fgets(tmp,sizeof(tmp),fp);
						fscanf(fp,"ip=%s",cfg->agent_ip);
				}
				else if(NULL != strstr(tmp,"#server dial config")) 
				{
						fscanf(fp,"health=%d",&cfg->srv_cfg.health);
						fgets(tmp,sizeof(tmp),fp);
						fscanf(fp,"delay_weight=%d",&cfg->srv_cfg.delay_weight);
						fgets(tmp,sizeof(tmp),fp);
						fscanf(fp,"lost_weight=%d",&cfg->srv_cfg.lost_weight);
						fgets(tmp,sizeof(tmp),fp);
						fscanf(fp,"count=%d",&cfg->srv_cfg.count);
						fgets(tmp,sizeof(tmp),fp);
						fscanf(fp,"timeout=%d",&cfg->srv_cfg.timeout);
						fgets(tmp,sizeof(tmp),fp);
						fscanf(fp,"interval=%d",&cfg->srv_cfg.interval);
						fgets(tmp,sizeof(tmp),fp);			
						fscanf(fp,"dname=%s",cfg->srv_cfg.dname);
				}
				else if(NULL != strstr(tmp,"#log config")) 
				{
						fscanf(fp,"path=%s",cfg->log_path);		
						fgets(tmp,sizeof(tmp),fp);
						fscanf(fp,"level=%d",&cfg->log_level);
				}
				else if(NULL != strstr(tmp,"#certificate config")) 
				{
						fscanf(fp,"path=%s",cfg->certificate_file);		
				}

		}

		fclose(fp);

		cfg_debug_printf(LOG_LEVEL_BASIC,"load_sys_config:agent_ip = %s,agent_port=%d,dial_server_port=%d\n",cfg->agent_ip,cfg->agent_port,cfg->dial_port);

		cfg_debug_printf(LOG_LEVEL_BASIC,"load_sys_config:dial_config===>health=%d,delay_weight=%d,lost_weight=%d,count=%d,timeout=%d,interval=%d,dname=%s,log_path=%s,log_level=%d,certificate_file=%s\n",
		cfg->srv_cfg.health,cfg->srv_cfg.delay_weight,cfg->srv_cfg.lost_weight,cfg->srv_cfg.count,cfg->srv_cfg.timeout,cfg->srv_cfg.interval,cfg->srv_cfg.dname,cfg->log_path,cfg->log_level,cfg->certificate_file);

		return NO_ERROR;
}



void thrift_init(int port)
{
		//int port = 9092;
		shared_ptr<DialHandler> handler(new DialHandler());
		shared_ptr<TProcessor> processor(new DialProcessor(handler));
		shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
		shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
		shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

		TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);

		server.serve();
}


void thrift_client_init(char *ip,int port)
{
		boost::shared_ptr<TSocket> tsocket(new TSocket(ip, port));  
		boost::shared_ptr<TTransport> ttransport(new TBufferedTransport(tsocket));  
		boost::shared_ptr<TProtocol> tprotocol(new TBinaryProtocol(ttransport)); 

		transport_client = ttransport;
		protocol_client = tprotocol;
}

int change_tcp_sys_timeout()
{
		FILE* fp = popen("sysctl -w net.ipv4.tcp_syn_retries=1","r");
		if(NULL == fp)
		{   
				return ERROR;
		}   
		pclose(fp);
		return NO_ERROR;
}

int sys_init()
{
		int rtn = 0;
		int agent_port = 0;
		char agent_ip[50] = {0};

	 	rtn = change_tcp_sys_timeout();
		if(rtn == ERROR)
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:switch_signal_init  failed!!\n");
				return ERROR;
		}

		pthread_mutex_init(&g_log_lock,NULL);

#if 0

		s_debug_switch = true;

		rtn = signal_init();
		if(rtn != NO_ERROR) 
		{
				debug_printf(LOG_LEVEL_ERROR,"sys_init:switch_signal_init  failed!!\n");
				return ERROR;
		}

		rtn = sys_log_timer_init();
		if(rtn != NO_ERROR) 
		{
				debug_printf(LOG_LEVEL_ERROR,"sys_init:sys_log_timer_init  failed!!\n");
				return ERROR;
		}

#endif

		memset(&g_cfg,0,sizeof(dial_cfg_t));
		rtn = load_sys_config(&g_cfg,(char *)CONFIG_FILE);
		if(rtn != NO_ERROR) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:load_sys_config  failed!!\n");
				return ERROR;
		}

		dial_config_check(&g_cfg);

		thrift_client_init(g_cfg.agent_ip,g_cfg.agent_port);

		rtn = hash_init_healthpolicy(&hs_health_policy,HASH_POLICY_NUM);
		if(rtn != NO_ERROR) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:init hs_health_policy failed!!\n");
				return ERROR;
		}

		rtn = hash_init_healthgroup(&hs_health_group,HASH_GROUP_NUM);
		if(rtn != NO_ERROR) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:init hs_health_group failed!!\n");
				return ERROR;
		}

		rtn = hash_init_nginxgroup(&hs_nginx_group,HASH_NGINX_NUM);
		if(rtn != NO_ERROR) 
		{
				debug_printf(LOG_LEVEL_ERROR,"sys_init:init hs_nginx_group failed!!\n");
				return ERROR;
		}

		list_head_init(&list_dial_srv);
		queue_init(&queue_info);
		queue_init(&https_queue);

		thread_exit_flag = true;
		cfg_debug_printf(LOG_LEVEL_BASIC,"isPrimary:enable = %d,thread_exit_flag = %d\n",primary_flag,thread_exit_flag);

		if((https_epfd = epoll_create(20001)) < 0)
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"create_https_epfd:failed!!\n");
				return ERROR;
		}

		if ((rtn = pthread_mutex_init(&client_lock,NULL)) != 0) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:pthread_mutex_init client_lock failed!!\n");
				return ERROR;
		}

		if ((rtn = pthread_mutex_init(&health_results_lock,NULL)) != 0) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:pthread_mutex_init health_results_lock failed!!\n");
				return ERROR;
		}

		if ((rtn = pthread_mutex_init(&server_results_lock,NULL)) != 0) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:pthread_mutex_init server_results_lock failed!!\n");
				return ERROR;
		}

		if ((rtn = pthread_mutex_init(&dc_results_lock,NULL)) != 0) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:pthread_mutex_init dc_results_lock failed!!\n");
				return ERROR;
		}

		if ((rtn = pthread_mutex_init(&nginx_results_lock,NULL)) != 0) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:pthread_mutex_init nginx_results_lock failed!!\n");
				return ERROR;
		}

		if ((rtn = pthread_rwlock_init(&ipsec_map_lock,NULL)) != 0) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:pthread_rwlock_init ipsec_map_lock failed!!\n");
				return ERROR;
		}

		if ((rtn = pthread_rwlock_init(&snmp_map_lock,NULL)) != 0) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"sys_init:pthread_rwlock_init snmp_map_lock failed!!\n");
				return ERROR;
		}

		init_openssl();

		return NO_ERROR;
}


inline void add_healthgroup_task_to_queue(healthgroup_info_t *hg,healthpolicy_info_t *policy)
{
		DIAL_LIST_NODE * cur = NULL;
		DIAL_LIST_NODE * tmp = NULL;
		DIAL_LIST_NODE * head = &hg->record_head.head;
		record_info_t * record = NULL;
		record_info_t * record_tmp = NULL;

		healthgroup_info_t *hg_node = (healthgroup_info_t *)calloc(1,sizeof(healthgroup_info_t));
		dial_node_t *task_node = (dial_node_t *)calloc(1,sizeof(dial_node_t));

		strcpy(hg_node->name,hg->name);
		list_head_init(&hg_node->record_head);

		list_for_each_safe(cur,tmp,head)
		{
				record_tmp = (record_info_t*)cur;
				record = (record_info_t*)calloc(1,sizeof(record_info_t));
				memcpy(record,record_tmp,sizeof(record_info_t));
				list_add(&hg_node->record_head,&record->node);
		}

		task_node->policy = policy;
		task_node->type = HEALTHGROUP;
		task_node->dial_node.healthgroup = hg_node;

		switch(policy->method)
		{
				case DIAL_TCPPORT:
				case DIAL_IMCP:
				case DIAL_HTTPGET:
				case DIAL_DATABASE:
				case DIAL_EXTTCPPORT:
				case DIAL_UDPPORT:
				case DIAL_FTP:
				case DIAL_SNMP:
				{
						queue_push(&queue_info, &task_node->node);
						break;
				}
				case DIAL_EXTHTTPGET:
				case DIAL_EXTHTTPPOST:
				case DIAL_HTTPCOMMON:
				{
						queue_push(&https_queue, &task_node->node);
						break;
				}
				case DIAL_SMTP:
				{
						queue_push(&https_queue, &task_node->node);
						#if 0
						if(policy->dial_option.tag)						
						{
								queue_push(&https_queue, &task_node->node);
						}
						else
						{
								queue_push(&queue_info, &task_node->node);
						}
						#endif
						break;
				}
		}
}


inline void add_server_task_to_queue(dial_srv_node_t *node)
{
		dial_srv_node_t *srv_node = (dial_srv_node_t *)calloc(1,sizeof(dial_srv_node_t));
		dial_node_t *task_node = (dial_node_t *)calloc(1,sizeof(dial_node_t));

		memcpy(srv_node,node,sizeof(dial_srv_node_t));

		task_node->type = SERVER;
		task_node->dial_node.srv = srv_node;

		queue_push(&queue_info, &task_node->node);
}


inline void add_dc_task_to_queue(dial_srv_node_t *node,healthpolicy_info_t *policy)
{
		dial_srv_node_t *srv_node = (dial_srv_node_t *)calloc(1,sizeof(dial_srv_node_t));
		dial_node_t *task_node = (dial_node_t *)calloc(1,sizeof(dial_node_t));

		memcpy(srv_node,node,sizeof(dial_srv_node_t));

		task_node->policy = policy;
		task_node->type = DC;
		task_node->dial_node.srv = srv_node;

		switch(policy->method)
		{
				case DIAL_TCPPORT:
				case DIAL_IMCP:
				case DIAL_HTTPGET:
				case DIAL_DATABASE:
				case DIAL_EXTTCPPORT:
				case DIAL_UDPPORT:
				case DIAL_FTP:
				case DIAL_SNMP:
				{
						queue_push(&queue_info, &task_node->node);
						break;
				}
				case DIAL_EXTHTTPGET:
				case DIAL_EXTHTTPPOST:
				case DIAL_HTTPCOMMON:
				{
						queue_push(&https_queue, &task_node->node);
						break;
				}
				case DIAL_SMTP:
				{
						queue_push(&https_queue, &task_node->node);
						break;
				}
		}
}


inline void add_nginxgroup_task_to_queue(nginxgroup_info_t *ng,healthpolicy_info_t *policy)
{
		DIAL_LIST_NODE * cur = NULL;
		DIAL_LIST_NODE * tmp = NULL;
		DIAL_LIST_NODE * head = &ng->srv_head.head;
		nginx_srv_t * nginx_srv = NULL;
		nginx_srv_t * nginx_srv_tmp = NULL;

		nginxgroup_info_t *ng_node = (nginxgroup_info_t *)calloc(1,sizeof(nginxgroup_info_t));
		dial_node_t *task_node = (dial_node_t *)calloc(1,sizeof(dial_node_t));

		strcpy(ng_node->name,ng->name);
		list_head_init(&ng_node->srv_head);

		list_for_each_safe(cur,tmp,head)
		{
				nginx_srv_tmp = (nginx_srv_t*)cur;
				nginx_srv = (nginx_srv_t*)calloc(1,sizeof(nginx_srv_t));
				memcpy(nginx_srv,nginx_srv_tmp,sizeof(nginx_srv_t));
				list_add(&ng_node->srv_head,&nginx_srv->node);
		}

		task_node->policy = policy;
		task_node->type = NGINX;
		task_node->dial_node.nginxgroup = ng_node;

		switch(policy->method)
		{
				case DIAL_TCPPORT:
				case DIAL_IMCP:
				case DIAL_HTTPGET:
				case DIAL_DATABASE:
				case DIAL_EXTTCPPORT:
				case DIAL_UDPPORT:
				case DIAL_FTP:
				case DIAL_SNMP:
				{
						queue_push(&queue_info, &task_node->node);
						break;
				}
				case DIAL_EXTHTTPGET:
				case DIAL_EXTHTTPPOST:
				case DIAL_HTTPCOMMON:
				{
						queue_push(&https_queue, &task_node->node);
						break;
				}
				case DIAL_SMTP:
				{
						queue_push(&https_queue, &task_node->node);
						break;
				}
		}
}


void queue_buffer_destroy(queue_info_t *info)
{
		DIAL_LIST_NODE *node = NULL;	
		healthgroup_info_t *hg = NULL;

		while(NULL != info->tail) 
		{

				node = queue_pop(info);
				hg = (healthgroup_info_t *)node;
				if(NULL != node)
						free(hg);	
		}
}


void dial_srv_list_destroy(DIAL_LIST_HEAD *list)
{
		DIAL_LIST_NODE *cur = NULL;	
		DIAL_LIST_NODE *tmp = NULL;	
		DIAL_LIST_NODE *head = &list->head;
		dial_srv_node_t *srv_node = NULL;

		list_for_each_safe(cur, tmp, head) 
		{
				list_del(&list_dial_srv,cur);
				srv_node = (dial_srv_node_t *)cur;
				if(NULL != srv_node)
						free(srv_node);
		}

}



int sys_free()
{
		threadpool_destroy(&tp);
		hash_destory_healthgroup(&hs_health_group);
		hash_destory_healthgroup(&hs_nginx_group);
		hash_destory_healthpolicy(&hs_health_policy);
		queue_buffer_destroy(&queue_info);	
		dial_srv_list_destroy(&list_dial_srv);

		transport_client->close(); 

		return NO_ERROR;
}


void *healthgroup_monitor_thread(void *arg)
{
		int i = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head =NULL;
		DIAL_LIST_NODE *cur_p = NULL;
		DIAL_LIST_NODE *tmp_p = NULL;
		DIAL_LIST_NODE *head_p =NULL;
		DIAL_LIST_HEAD *phead = NULL;
		pPolicy_node_t *policy = NULL;
		healthgroup_info_t *hg = NULL;
		struct timeval t_now;


		while(thread_exit_flag) 
		{

				if(false == client_connecting_flag || 1 != primary_flag)
				{
						sleep(1);
						continue;
				}

				for(i = 0; i < hs_health_group.num; ++i) 
				{
						cur = NULL;
						head = &(hs_health_group.tab[i].head);
						phead = &(hs_health_group.tab[i]);

						pthread_mutex_lock(&phead->lock);
						list_for_each_safe(cur,tmp,head) 
						{
								hg = (healthgroup_info_t *)cur;
								head_p = &hg->pPolicy_head.head;

								list_for_each_safe(cur_p,tmp_p,head_p) 
								{
										policy = (pPolicy_node_t *)cur_p;

										gettimeofday(&t_now,NULL);
										if(((t_now.tv_sec * 1000*1000 + t_now.tv_usec) - (policy->t_insert.tv_sec * 1000*1000 + policy->t_insert.tv_usec)) >= 0) 
										{

												add_healthgroup_task_to_queue(hg,policy->pPolicy);
												//handle_healthgroup_task(hg,policy->pPolicy);
												policy->t_insert = t_now;
												policy->t_insert.tv_sec += policy->pPolicy->freq;					
										}
								}
						}
						pthread_mutex_unlock(&phead->lock);
				}	
				sleep(1);
		}

}



void *server_monitor_thread(void *arg)
{
		int i = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head =NULL;
		DIAL_LIST_NODE *cur_p = NULL;
		DIAL_LIST_NODE *head_p =NULL;
		DIAL_LIST_HEAD *phead = NULL;
		pPolicy_node_t *policy = NULL;
		dial_srv_node_t *srv_node = NULL;
		struct timeval t_now;

		while(thread_exit_flag) 
		{

				if(false == client_connecting_flag || 1 != primary_flag)
				{
						sleep(1);
						continue;
				}

				cur = NULL;
				head = &list_dial_srv.head;
				phead = &list_dial_srv;

				pthread_mutex_lock(&phead->lock);
				list_for_each(cur,head) 
				{

						srv_node = (dial_srv_node_t *)cur;
						gettimeofday(&t_now,NULL);
						
						if(DialServerType::DATACENTER != srv_node->srv_tpye && CMP_TIME(t_now,srv_node->t_insert) > 0)
						{
								add_server_task_to_queue(srv_node);
								srv_node->t_insert = t_now;
								srv_node->t_insert.tv_sec += g_cfg.srv_cfg.interval;					
						}				
						else if(DialServerType::DATACENTER == srv_node->srv_tpye)
						{
								head_p = &srv_node->pPolicy_head.head;
								list_for_each(cur_p,head_p)
								{
										policy = (pPolicy_node_t *)cur_p;

										if(CMP_TIME(t_now,policy->t_insert) > 0)
										{
												add_dc_task_to_queue(srv_node,policy->pPolicy);
												policy->t_insert = t_now;
												policy->t_insert.tv_sec += policy->pPolicy->freq;					
										}
								}
						}
				}
				pthread_mutex_unlock(&phead->lock);

				sleep(1);
		}

}



void *nginxgroup_monitor_thread(void *arg)
{
		int i = 0;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *tmp = NULL;
		DIAL_LIST_NODE *head =NULL;
		DIAL_LIST_HEAD *phead = NULL;
		DIAL_LIST_NODE *cur_p = NULL;
		DIAL_LIST_NODE *tmp_p = NULL;
		DIAL_LIST_NODE *head_p =NULL;
		pPolicy_node_t *policy = NULL;
		nginxgroup_info_t *ng = NULL;
		struct timeval t_now;


		while(thread_exit_flag) 
		{

				if(false == client_connecting_flag || 1 != primary_flag)
				{
						sleep(1);
						continue;
				}	

				for(i = 0; i < hs_nginx_group.num; ++i) 
				{

						cur = NULL;
						head = &(hs_nginx_group.tab[i].head);
						phead = &(hs_nginx_group.tab[i]);

						pthread_mutex_lock(&phead->lock);
						list_for_each_safe(cur,tmp,head) 
						{
								ng = (nginxgroup_info_t *)cur;

								head_p = &ng->pPolicy_head.head;
								list_for_each_safe(cur_p,tmp_p,head_p) 
								{
										policy = (pPolicy_node_t *)cur_p;

										gettimeofday(&t_now,NULL);
										if(((t_now.tv_sec * 1000*1000 + t_now.tv_usec) - (policy->t_insert.tv_sec * 1000*1000 + policy->t_insert.tv_usec)) >= 0) 
										{

												add_nginxgroup_task_to_queue(ng,policy->pPolicy);

												policy->t_insert = t_now;
												policy->t_insert.tv_sec += policy->pPolicy->freq;					
										}
								}
						}
						pthread_mutex_unlock(&phead->lock);
				}	
				sleep(1);
		}

}


void *ipsec_monitor_thread(void *arg)
{
		int res = 0;
		map<string,ipsec_node_t>::iterator iter;

		while(thread_exit_flag) 
		{
				if(false == client_connecting_flag)
				{
						sleep(1);
						continue;
				}
				
				pthread_rwlock_rdlock(&ipsec_map_lock);

				for(iter = ipsec_map.begin() ; iter != ipsec_map.end() ; iter++)
				{
						if(0 != iter->second.tid)
						{
								continue;
						}

						iter->second.work_flag = true;
						res = pthread_create(&iter->second.tid,NULL,ipsec_work_thread,&iter->second);
						if(0 != res)
						{
								iter->second.tid = 0;
								iter->second.work_flag = false;
								debug_printf(LOG_LEVEL_ERROR,"create ipsec work thread failed,ip=%s\n",iter->second.ipsec.ipsec.ip.addr.c_str());
						}

						debug_printf(LOG_LEVEL_BASIC,"create a ipsec task thread ipsec=%s,tid=%u\n",iter->second.ipsec.ipsec.ip.addr.c_str(),iter->second.tid);
				}

				pthread_rwlock_unlock(&ipsec_map_lock);

				sleep(1);
		}
}


void *snmpgroup_monitor_thread(void *arg)
{
		int res = 0;
		map<string,snmp_node_t>::iterator iter;

		while(thread_exit_flag) 
		{
				if(false == client_connecting_flag)
				{
						sleep(1);
						continue;
				}

				pthread_rwlock_rdlock(&snmp_map_lock);

				for(iter = snmp_map.begin() ; iter != snmp_map.end() ; iter++)
				{
						if(0 != iter->second.tid)
						{
								continue;
						}

						iter->second.work_flag = true;
						res = pthread_create(&iter->second.tid,NULL,snmp_work_thread,&iter->second);
						if(0 != res)
						{
								iter->second.tid = 0;
								iter->second.work_flag = false;
								debug_printf(LOG_LEVEL_BASIC,"create a snmp task thread failed!! ip=%s\n",iter->second.snmp.ip.addr.c_str());
						}
						debug_printf(LOG_LEVEL_BASIC,"create a snmp task thread success!! ip=%s,tid=%u\n",iter->second.snmp.ip.addr.c_str(),iter->second.tid);
				}

				pthread_rwlock_unlock(&snmp_map_lock);

				sleep(1);
		}
}


void updata_dc_result(int sec)
{
		int size = dc_results.size();

		if(size >= 2000 || (size > 0 && size < 2000 && sec == 5))
		{
				debug_printf(LOG_LEVEL_TEST,"send update dc group num = %d\n",size);
				pthread_mutex_lock(&health_results_lock);
				send_update_dc_status(dc_results);
				dc_results.clear();
				pthread_mutex_unlock(&health_results_lock);
		}
}


void update_nginxgroup_result(int sec)
{
		int size = nginx_results.size();

		if(size >= 2000 || (size > 0 && size < 2000 && sec == 5))
		{
				debug_printf(LOG_LEVEL_TEST,"send update nginx group num = %d\n",size);
				pthread_mutex_lock(&nginx_results_lock);
				send_update_nginx_status(nginx_results);
				nginx_results.clear();
				pthread_mutex_unlock(&nginx_results_lock);
		}
}


void updata_server_result(int sec)
{
		int size = server_results.size();

		if(size >= 2000 || (size > 0 && size < 2000 && sec == 5))
		{
				debug_printf(LOG_LEVEL_TEST,"send update server num = %d\n",size);
				pthread_mutex_lock(&server_results_lock);
				send_update_server_status(server_results);
				server_results.clear();
				pthread_mutex_unlock(&server_results_lock);
		}
}


void update_healthgroup_result(int sec)
{
		int size = health_results.size();

		if(size >= 2000 || (size > 0 && size < 2000 && sec == 5))
		{
				debug_printf(LOG_LEVEL_TEST,"send update health group num = %d\n",size);
				pthread_mutex_lock(&health_results_lock);
				send_update_health_status(health_results);
				health_results.clear();
				pthread_mutex_unlock(&health_results_lock);
		}
}


void *updata_result_thread(void*arg)
{
		int sec = 0;

		while(thread_exit_flag)
		{
				update_healthgroup_result(sec);
				updata_server_result(sec);
				updata_dc_result(sec);
				update_nginxgroup_result(sec);

				if(sec == 5)
				{
						sec = 0;	
				}
				
				sleep(1);
				sec++;
		}
}

void *dial_monitor_queue_thread(void *arg)
{    
		int i = 0,count = 0;

		while(thread_exit_flag) 
		{
				if(false == client_connecting_flag || 1 != primary_flag)
				{
						debug_printf(LOG_LEVEL_DEBUG,"client_connecting_flag=%d,primary_flag=%d!!\n",client_connecting_flag,primary_flag);
						sleep(1);
						continue;
				}	
				
				//if(tp.threads_used < tp.act_threads_num && NULL != queue_info.tail && queue_info.cnt > 0) 
				if(tp.threads_used < tp.act_threads_num && queue_info.cnt > 0) 
				{
						pthread_cond_signal(&tp.cond);
						debug_printf(LOG_LEVEL_TEST,"signaling queue task num=%d task,used thread num=%d!!\n",queue_info.cnt,tp.threads_used);
						continue;
				}
				else if(queue_info.cnt > 50000 && NULL != queue_info.tail && tp.threads_used == tp.act_threads_num)
				{
						debug_printf(LOG_LEVEL_TEST,"clear start! queue task num=%d,used thread num=%d!!\n",queue_info.cnt,tp.threads_used);
						queue_clear(&queue_info);
						debug_printf(LOG_LEVEL_TEST,"clear over! queue task num=%d,used thread num=%d!!\n",queue_info.cnt,tp.threads_used);
				}
		
				sleep(1);
				debug_printf(LOG_LEVEL_DEBUG,"queue task num=%d task,used thread num=%d!!\n",queue_info.cnt,tp.threads_used);

		}
}


void *start_register_thread(void *arg)
{
		cfg_debug_printf(LOG_LEVEL_BASIC,"start_register_thread:register start!!!\n");
		bool success_flag = true;

		while(1) 
		{
				if(success_flag)
				{
						usleep(50*1000);
				}	
				else
				{
						sleep(2);
				}

				try
				{
						RetCode::type ret;

						transport_client->open(); 
						AgentClient client(protocol_client);
						ret = client.registerModule(ModuleType::DIALING);
						if(ret != RetCode::OK) 
						{
								debug_printf(LOG_LEVEL_ERROR,"start_register_thread:register failed,continue!!\n");
								continue;
						}

				}
				catch(std::exception &e) 
				{
						success_flag = false;
						debug_printf(LOG_LEVEL_ERROR,"start_register_thread:catch an exception!-->%s\n",e.what());
						continue;
				}
				client_connecting_flag = true;
				registered_flag = true;
				break;
		}
		cfg_debug_printf(LOG_LEVEL_BASIC,"start_register_thread:register success!!!\n");
}



void *client_reconnect_thread(void *arg)
{
		cfg_debug_printf(LOG_LEVEL_BASIC,"client_reconnect_thread: register start!\n");
		bool success_flag = true;

		while(1) 
		{
				sleep(1);

				try
				{

						transport_client->open(); 

				}
				catch(std::exception &e) 
				{
						debug_printf(LOG_LEVEL_ERROR,"client_reconnect_thread:catch an exception!-->%s\n",e.what());
						continue;
				}
				client_connecting_flag = true;
				break;
		}
		cfg_debug_printf(LOG_LEVEL_DEBUG,"client_reconnect_thread: register success!!!\n");
}



int set_core_file()
{
		struct rlimit rlim_new,rlim;

		if (getrlimit(RLIMIT_CORE, &rlim)==0) 
		{
				rlim_new.rlim_cur = rlim_new.rlim_max = RLIM_INFINITY;
				if (setrlimit(RLIMIT_CORE, &rlim_new)!=0) 
				{
						rlim_new.rlim_cur = rlim_new.rlim_max = rlim.rlim_max;
						(void) setrlimit(RLIMIT_CORE, &rlim_new);			
						cfg_debug_printf(LOG_LEVEL_ERROR,"set_core_file:setrlimit failed!!\n");
						return -1;
				}
		}
		else
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"set_core_file:getrlimit failed!!\n");
				return -1;
		}

		return 0;
}

int set_file_limit()
{
		rlimit tmp = {262143,262144};
		int rtn = setrlimit(RLIMIT_NOFILE,&tmp); 
		if(rtn != 0)
		{
				return -1;
		}
		cfg_debug_printf(LOG_LEVEL_BASIC,"set file max rlim_cur=%d,rlim_max=%d\n",tmp.rlim_cur,tmp.rlim_max);
		return 0;
}

void log_debug_open(int sig)
{
	s_debug_switch = true;
}


void log_debug_close(int sig)
{
	s_debug_switch = false;
}


void set_timer_handler(int sig)
{
	debug_printf(LOG_LEVEL_BASIC,"set_timer_handler:log closed!!\n");

	log_debug_close(sig);
}


int signal_init()
{

		// 
		if(SIG_ERR == signal(SIGUSR1,log_debug_close)) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"signal_init:can't catch SIGUSR1!!\n");
				return ERROR;
		}
		if(SIG_ERR == signal(SIGUSR2,log_debug_open)) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"signal_init:can't catch SIGUSR2!!\n");
				return ERROR;
		}
		//
		if(SIG_ERR == signal(SIGALRM,set_timer_handler)) 
		{
				cfg_debug_printf(LOG_LEVEL_ERROR,"signal_init:can't catch SIGALRM!!\n");
				return ERROR;
		}
		return NO_ERROR;
}


int sys_log_timer_init()
{	
		struct itimerval 		timer; 
		int ret = 0;

		memset(&timer, 0, sizeof(timer));

		timer.it_value.tv_sec = 5*60;
		timer.it_value.tv_usec = 0;
		timer.it_interval = timer.it_value;

		ret = setitimer(ITIMER_REAL, &timer, NULL);
		if(ret < 0) 
		{
				debug_printf(LOG_LEVEL_ERROR,"sys_log_timer_init:setitimer failed!!\n");
				return ERROR;
		}

		return NO_ERROR;	   
}


void parse_arg(int argc,char **argv,bool &need_daemon)
{
		int i = 0;

		if(argc >= 2)
		{
				for(i = 1; i < argc; i++)
				{

						if (strcmp("start", argv[i]) == 0) 
						{
								need_daemon = true;
								continue;
						} 
						else if (strcmp("stop", argv[i]) == 0) 
						{
								daemon_stop();
								exit(0);
						} 
						else if (strcmp("restart", argv[i]) == 0) 
						{
								daemon_stop();
								need_daemon = true;
								continue;
						}
						else if(strcmp("-v", argv[i]) == 0)
						{
								printf("%s",DIAL_VERSION);
								exit(0);
						} 
						else 
						{
								printf("unkown param:%s\n",argv[i]);
								exit(0);
						}
				}
		}
		else
		{
				printf("usage:dial start|stop|restart\n");
				exit(0);
		}

}


void monitor_thread_join(pthread_t*td,int monitor_thread_num)
{
		int i = 0;

		for(i = 0 ; i < monitor_thread_num ; i++)
		{
				pthread_join(td[i],NULL);
		}
}


#define USE_OPENSSL
#ifdef USE_OPENSSL
static pthread_mutex_t *lockarray;
static void lock_callback(int mode, int type, char *file, int line)
{
		(void)file;
		(void)line;
		if(mode & CRYPTO_LOCK) {
				pthread_mutex_lock(&(lockarray[type]));
		}
		else {
				pthread_mutex_unlock(&(lockarray[type]));
		}
}

static unsigned long thread_id(void)
{
		unsigned long ret;

		ret = (unsigned long)pthread_self();
		return ret;
}

static void init_locks(void)
{
		int i;

		lockarray = (pthread_mutex_t *)OPENSSL_malloc(CRYPTO_num_locks() *
						sizeof(pthread_mutex_t));
		for(i = 0; i<CRYPTO_num_locks(); i++) {
				pthread_mutex_init(&(lockarray[i]), NULL);
		}

		CRYPTO_set_id_callback((unsigned long (*)())thread_id);
		CRYPTO_set_locking_callback((void (*)(int,int,const char*,int))lock_callback);
}

static void kill_locks(void)
{
		int i;

		CRYPTO_set_locking_callback(NULL);
		for(i = 0; i<CRYPTO_num_locks(); i++)
				pthread_mutex_destroy(&(lockarray[i]));

		OPENSSL_free(lockarray);
}
#endif

const char *http_get = 
"GET %s HTTP/1.1\r\n"
"Host: %s\r\n"
"User-Agent: Mozilla/5.0 (Windows NT 6.2; WOW64; rv:40.0) Gecko/20100101 Firefox/40.0\r\n"
"Accept: */*\r\n"
"Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3\r\n"
"Accept-Encoding: gzip, deflate\r\n"
"\r\n";

const char *http_post = 
"POST %s HTTP/1.1\r\n"
"Host: %s\r\n"
"User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; Trident/4.0)\r\n"
"Accept: */*\r\n"
"Content-Type: %s\r\n"
"Content-Length: %d\r\n"
"\r\n"
"%s";

typedef struct event_node
{
		bool https_flag;
		char send_buf[4096];
		char pattern[1024];
		char resource[256];
		char rid[64];
		char hg[64];
		char ip[64];
		char policy[64];
		int send_len;
		int sockfd;
		int epfd;
		int flag;
		int dial_type;
		int priority;
		struct sockaddr_in dest;
		struct timeval t_start;
		struct timeval t_end;
		SSL_CTX * ctx;
		SSL * ssl;

}ev_t;


int handle_healthgroup_http_task(dial_node_t*task_node)
{
		bool https_flag;
		int sockfd = 0,rtn = 0,port = 0;
		char resource[256] ={'\0'};
		char url_ip[30] = {'\0'};
		DIAL_LIST_NODE *node = NULL;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *phead = NULL;
		record_info_t *rec = NULL;

		head = &task_node->dial_node.healthgroup->record_head.head;
		phead = &task_node->dial_node.healthgroup->record_head;

		list_for_each(cur,head) 
		{
				rec = (record_info_t*)cur;

				if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
				{
						debug_printf(LOG_LEVEL_TEST,"%s-%d-https_monitor_thread create socket failed!!\n",__func__,__LINE__);
						break;
				}

				fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);

				if(task_node->policy->method == DIAL_SMTP)
				{
						if(task_node->policy->dial_option.tag)
						{
								https_flag = true;
						}
						else
						{
								https_flag = false;
						}
						port = task_node->policy->port;
						memset(url_ip,0,30);
						strcpy(url_ip,rec->ip.addr);
				}
				else
				{
						port = 0;
						memset(resource,0,256);
						memset(url_ip,0,30);
						rtn = get_parameters_from_url(task_node->policy->dial_option.dest_url,resource,url_ip,&port,&https_flag);
						if(NO_ERROR != rtn)
						{
								close(sockfd);
								debug_printf(LOG_LEVEL_ERROR,"https_monitor_thread :get partten from url failed,record_ip=%s\n",rec->ip.addr);
								break;
						}	
						if(!strcmp(url_ip,"$domain")) 
						{
								strcpy(url_ip,rec->ip.addr);
						}
				}

				ev_t * my_ev = (ev_t*)calloc(1,sizeof(ev_t));
				strcpy(my_ev->rid,rec->rid);
				strcpy(my_ev->ip,url_ip);
				strcpy(my_ev->hg,task_node->dial_node.healthgroup->name);
				strcpy(my_ev->policy,task_node->policy->policyname);
				sprintf(my_ev->pattern,".*?%s.*?",task_node->policy->dial_option.expect_match);
				//debug_printf(LOG_LEVEL_DEBUG,"%s-%d-pattern=\n%s\n",__func__,__LINE__,my_ev->pattern);
				if(task_node->policy->method == DIAL_EXTHTTPPOST)
				{
						sprintf(my_ev->send_buf,http_post,resource,url_ip,task_node->policy->dial_option.content_type,
										strlen(task_node->policy->dial_option.test_method),task_node->policy->dial_option.test_method);
				}
				else if(task_node->policy->method == DIAL_EXTHTTPGET)
				{
						sprintf(my_ev->send_buf,http_get,resource,url_ip);
				}
				else if(task_node->policy->method == DIAL_HTTPCOMMON)
				{
						strcpy(my_ev->send_buf,task_node->policy->dial_option.test_method);
				}
				else if(task_node->policy->method == DIAL_SMTP)
				{
						strcpy(my_ev->send_buf,"ehlo localhost\r\n");
				}
				//debug_printf(LOG_LEVEL_DEBUG,"send=\n%s\n",my_ev->send_buf);
				my_ev->send_len = strlen(my_ev->send_buf);
				my_ev->sockfd = sockfd;
				my_ev->epfd = https_epfd;
				my_ev->flag = 1;
				my_ev->dial_type = HEALTHGROUP;
				my_ev->https_flag = https_flag;
				my_ev->dest.sin_family = AF_INET;
				my_ev->dest.sin_port = htons(port);
				inet_pton(AF_INET,url_ip,&(my_ev->dest.sin_addr.s_addr));
				gettimeofday(&my_ev->t_start,NULL);

				struct epoll_event ev;
				ev.events = EPOLLIN | EPOLLOUT | EPOLLET;
				ev.data.ptr = my_ev;
				rtn = epoll_ctl(https_epfd,EPOLL_CTL_ADD,sockfd,&ev);
				if(rtn < 0)
				{
						debug_printf(LOG_LEVEL_TEST,"%s-%d-epoll add failed ip=%s,sockfd=%d\n",__func__,__LINE__,url_ip,sockfd);
						free(my_ev);
						close(sockfd);
						break;
				}

				connect(sockfd,(struct sockaddr*)&my_ev->dest,sizeof(sockaddr_in));

#if 0
				if (connect(sockfd,(struct sockaddr*)&my_ev->dest,sizeof(sockaddr_in)) < 0) 
				{
						if (errno != EINPROGRESS && errno != EINTR) 
						{
								debug_printf(LOG_LEVEL_TEST,"%s-%d-connect error\n",__func__,__LINE__);
								epoll_ctl(https_epfd, EPOLL_CTL_DEL,sockfd,NULL);
								free(my_ev);
								close(sockfd);
								break;
						}
				}
				else
				{
						debug_printf(LOG_LEVEL_TEST,"send ip = %s,sockfd = %d\n",url_ip,sockfd);
				}
				//debug_printf(LOG_LEVEL_BASIC,"ip=%s,sockfd=%d,port=%d,source=%s\n",url_ip,sockfd,port,resource);
#endif
		}

		return 0;
}


int handle_nginxgroup_http_task(dial_node_t* task_node)
{
		bool https_flag;
		int sockfd = 0,rtn = 0,port = 0;
		char resource[256] ={'\0'};
		char url_ip[30] = {'\0'};
		DIAL_LIST_NODE *node = NULL;
		DIAL_LIST_NODE *cur = NULL;
		DIAL_LIST_NODE *head = NULL;
		DIAL_LIST_HEAD *phead = NULL;
		nginx_srv_t *srv = NULL;

		head = &task_node->dial_node.nginxgroup->srv_head.head;
		phead = &task_node->dial_node.nginxgroup->srv_head;

		list_for_each(cur,head) 
		{
				srv = (nginx_srv_t*)cur;

				if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
				{
						debug_printf(LOG_LEVEL_TEST,"%s-%d-https_monitor_thread create socket failed!!\n",__func__,__LINE__);
						break;
				}

				fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);

				port = 0;
				memset(resource,0,256);
				memset(url_ip,0,30);
				rtn = get_parameters_from_url(srv->url,resource,url_ip,&port,&https_flag);
				if(NO_ERROR != rtn)
				{
						close(sockfd);
						debug_printf(LOG_LEVEL_ERROR,"https_monitor_thread :get partten from url failed,url=%s\n",srv->url);
						break;
				}

				if(task_node->policy->method == DIAL_SMTP)
				{
						if(task_node->policy->dial_option.tag)
						{
								https_flag = true;
						}
						else
						{
								https_flag = false;
						}
						port = task_node->policy->port;
				}

				ev_t * my_ev = (ev_t*)calloc(1,sizeof(ev_t));
				strcpy(my_ev->rid,srv->url);
				strcpy(my_ev->ip,url_ip);
				strcpy(my_ev->hg,task_node->dial_node.nginxgroup->name);
				strcpy(my_ev->policy,task_node->policy->policyname);
				sprintf(my_ev->pattern,".*?%s.*?",task_node->policy->dial_option.expect_match);
				//debug_printf(LOG_LEVEL_DEBUG,"%s-%d-nginxurl=%s,ip=%s\n",__func__,__LINE__,my_ev->rid,my_ev->ip);
				//debug_printf(LOG_LEVEL_DEBUG,"%s-%d-pattern=\n%s\n",__func__,__LINE__,my_ev->pattern);
				if(task_node->policy->method == DIAL_EXTHTTPPOST)
				{
						sprintf(my_ev->send_buf,http_post,resource,url_ip,task_node->policy->dial_option.content_type,
										strlen(task_node->policy->dial_option.test_method),task_node->policy->dial_option.test_method);
				}
				else if(task_node->policy->method == DIAL_EXTHTTPGET)
				{
						sprintf(my_ev->send_buf,http_get,resource,url_ip);
				}
				else if(task_node->policy->method == DIAL_HTTPCOMMON)
				{
						strcpy(my_ev->send_buf,task_node->policy->dial_option.test_method);
				}
				else if(task_node->policy->method == DIAL_SMTP)
				{
						strcpy(my_ev->send_buf,"ehlo localhost\r\n");
				}
				//debug_printf(LOG_LEVEL_DEBUG,"send=\n%s\n",my_ev->send_buf);
				my_ev->send_len = strlen(my_ev->send_buf);
				my_ev->sockfd = sockfd;
				my_ev->epfd = https_epfd;
				my_ev->flag = 1;
				my_ev->dial_type = NGINX;
				my_ev->priority = srv->priority;
				my_ev->https_flag = https_flag;
				my_ev->dest.sin_family = AF_INET;
				my_ev->dest.sin_port = htons(port);
				inet_pton(AF_INET,url_ip,&(my_ev->dest.sin_addr.s_addr));
				gettimeofday(&my_ev->t_start,NULL);

				struct epoll_event ev;
				ev.events = EPOLLIN | EPOLLOUT | EPOLLET;
				ev.data.ptr = my_ev;
				rtn = epoll_ctl(https_epfd,EPOLL_CTL_ADD,sockfd,&ev);
				if(rtn < 0)
				{
						debug_printf(LOG_LEVEL_TEST,"%s-%d-epoll add failed ip=%s,sockfd=%d\n",__func__,__LINE__,url_ip,sockfd);
						free(my_ev);
						close(sockfd);
						break;
				}

				connect(sockfd,(struct sockaddr*)&my_ev->dest,sizeof(sockaddr_in));
		}

		return 0;
}

int handle_dc_http_task(dial_node_t* task_node)
{
		bool https_flag;
		int sockfd = 0,rtn = 0,port = 0;
		char resource[256] ={'\0'};
		char url_ip[30] = {'\0'};
		dial_srv_node_t* srv = task_node->dial_node.srv;
		healthpolicy_info_t* policy = task_node->policy; 

		if ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) < 0) 
		{
				debug_printf(LOG_LEVEL_TEST,"%s-%d-create socket failed!!\n",__func__,__LINE__);
				return -1;
		}

		fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL, 0) | O_NONBLOCK);

		if(task_node->policy->method == DIAL_SMTP)
		{
				if(task_node->policy->dial_option.tag)
				{
						https_flag = true;
				}
				else
				{
						https_flag = false;
				}
				port = task_node->policy->port;
				memset(url_ip,0,30);
				strcpy(url_ip,srv->ip.addr);
		}
		else
		{
				rtn = get_parameters_from_url(policy->dial_option.dest_url,resource,url_ip,&port,&https_flag);
				if(NO_ERROR != rtn)
				{
						close(sockfd);
						debug_printf(LOG_LEVEL_ERROR,"%s-%d-get partten from url failed,record_ip=%s\n",__func__,__LINE__,srv->ip.addr);
						return -1;
				}	
				if(!strcmp(url_ip,"$domain")) 
				{
						strcpy(url_ip,srv->ip.addr);
				}
		}

		ev_t * my_ev = (ev_t*)calloc(1,sizeof(ev_t));
		strcpy(my_ev->rid,srv->srv_id);
		strcpy(my_ev->ip,url_ip);
		strcpy(my_ev->policy,policy->policyname);
		sprintf(my_ev->pattern,".*?%s.*?",policy->dial_option.expect_match);
		//debug_printf(LOG_LEVEL_DEBUG,"%s-%d-pattern=\n%s\n",__func__,__LINE__,my_ev->pattern);
		if(policy->method == DIAL_EXTHTTPPOST)
		{
				sprintf(my_ev->send_buf,http_post,resource,url_ip,policy->dial_option.content_type,
								strlen(policy->dial_option.test_method),policy->dial_option.test_method);
		}
		else if(policy->method == DIAL_EXTHTTPGET)
		{
				sprintf(my_ev->send_buf,http_get,resource,url_ip);
		}
		else if(policy->method == DIAL_HTTPCOMMON)
		{
				strcpy(my_ev->send_buf,policy->dial_option.test_method);
		}
		else if(task_node->policy->method == DIAL_SMTP)
		{
				strcpy(my_ev->send_buf,"ehlo localhost\r\n");
		}
		//debug_printf(LOG_LEVEL_DEBUG,"send=\n%s\n",my_ev->send_buf);
		my_ev->send_len = strlen(my_ev->send_buf);
		my_ev->sockfd = sockfd;
		my_ev->epfd = https_epfd;
		my_ev->flag = 1;
		my_ev->dial_type = DC;
		my_ev->https_flag = https_flag;
		my_ev->dest.sin_family = AF_INET;
		my_ev->dest.sin_port = htons(port);
		inet_pton(AF_INET,url_ip,&(my_ev->dest.sin_addr.s_addr));
		gettimeofday(&my_ev->t_start,NULL);

		struct epoll_event ev;
		ev.events = EPOLLIN | EPOLLOUT | EPOLLET;
		ev.data.ptr = my_ev;
		rtn = epoll_ctl(https_epfd,EPOLL_CTL_ADD,sockfd,&ev);
		if(rtn < 0)
		{
				debug_printf(LOG_LEVEL_TEST,"%s-%d-epoll add failed ip=%s,sockfd=%d\n",__func__,__LINE__,url_ip,sockfd);
				free(my_ev);
				close(sockfd);
				return -1;
		}

		connect(sockfd,(struct sockaddr*)&my_ev->dest,sizeof(sockaddr_in));

		return 0;
}

void* https_monitor_thread(void*arg)
{
		DIAL_LIST_NODE *node = NULL;
		dial_node_t *task_node = NULL;

		while(tp.threads_run_flag) 
		{
				if(false == client_connecting_flag || 1 != primary_flag)
				{
						sleep(1);
						continue;
				}

				while(NULL != (node = queue_pop(&https_queue))) 
				{
						task_node = (dial_node_t *)node;

						if(false == client_connecting_flag || 1 != primary_flag)
						{
								task_node_free(task_node);
								break;
						}

						if(task_node->type == HEALTHGROUP)
						{
								handle_healthgroup_http_task(task_node);
						}
						else if(task_node->type == NGINX)
						{
								handle_nginxgroup_http_task(task_node);
						}
						else if(task_node->type == DC)
						{
								handle_dc_http_task(task_node);
						}

						task_node_free(task_node);
				}
				usleep(100*1000);
		}		
}

void clean_ev(ev_t*ev)
{
		epoll_ctl(ev->epfd,EPOLL_CTL_DEL,ev->sockfd,NULL);
		if(ev->ssl)
		{
				SSL_shutdown(ev->ssl);
				SSL_free(ev->ssl);
		}
		if(ev->ctx)
		{
				SSL_CTX_free(ev->ctx);
		}		
		close(ev->sockfd);
		free(ev);
}

int ssl_connect_write(ev_t*ev)
{
		int rtn = 0;
		int ssl_conn_ret = SSL_connect(ev->ssl);
		//int ssl_conn_ret = SSL_do_handshake(ev->ssl);
		if (1 == ssl_conn_ret) 
		{
				while((rtn = SSL_write(ev->ssl,ev->send_buf,ev->send_len)) < 0)
				{
						int ssl_conn_err = SSL_get_error(ev->ssl,rtn);
						if (SSL_ERROR_WANT_WRITE == ssl_conn_err) 
						{
								continue;
						}
						debug_printf(LOG_LEVEL_ERROR,"%s-%d-%s-ssl send error,rtn=%d\n",__func__,__LINE__,ev->ip,rtn);
						return -1;
				}
				if(rtn == ev->send_len)
				{
						ev->flag = 3;
						debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-ssl send msg success,send_len=%d\n",__func__,__LINE__,ev->ip,rtn);
						//debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-ssl send_buf=\n%s\n",__func__,__LINE__,ev->ip,ev->send_buf);
						return 0;
				}		
				debug_printf(LOG_LEVEL_ERROR,"%s-%d-%s-ssl send msg failed,send_len=%d\n",__func__,__LINE__,ev->ip,rtn);
				return -1;
		}

		int ssl_conn_err = SSL_get_error(ev->ssl,ssl_conn_ret);
		if (SSL_ERROR_WANT_WRITE == ssl_conn_err||SSL_ERROR_WANT_READ == ssl_conn_err) 
		{
				ev->flag = 2;
				debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-ssl connect continue\n",__func__,__LINE__,ev->ip);
				return 0;
		}

		debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-ssl connect failed\n",__func__,__LINE__,ev->ip);
		return -1;
}

int ssl_first_connect_write(ev_t*ev)
{
		int rtn = 0;
		ev->ctx = SSL_CTX_new(SSLv23_client_method());
		if(ev->ctx == NULL)
		{
				debug_printf(LOG_LEVEL_ERROR,"%s-%d-%s-ssl_ctx_new failed\n",__func__,__LINE__,ev->ip);
				return -1;
		}

		ev->ssl = SSL_new(ev->ctx);
		if(ev->ssl == NULL)
		{
				debug_printf(LOG_LEVEL_ERROR,"%s-%d-%s-ssl_new failed\n",__func__,__LINE__,ev->ip);
				return -1;
		}

		SSL_set_mode(ev->ssl,SSL_MODE_ENABLE_PARTIAL_WRITE);
		SSL_set_fd(ev->ssl,ev->sockfd);

		rtn = ssl_connect_write(ev);
		return rtn;
}

inline void add_healthgroup_success_result(ev_t* ev)
{
		DialHealthResult result;
		DialRecordStatus rr;
		result.groupName.assign(ev->hg);
		result.policyName.assign(ev->policy);
		rr.rid.assign(ev->rid);
		rr.status = DialStatus::OK;
		rr.delay = ((ev->t_end.tv_sec * 1000*1000 + ev->t_end.tv_usec) - (ev->t_start.tv_sec * 1000*1000 + ev->t_start.tv_usec));
		result.statusList.push_back(rr);
		pthread_mutex_lock(&health_results_lock);
		health_results.push_back(result);
		pthread_mutex_unlock(&health_results_lock);

}

inline void add_nginxgroup_success_result(ev_t* ev)
{
		DialNginxResult result;
		DialNginxStatus sr;
		result.groupName.assign(ev->hg);
		result.policyName.assign(ev->policy);
		sr.server.localURL.assign(ev->rid);
		sr.server.priority = ev->priority;
		sr.status = DialStatus::OK;
		sr.delay = ((ev->t_end.tv_sec * 1000*1000 + ev->t_end.tv_usec) - (ev->t_start.tv_sec * 1000*1000 + ev->t_start.tv_usec));
		result.statusList.push_back(sr);
		pthread_mutex_lock(&nginx_results_lock);
		nginx_results.push_back(result);
		pthread_mutex_unlock(&nginx_results_lock);
}

inline void add_dc_success_result(ev_t* ev)
{
		DialDcResult result;
		result.id.assign(ev->rid);
		result.policy.assign(ev->policy);
		result.status = DialStatus::OK;
		result.delay = ((ev->t_end.tv_sec * 1000*1000 + ev->t_end.tv_usec) - (ev->t_start.tv_sec * 1000*1000 + ev->t_start.tv_usec));

		pthread_mutex_lock(&dc_results_lock);
		dc_results.push_back(result);
		pthread_mutex_unlock(&dc_results_lock);
}

int ssl_read(ev_t*ev)
{
		int size = 0,rtn = 0,status_code = 0;
		char*recv_buf = (char*)calloc(1,1024*1024);
		do
		{
				rtn = SSL_read(ev->ssl,recv_buf+size,1024);
				if(rtn < 0)
				{
						int ssl_conn_err = SSL_get_error(ev->ssl,rtn);
						if (SSL_ERROR_WANT_READ == ssl_conn_err) 
						{
								continue;
						}
						debug_printf(LOG_LEVEL_ERROR,"%s-%d-%s-ssl recv msg failed\n",__func__,__LINE__,ev->ip);
						free(recv_buf);
						return -1;
				}
				size += rtn;
		}
		while(rtn > 0 && size < 1024*1023);

		if(size > 0)
		{
				gettimeofday(&ev->t_end,NULL);
				healthpolicy_info_t * policy = find_healthpolicy_node_by_name(ev->policy);
				if(!policy)
				{
						free(recv_buf);
						debug_printf(LOG_LEVEL_ERROR,"%s-%d-%s-ssl recv msg success but find policy error\n",__func__,__LINE__,ev->ip);
						return -1;
				}

				if(policy->method == DIAL_SMTP)
				{
						if(strstr(recv_buf,"220") || strstr(recv_buf,"250"))
						{
								rtn = NO_ERROR;
						}
						else
						{
								rtn = ERROR;
						}
				}
				else
				{
						status_code = atoi(recv_buf + 9);
						rtn = check_httpget_result(&policy->dial_option,recv_buf,ev->pattern,(unsigned int)status_code);
				}

				if(rtn == NO_ERROR)
				{
						if(ev->dial_type == HEALTHGROUP)
						{
								add_healthgroup_success_result(ev);
								debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-healthgroup ssl recv msg and check result success\n",__func__,__LINE__,ev->ip);
						}
						else if(ev->dial_type == NGINX)
						{
								add_nginxgroup_success_result(ev);
								debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-nginx ssl recv msg and check result success\n",__func__,__LINE__,ev->ip);
						}
						else if(ev->dial_type == DC)
						{
								add_dc_success_result(ev);
								debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-dc ssl recv msg and check result success\n",__func__,__LINE__,ev->ip);
						}

						clean_ev(ev);
						free(recv_buf);

						return 0;
				}
		}

		debug_printf(LOG_LEVEL_ERROR,"%s-%d-%s-ssl recv msg size = %d,recv or check result failed\n",__func__,__LINE__,ev->ip,size);
		free(recv_buf);
		return -1;
}

int http_write(ev_t*ev)
{
		int size = 0;
		while((size = send(ev->sockfd,ev->send_buf,ev->send_len,0)) < 0)
		{
				if(errno == EINTR || errno == EAGAIN)
				{
						continue;
				}
				debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-http send msg failed\n",__func__,__LINE__,ev->ip);
				return -1;
		}
		if(size == ev->send_len)
		{
				ev->flag = 2;
				debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-http send msg success,send_len=%d\n",__func__,__LINE__,ev->ip,size);
				//debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-http send_buf=\n%s\n",__func__,__LINE__,ev->ip,ev->send_buf);
				return 0;
		}		
		debug_printf(LOG_LEVEL_ERROR,"%s-%d-%s-http send msg failed,send_len=%d\n",__func__,__LINE__,ev->ip,size);
		return -1;
}

int http_read(ev_t*ev)
{
		int rtn = 0;
		long size = 0;
		int status_code;
		char*recv_buf = (char*)calloc(1,1024*1024);

		do
		{
				rtn = recv(ev->sockfd,recv_buf+size,1024,0);
				if(rtn < 0)
				{
						if((errno == EINTR || errno == EAGAIN))
						{
								continue;
						}
						debug_printf(LOG_LEVEL_ERROR,"%s-%d-%s-http recv msg failed\n",__func__,__LINE__,ev->ip);
						free(recv_buf);
						return -1;
				}
				size += rtn;
		}
		while(rtn > 0 && size < 1024*1023);
		
		if(size > 0)
		{
				gettimeofday(&ev->t_end,NULL);
				healthpolicy_info_t * policy = find_healthpolicy_node_by_name(ev->policy);
				if(!policy)
				{
						free(recv_buf);
						debug_printf(LOG_LEVEL_ERROR,"%s-%d-%s-http recv msg success but find policy error\n",__func__,__LINE__,ev->ip);
						return -1;
				}

				if(policy->method == DIAL_SMTP)
				{
						if(strstr(recv_buf,"220") || strstr(recv_buf,"250"))
						{
								rtn = NO_ERROR;
						}
						else
						{
								rtn = ERROR;
						}
				}
				else
				{
						status_code = atoi(recv_buf + 9);
						rtn = check_httpget_result(&policy->dial_option,recv_buf,ev->pattern,(unsigned int)status_code);
				}

				if(rtn == NO_ERROR)
				{
						if(ev->dial_type == HEALTHGROUP)
						{
								add_healthgroup_success_result(ev);
								debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-healthgroup http recv msg and check result success\n",__func__,__LINE__,ev->ip);
						}
						else if(ev->dial_type == NGINX)
						{
								add_nginxgroup_success_result(ev);
								debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-nginxgroup http recv msg and check result success\n",__func__,__LINE__,ev->ip);
						}
						else if(ev->dial_type == DC)
						{
								add_dc_success_result(ev);
								debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-dc http recv msg and check result success\n",__func__,__LINE__,ev->ip);
						}

						epoll_ctl(ev->epfd,EPOLL_CTL_DEL,ev->sockfd,NULL);
						close(ev->sockfd);
						free(ev);
						free(recv_buf);

						return 0;
				}		
		}

		if(ev->dial_type == HEALTHGROUP)
		{
				debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-healthgroup http recv msg size=%d,recv or check result failed\n",__func__,__LINE__,ev->ip,size);
		}
		else if(ev->dial_type == NGINX)
		{
				debug_printf(LOG_LEVEL_DEBUG,"%s-%d-%s-nginxgroup http recv msg size=%d,recv or check result failed\n",__func__,__LINE__,ev->ip,size);
		}

		free(recv_buf);
		return -1;
}


int do_write_read(ev_t*ev,uint32_t events)
{
		int rtn = 0;
		if(ev->https_flag)
		{
				if(ev->flag == 1 && events & EPOLLOUT)
				{
						rtn = ssl_first_connect_write(ev);
				}
				else if(ev->flag == 2 && events & EPOLLOUT)
				{
						rtn = ssl_connect_write(ev);
				}
				else if(ev->flag == 3 && events & EPOLLIN)
				{
						rtn = ssl_read(ev);
				}
		}
		else
		{
				if(ev->flag == 1 && events & EPOLLOUT)
				{
						rtn = http_write(ev);
				}		
				else if(ev->flag == 2 && events & EPOLLIN)
				{
						rtn = http_read(ev);
				}
		}
		return rtn; 
}

inline void add_healthgroup_failed_result(ev_t* ev)
{
		DialHealthResult result;
		DialRecordStatus rr;
		result.groupName.assign(ev->hg);
		result.policyName.assign(ev->policy);
		rr.rid.assign(ev->rid);
		rr.status = DialStatus::FAIL;
		rr.delay = 0;
		result.statusList.push_back(rr);

		pthread_mutex_lock(&health_results_lock);
		health_results.push_back(result);
		pthread_mutex_unlock(&health_results_lock);
}

inline void add_nginxgroup_failed_result(ev_t* ev)
{
		DialNginxResult result;
		DialNginxStatus sr;
		result.groupName.assign(ev->hg);
		result.policyName.assign(ev->policy);
		sr.server.localURL.assign(ev->rid);
		sr.server.priority = ev->priority;
		sr.status = DialStatus::FAIL;
		sr.delay = 0;
		result.statusList.push_back(sr);

		pthread_mutex_lock(&nginx_results_lock);
		nginx_results.push_back(result);
		pthread_mutex_unlock(&nginx_results_lock);

}

inline void add_dc_failed_result(ev_t* ev)
{
		DialDcResult result;
		result.id.assign(ev->rid);
		result.policy.assign(ev->policy);
		result.status = DialStatus::FAIL;
		result.delay = 0;

		pthread_mutex_lock(&dc_results_lock);
		dc_results.push_back(result);
		pthread_mutex_unlock(&dc_results_lock);
}

void* https_handle_thread(void*arg)
{
		struct epoll_event events[4000];
		int fds = 0, i = 0,rtn = 0;

		while(1)
		{
				fds = epoll_wait(https_epfd,events,4000,-1);
				if(fds == -1 && errno == EINTR)
				{
						continue;
				}
				for(i = 0 ; i < fds ; i++)
				{
						ev_t* ev = (ev_t*)events[i].data.ptr;

						//debug_printf(LOG_LEVEL_DEBUG,"%s-%d-wait event=%d,ip=%s\n",__func__,__LINE__,events[i].events,ev->ip);
						
						if(events[i].events & EPOLLERR)
						{
								if(ev->dial_type == HEALTHGROUP)
								{
										add_healthgroup_failed_result(ev);
										debug_printf(LOG_LEVEL_ERROR,"%s-%d-healthgroup failed,events=%d,ip=%s\n",__func__,__LINE__,events[i].events,ev->ip);
								}
								else if(ev->dial_type == NGINX)
								{
										add_nginxgroup_failed_result(ev);
										debug_printf(LOG_LEVEL_ERROR,"%s-%d-nginx failed,events=%d,ip=%s\n",__func__,__LINE__,events[i].events,ev->ip);
								}		
								else if(ev->dial_type == DC)
								{
										add_dc_failed_result(ev);
										debug_printf(LOG_LEVEL_ERROR,"%s-%d-dc failed,events=%d,ip=%s\n",__func__,__LINE__,events[i].events,ev->ip);
								}

								epoll_ctl(ev->epfd,EPOLL_CTL_DEL,ev->sockfd,NULL);
								close(ev->sockfd);
								free(ev);
						}
						else if(events[i].events == (EPOLLOUT | EPOLLIN) || events[i].events == EPOLLOUT)
						{
								rtn = do_write_read(ev,events[i].events);
								if(rtn < 0)
								{
										if(ev->dial_type == HEALTHGROUP)
										{
												add_healthgroup_failed_result(ev);
										}
										else if(ev->dial_type == NGINX)
										{
												add_nginxgroup_failed_result(ev);
										}		
										else if(ev->dial_type == DC)
										{
												add_dc_failed_result(ev);
										}

										if(ev->https_flag)
										{
												clean_ev(ev);
										}
										else
										{
												epoll_ctl(ev->epfd,EPOLL_CTL_DEL,ev->sockfd,NULL);
												close(ev->sockfd);
												free(ev);
										}
								}
						}
				}
		}
}

int monitor_thread_init(pthread_t *td)
{
		int rtn = 0;

		if ((rtn = pthread_create(&td[0],NULL,healthgroup_monitor_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!healthgroup_monitor_thread,rtn = %d\n",rtn);
				return ERROR;
		}

		if ((rtn = pthread_create(&td[1],NULL,server_monitor_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!server_monitor_thread,rtn = %d\n",rtn);
				return ERROR;
		}

		if ((rtn = pthread_create(&td[2],NULL,nginxgroup_monitor_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!nginxgroup_monitor_thread,rtn = %d\n",rtn);
				return ERROR;
		}	

		if ((rtn = pthread_create(&td[3],NULL,snmpgroup_monitor_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!snmpgroup_monitor_thread,rtn = %d\n",rtn);
				return ERROR;
		}

		if ((rtn = pthread_create(&td[4],NULL,ipsec_monitor_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!ipsec_monitor_thread,rtn = %d\n",rtn);
				return ERROR;
		}

		if ((rtn = pthread_create(&td[5],NULL,dial_monitor_queue_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!dial_monitor_queue_thread,rtn = %d\n",rtn);
				return ERROR;
		}	

		if ((rtn = pthread_create(&td[6],NULL,updata_result_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed! updata_result_thread,rtn = %d\n",rtn);
				return ERROR;
		}	

		if ((rtn = pthread_create(&td[7],NULL,start_register_thread,NULL))!=0) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"main:pthread_create failed!start_register_thread,rtn = %d\n",rtn);
				return ERROR;
		}

		rtn = pthread_create(&td[8],NULL,https_monitor_thread,NULL);
		if(rtn < 0)
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"create_https_thrad:failed!!\n");
				return ERROR;
		}

		rtn = pthread_create(&td[9],NULL,https_handle_thread,NULL);
		if(rtn < 0)
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"create_https_thrad:failed!!\n");
				return ERROR;
		}
}

void check_port()
{
		FILE* fp = popen("pidof ymdial","r");
		if(NULL == fp) 
		{    
				printf("popen(pidof ymdial) error\n");
				exit(0);
		}   
		char cmd[128] = {'\0'};
		int len = fread(cmd,128,1,fp);
		int str_len = strlen(cmd);
		if(str_len <= 0)
		{   
				pclose(fp);
				return;
		}   

		printf("please after kill ymdial and start edns_dial...\n");
		pclose(fp);
		exit(0);
}

int main(int argc, char **argv) 
{
		int rtn = NO_ERROR;
		pthread_t td[MONITOR_THREAD_NUM] = {0};
		bool need_daemon = false;
		
		check_port();
		parse_arg(argc,argv,need_daemon);

		if(need_daemon)
		{
				daemon_start(1);
		}

		rtn = sys_init();
		if(rtn != NO_ERROR) 
		{
				printf("process start failed!\n");
				return ERROR;
		}

		set_core_file();
		set_file_limit();
		init_locks();
		
		rtn = threadpool_init(&tp,THREAD_POOL_NUM);
		if(0 != rtn) 
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"sys_init:threadpool_init  failed!!\n");
				return ERROR;
		}

		rtn = monitor_thread_init(td);
		if(ERROR == rtn)
		{
				cfg_debug_printf(LOG_LEVEL_BASIC,"monitor_thrad_init:failed!!\n");
				return ERROR;
		}

		cfg_debug_printf(LOG_LEVEL_BASIC,"*****************dial module start ***********\n");
		thrift_init(g_cfg.dial_port);
		cfg_debug_printf(LOG_LEVEL_BASIC,"*****************dial module over,thrift died! ***********\n");

		thread_exit_flag = false;
		sleep(5);
		kill_locks();
		sys_free();
		monitor_thread_join(td,MONITOR_THREAD_NUM);

		return NO_ERROR;
}

